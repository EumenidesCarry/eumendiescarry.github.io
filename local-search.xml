<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux 运维工程师面试总结</title>
    <link href="/2020/11/22/linux_interview/"/>
    <url>/2020/11/22/linux_interview/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>文章名称</th><th>linux 运维工程师面试题总结</th></tr></thead><tbody><tr><td>作者信息</td><td><a href="https://www.cuiliangblog.cn/blog/about/">https://www.cuiliangblog.cn/blog/about/</a></td></tr><tr><td>技术博客</td><td><a href="https://www.cuiliangblog.cn/">https://www.cuiliangblog.cn/</a></td></tr><tr><td>文章链接</td><td><a href="https://www.cuiliangblog.cn/blog/show-124/">https://www.cuiliangblog.cn/blog/show-124/</a></td></tr></tbody></table><h1 id="一、-linux"><a href="#一、-linux" class="headerlink" title="一、 linux"></a>一、 linux</h1><ol><li>系统启动流程</li><li>linux 文件类型</li><li>centos6 和 7 怎么添加程序开机自启动？</li><li>如何升级内核，目前最新版本号多少？</li><li>nginx 日志访问量前十的ip怎么统计？</li><li>删除 /var/log/ 下 .log 结尾的30天前的日志文件</li><li>ansible 有哪些模块？功能是什么？</li><li>nginx 性能为什么比 apache 高？</li><li>四层负载和七层负载区别是什么？</li><li>lvs 有哪些工作模式？哪个性能高？</li><li>lvs nginx haproxy keeplived 区别，优缺点？</li><li>如下 url 地址，各个部分的含义<br><a href="https://www.baidu.com/s?word=123&amp;ie=utf-8">https://www.baidu.com/s?word=123&amp;ie=utf-8</a></li><li>tomcat 各个目录含义，如何修改端口，如何修改内存数？</li><li>nginx 反向代理时，如何使后端获取真正的访问来源 ip？</li><li>nginx 负载均衡算法有哪些？</li><li>如何进行压力测试？</li><li>curl 命令如何发送 https 请求？如何查看 response 头信息？如何发送 get 和 post 表单信息？</li></ol><h1 id="二、-mysql"><a href="#二、-mysql" class="headerlink" title="二、 mysql"></a>二、 mysql</h1><ol><li>索引的为什么使查询加快？有啥缺点？</li><li>sql 语句左外连接 右外连接 内连接 全连接区别</li><li>mysql 数据备份方式，如何恢复？你们的备份策略是什么？</li><li>如何配置数据库主从同步，实际工作中是否遇到数据不一致问题？如何解决？</li><li>mysql 约束有哪些？</li><li>二进制日志（binlog）用途？</li><li>mysql 数据引擎有哪些？</li><li>如何查询 mysql 数据库存放路径？</li><li>mysql 数据库文件后缀名有哪些？用途什么？</li><li>如何修改数据库用户的密码？</li><li>如何修改用户权限？如何查看？</li></ol><h1 id="三、-nosql"><a href="#三、-nosql" class="headerlink" title="三、 nosql"></a>三、 nosql</h1><ol><li>redis 数据持久化有哪些方式？</li><li>redis 集群方案有哪些？</li><li>redis 如何进行数据备份与恢复？</li><li>MongoDB 如何进行数据备份？</li><li>kafka 为何比 redis rabbitmq 快？</li></ol><h1 id="四、-docker"><a href="#四、-docker" class="headerlink" title="四、 docker"></a>四、 docker</h1><ol><li>dockerfile 有哪些关键字？用途是什么？</li><li>如何减小 dockerfile 生成镜像体积？</li><li>dockerfile 中 CMD 与 ENTRYPOINT 区别是什么？</li><li>dockerfile 中 COPY 和 ADD 区别是什么？</li><li>docker 的 cs 架构组件有哪些？</li><li>docker 网络类型有哪些？</li><li>如何配置 docker 远程访问？</li><li>docker 核 心namespace CGroups 联合文件系统功能是什么？</li><li>命令相关：导入导出镜像，进入容器，设置重启容器策略，查看镜像环境变量，查看容器占用资源</li><li>构建镜像有哪些方式？</li><li>docker 和 vmware 虚拟化区别？</li></ol><h1 id="五、-kubernetes"><a href="#五、-kubernetes" class="headerlink" title="五、 kubernetes"></a>五、 kubernetes</h1><ol><li>k8s 的集群组件有哪些？功能是什么？</li><li>kubectl 命令相关：如何修改副本数，如何滚动更新和回滚，如何查看 pod 的详细信息，如何进入 pod 交互？</li><li>etcd 数据如何备份？</li><li>k8s 控制器有哪些？</li><li>哪些是集群级别的资源？</li><li>pod 状态有哪些？</li><li>pod 创建过程是什么？</li><li>pod 重启策略有哪些？</li><li>资源探针有哪些？</li><li>requests 和 limits 用途是什么？</li><li>kubeconfig 文件包含什么内容，用途是什么？</li><li>RBAC中role 和 clusterrole 区别，rolebinding 和 clusterrolebinding 区别？</li><li>ipvs 为啥比 iptables 效率高？</li><li>sc pv pvc 用途，容器挂载存储整个流程是什么？</li><li>nginx ingress 的原理本质是什么？</li><li>网络类型，描述不同 node 上的 Pod 之间的通信流程</li><li>k8s 集群节点需要关机维护，需要怎么操作</li></ol><h1 id="六、-prometheus"><a href="#六、-prometheus" class="headerlink" title="六、 prometheus"></a>六、 prometheus</h1><ol><li>prometheus 对比 zabbix 有哪些优势？</li><li>prometheus 组件有哪些，功能是什么？</li><li>指标类型有哪些？</li><li>在应对上千节点监控时，如何保障性能<br>（降低采集频率，缩小历史数据保存天数，使用集群联邦和远程存储）</li><li>简述从添加节点监控到 grafana 成图的整个流程</li><li>在工作中用到了哪些 exporter</li></ol><h1 id="七、-ELK"><a href="#七、-ELK" class="headerlink" title="七、 ELK"></a>七、 ELK</h1><ol><li>Elasticsearch 的数据如何备份与恢复？</li><li>你们项目中使用的 logstash 过滤器插件是什么？实现哪些功能？</li><li>是否用到了 filebeat 的内置 module？用了哪些？</li><li>kibana 如何自定义图表和仪表盘？</li><li>elasticsearch 分片副本是什么？你们配置的参数是多少？</li></ol><h1 id="八、-运维开发"><a href="#八、-运维开发" class="headerlink" title="八、 运维开发"></a>八、 运维开发</h1><ol><li>备份系统中所有镜像</li><li>编写脚本，定时备份某个库，然后压缩，发送异机<br>（注意：①公共部分定义函数，如获取时间戳，配置报警接口②异常处理，如数据库大，检测任务是否完成。检测生成文件大小是否是空文件）</li><li>批量获取所有主机的系统信息</li><li>django 的 mtv 模式流程</li><li>python 如何导出、导入环境依赖包</li><li>python 创建，进入，退出，查看虚拟环境</li><li>flask 和 django 区别，应用场景</li><li>flask开发一个 hello word 页面流程</li><li>列举常用的 git 命令</li><li>git gitlab jenkins 的 CICD 流程如何配置</li></ol><h1 id="九、-日常工作"><a href="#九、-日常工作" class="headerlink" title="九、 日常工作"></a>九、 日常工作</h1><ol><li>在日常工作中遇到了什么棘手的问题，如何排查<br>（① redis 弱口令导致中挖矿病毒，排查，优化 ② k8s 中开发的程序在用户上传文件时开启进程，未及时关闭，导致节点超出最大进程数）</li><li>日常故障处理流程</li><li>修改线上业务配置文件流程</li><li>业务 pv 多少？集群规模多少？怎么保障业务高可用？</li></ol><h1 id="十、-开放性问题"><a href="#十、-开放性问题" class="headerlink" title="十、 开放性问题"></a>十、 开放性问题</h1><ol><li>你认为初级运维工程师和高级运维工程师的区别？（初级干活的，会操作，顺利完成领导安排的任务。高级优化架构，研究如何避免问题，研究新技术并引用）</li><li>你认为未来运维发展方向（自动化，智能化）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 简单配置</title>
    <link href="/2020/10/21/nginx/"/>
    <url>/2020/10/21/nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-基础概念"><a href="#一、-基础概念" class="headerlink" title="一、 基础概念"></a>一、 基础概念</h1><p>Nginx 是一个高性能的 <strong>HTTP</strong> 和<strong>反向代理服务器</strong>，特点是占用<strong>内存少</strong>，<strong>并发能力强</strong>，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p><p>Nginx 相对于 Apache 优点：</p><ul><li>高并发响应性能非常好，官方 Nginx 处理静态文件并发 5w/s</li><li>负载均衡及反向代理性能非常强</li><li>系统内存和 CPU 占用率低</li><li>可以对后端服务进行将康检查</li><li>支持 PHP cgi 方式和 FastCGI 方式</li><li>可作为缓存服务器、邮件代理服务器</li><li>配置代码简洁且容易上手</li></ul><h2 id="1-1-静态页面"><a href="#1-1-静态页面" class="headerlink" title="1.1 静态页面"></a>1.1 静态页面</h2><p><strong>静态页面</strong>通常指不与数据库发生交互的页面，是一种基于 w3c 规范的一种网页书写格式，是一种统一协议语言，所以称之为静态网页。静态页面被设计好之后，一般很少去修改，不随着浏览器参数改变而内容改变，需注意的是动态的图片也是属于静态文件。从 SEO 角度来讲，HTML 页面更有利于搜索引擎的爬行和收录。常见的静态页面以 .html、 .gif、 .jpg、 .jpeg、 .bmp、 .png、 .ico、 .txt、 .js、 .css 等结尾。</p><h2 id="1-2-动态页面"><a href="#1-2-动态页面" class="headerlink" title="1.2 动态页面"></a>1.2 动态页面</h2><p><strong>动态页面</strong>通常指与数据库发生交互的页面，内容展示丰富，功能非常强大，实用性广。从 SEO 角度来讲，搜索引擎很难全面的爬行和收录动态网页，因为动态网页会随着数据库的更新、参数的变更而发生改变，常见的动态页面以 .jsp、.php、.do、.asp、.cgi、.apsx 等结尾。</p><h1 id="二、-工作原理"><a href="#二、-工作原理" class="headerlink" title="二、 工作原理"></a>二、 工作原理</h1><p>Nginx WEB 服务器最主要的就是各个模块的工作，模块从结构上分为<strong>核心模块</strong>、<strong>基础模块</strong>和<strong>第三方模块</strong>，其中三类模块分别为：</p><ul><li>核心模块：<strong>HTTP</strong> 模块、<strong>EVENT</strong> 模块和 <strong>MAIL</strong> 模块等</li><li>基础模块：HTTP Access 模块、HTTP FastCGI 模块、HTTP Proxy 模块和 HTTP Rewrite 模块</li><li>第三方模块：HTTP Upstream Request Hash 模块、Notice 模块、HTTP Access Key 模块、Limit_req 模块和 Upstream check module 等</li></ul><p>Nginx 的模块从功能上分为：</p><ul><li><font color=red>Handlers（处理器模块）：此类模块直接处理请求，并进行输出内容和修改 headers 信息等操作，Handlers 处理器模块一般只能有一个</font></li><li><font color=red>Filters（过滤器模块）：此类模块主要是对其他模块输出的内容进行修改操作，最后有 Nginx 输出</font></li><li>Proxys（代理类模块）：此类模块是 Nginx 的 HTTP Upstream 之类的模块，这些模块主要与后端一些服务比如 FastCGI 等进行交互，实现服务代理和负载均衡等功能</li></ul><pre><code class="hljs routeros"><span class="hljs-comment"># user  nobody;</span>worker_processes  1;<span class="hljs-comment"># error_log  logs/error.log;</span><span class="hljs-comment"># error_log  logs/error.log  notice;</span><span class="hljs-comment"># error_log  logs/error.log  info;</span><span class="hljs-comment">#pid        logs/nginx.pid;</span>events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    # log_format  main  <span class="hljs-string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span>    #                   <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span>    #                   <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;    # access_log  logs/access.log  main;    sendfile        on;    # tcp_nopush     on;    # keepalive_timeout  0;    keepalive_timeout  65;    # gzip  on;   <span class="hljs-built_in"> server </span>&#123;        listen       80;        server_name  localhost;        # charset koi8-r;        # access_log  logs/host.access.log  main;        location / &#123;            root   html;            index  index.html index.htm;        &#125;        # error_page  404              /404.html;        # redirect<span class="hljs-built_in"> server </span><span class="hljs-builtin-name">error</span> pages <span class="hljs-keyword">to</span> the static<span class="hljs-built_in"> page </span>/50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;    &#125;&#125;</code></pre><h2 id="2-1-Nginx-运行原理"><a href="#2-1-Nginx-运行原理" class="headerlink" title="2.1 Nginx 运行原理"></a>2.1 Nginx 运行原理</h2><p>Nginx  由 <strong>Nginx 内核</strong>和<strong>模块</strong>组成，其中内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端的请求映射到一个 <font color=red>location block</font>，而 location 是 Nginx 配置中的一个指令，用于访问的 URL 匹配，而在这个 location 中所配置的每个指令将会启动不同的模块去完成相应的工作。</p><p><strong>location block</strong></p><pre><code class="hljs glsl"><span class="hljs-meta">#访问根 /</span><span class="hljs-keyword">location</span> / &#123;            root   html;            <span class="hljs-meta"># 以 /usr/local/nginx/ 为基础的目录</span>            <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;        &#125;</code></pre><p>根页面：</p><p><img src="/img/nginx/nginx_1.jpg"></p><pre><code class="hljs crmsh"><span class="hljs-comment"># = 精确匹配</span><span class="hljs-keyword">location</span> <span class="hljs-title">= /50x</span>.html &#123;            root   html; <span class="hljs-comment">#以/usr/local/nginx/为基础的目录</span>        &#125;</code></pre><p>精准匹配 50x 页面：<br><img src="/img/nginx/nginx_1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 简单上手</title>
    <link href="/2020/10/13/docker/"/>
    <url>/2020/10/13/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-Docker-简介"><a href="#一、-Docker-简介" class="headerlink" title="一、 Docker 简介"></a>一、 Docker 简介</h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h2><ul><li>使用最广泛的开源容器引擎</li><li>一种操作系统级别的虚拟化技术</li><li>依赖于 Linux 内核特性：<strong>Namespace</strong>（<font color=red>资源隔离</font>）和 <strong>Cgroups</strong>（<font color=red>资源限制</font>）</li><li>一个简单的应用程序打包工具</li></ul><h2 id="1-2-基本组成"><a href="#1-2-基本组成" class="headerlink" title="1.2 基本组成"></a>1.2 基本组成</h2><ul><li>Docker Client：客户端</li><li>Docker Daemon：守护进程</li><li>Docker Images：镜像</li><li>Docker Container：容器</li><li>Docker Registry：镜像仓库</li></ul><p><img src="https://docs.docker.com/engine/images/architecture.svg"></p><h2 id="1-3-容器-VS-VM"><a href="#1-3-容器-VS-VM" class="headerlink" title="1.3 容器 VS VM"></a>1.3 容器 VS VM</h2><p><img src="/img/Docker/Docker_1.jpg"></p><table><thead><tr><th></th><th>容器</th><th>VM</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>运行性能</td><td>接近原生</td><td>5%左右损失</td></tr><tr><td>磁盘占用</td><td>MB</td><td>GB</td></tr><tr><td>数量</td><td>成百上千</td><td>一般几十台</td></tr><tr><td>隔离性</td><td>进程隔离</td><td>系统级（彻底）</td></tr><tr><td>操作系统</td><td>只支持 Linux</td><td>所有</td></tr><tr><td>封装进度</td><td>只打包项目代码和依赖关系，共享宿主机内核</td><td>完整的操作系统</td></tr></tbody></table><h2 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h2><ul><li>应用程序打包和发布</li><li>应用程序隔离</li><li>持续的集成</li><li>部署微服务</li><li>快速搭建测试环境</li><li>提供 PaaS（Platform as a Service），指平台即服务</li></ul><h1 id="二、-Docker-安装"><a href="#二、-Docker-安装" class="headerlink" title="二、 Docker 安装"></a>二、 Docker 安装</h1><h2 id="2-1-CentOS-7-安装（使用-yum-安装）"><a href="#2-1-CentOS-7-安装（使用-yum-安装）" class="headerlink" title="2.1 CentOS 7 安装（使用 yum 安装）"></a>2.1 CentOS 7 安装（使用 yum 安装）</h2><h3 id="官方安装手册"><a href="#官方安装手册" class="headerlink" title="官方安装手册"></a>官方安装手册</h3><p>地址：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><h3 id="阿里源安装手册（推荐）"><a href="#阿里源安装手册（推荐）" class="headerlink" title="阿里源安装手册（推荐）"></a>阿里源安装手册（推荐）</h3><p>使用<a href="https://developer.aliyun.com/mirror/docker-ce?spm=a2c6h.13651102.0.0.3e221b11q3kwWA">阿里源</a>安装 Docker</p><p>删除旧版本的 docker：</p><pre><code class="hljs latex"><span class="hljs-formula">$ sudo yum remove docker <span class="hljs-tag">\</span></span><span class="hljs-formula">                  docker-client <span class="hljs-tag">\</span></span><span class="hljs-formula">                  docker-client-latest <span class="hljs-tag">\</span></span><span class="hljs-formula">                  docker-common <span class="hljs-tag">\</span></span><span class="hljs-formula">                  docker-latest <span class="hljs-tag">\</span></span><span class="hljs-formula">                  docker-latest-logrotate <span class="hljs-tag">\</span></span><span class="hljs-formula">                  docker-logrotate <span class="hljs-tag">\</span></span><span class="hljs-formula">                  docker-engine</span></code></pre><p>安装步骤：</p><pre><code class="hljs vala"><span class="hljs-meta"># step 1: 安装必要的一些系统工具</span>sudo yum install -y yum-utils device-mapper-persistent-data lvm2<span class="hljs-meta"># Step 2: 添加软件源信息</span>sudo yum-config-manager --add-repo https:<span class="hljs-comment">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><span class="hljs-meta"># Step 3: 更新 yum 软件包索引并安装Docker-CE</span>sudo yum makecache fastsudo yum -y install docker-ce<span class="hljs-meta"># Step 4: 开启Docker服务</span>sudo service docker start<span class="hljs-meta"># 注意：</span><span class="hljs-meta"># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。</span><span class="hljs-meta"># vim /etc/yum.repos.d/docker-ee.repo</span><span class="hljs-meta">#   将[docker-ce-test]下方的enabled=0修改为enabled=1</span><span class="hljs-meta">#</span><span class="hljs-meta"># 安装指定版本的Docker-CE:</span><span class="hljs-meta"># Step 1: 查找Docker-CE的版本:</span><span class="hljs-meta"># yum list docker-ce.x86_64 --showduplicates | sort -r</span><span class="hljs-meta">#   Loading mirror speeds from cached hostfile</span><span class="hljs-meta">#   Loaded plugins: branch, fastestmirror, langpacks</span><span class="hljs-meta">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span><span class="hljs-meta">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span><span class="hljs-meta">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span><span class="hljs-meta">#   Available Packages</span><span class="hljs-meta"># Step2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.0.ce.1-1.el7.centos)</span><span class="hljs-meta"># sudo yum -y install docker-ce-[VERSION]</span></code></pre><p>校验安装：</p><pre><code class="hljs yaml">[<span class="hljs-string">root@test</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># docker version</span><span class="hljs-attr">Client:</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Engine</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Community</span> <span class="hljs-attr">Version:</span>           <span class="hljs-number">19.03</span><span class="hljs-number">.13</span> <span class="hljs-attr">API version:</span>       <span class="hljs-number">1.40</span> <span class="hljs-attr">Go version:</span>        <span class="hljs-string">go1.13.15</span> <span class="hljs-attr">Git commit:</span>        <span class="hljs-string">4484c46d9d</span> <span class="hljs-attr">Built:</span>             <span class="hljs-string">Wed</span> <span class="hljs-string">Sep</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span><span class="hljs-string">:03:45</span> <span class="hljs-number">2020</span> <span class="hljs-attr">OS/Arch:</span>           <span class="hljs-string">linux/amd64</span> <span class="hljs-attr">Experimental:</span>      <span class="hljs-literal">false</span><span class="hljs-attr">Server:</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Engine</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Community</span> <span class="hljs-attr">Engine:</span>  <span class="hljs-attr">Version:</span>          <span class="hljs-number">19.03</span><span class="hljs-number">.13</span>  <span class="hljs-attr">API version:</span>      <span class="hljs-number">1.40</span> <span class="hljs-string">(minimum</span> <span class="hljs-string">version</span> <span class="hljs-number">1.12</span><span class="hljs-string">)</span>  <span class="hljs-attr">Go version:</span>       <span class="hljs-string">go1.13.15</span>  <span class="hljs-attr">Git commit:</span>       <span class="hljs-string">4484c46d9d</span>  <span class="hljs-attr">Built:</span>            <span class="hljs-string">Wed</span> <span class="hljs-string">Sep</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span><span class="hljs-string">:02:21</span> <span class="hljs-number">2020</span>  <span class="hljs-attr">OS/Arch:</span>          <span class="hljs-string">linux/amd64</span>  <span class="hljs-attr">Experimental:</span>     <span class="hljs-literal">false</span> <span class="hljs-attr">containerd:</span>  <span class="hljs-attr">Version:</span>          <span class="hljs-number">1.3</span><span class="hljs-number">.7</span>  <span class="hljs-attr">GitCommit:</span>        <span class="hljs-string">8fba4e9a7d01810a393d5d25a3621dc101981175</span> <span class="hljs-attr">runc:</span>  <span class="hljs-attr">Version:</span>          <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><span class="hljs-string">-rc10</span>  <span class="hljs-attr">GitCommit:</span>        <span class="hljs-string">dc9208a3303feef5b3839f4323d9beb36df0a9dd</span> <span class="hljs-attr">docker-init:</span>  <span class="hljs-attr">Version:</span>          <span class="hljs-number">0.18</span><span class="hljs-number">.0</span>  <span class="hljs-attr">GitCommit:</span>        <span class="hljs-string">fec3683</span></code></pre><p>运行 <strong>HELLO WORLD</strong>:</p><pre><code class="hljs livescript">[root@test ~]<span class="hljs-comment"># docker run hello-world</span><span class="hljs-comment">#由于本地没有 hello-world 这个镜像，所以会下载一个 hello-world 的镜像，并在容器中运行</span>Unable <span class="hljs-keyword">to</span> find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locallylatest: Pulling <span class="hljs-keyword">from</span> library/hello-world<span class="hljs-number">0e</span>03bdcc26d7: Pull complete Digest: sha256:<span class="hljs-number">4cf</span>9c47f86df71d48364001ede3a4fcd85ae80ce02ebad74156906caff5378bcStatus: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<span class="hljs-comment">#上面安装，下面运行</span>Hello <span class="hljs-keyword">from</span> Docker!This message shows <span class="hljs-literal">that</span> your installation appears <span class="hljs-keyword">to</span> be working correctly.To generate <span class="hljs-built_in">this</span> message, Docker took the following steps: <span class="hljs-number">1.</span> The Docker client contacted the Docker daemon. <span class="hljs-number">2.</span> The Docker daemon pulled the <span class="hljs-string">&quot;hello-world&quot;</span> image <span class="hljs-keyword">from</span> the Docker Hub.    (amd64) <span class="hljs-number">3.</span> The Docker daemon created a <span class="hljs-keyword">new</span> container <span class="hljs-keyword">from</span> <span class="hljs-literal">that</span> image which runs the    executable <span class="hljs-literal">that</span> produces the output you are currently reading. <span class="hljs-number">4.</span> The Docker daemon streamed <span class="hljs-literal">that</span> output <span class="hljs-keyword">to</span> the Docker client, which sent <span class="hljs-literal">it</span>    <span class="hljs-keyword">to</span> your terminal.To <span class="hljs-keyword">try</span> something more ambitious, you can run an Ubuntu container with: $ docker run -<span class="hljs-literal">it</span> ubuntu bashShare images, automate workflows, <span class="hljs-keyword">and</span> more <span class="hljs-keyword">with</span> a free Docker ID: https:<span class="hljs-regexp">//hub.docker.com/</span><span class="hljs-regexp"></span><span class="hljs-regexp">For more examples and ideas, visit:</span><span class="hljs-regexp"> https://</span>docs.docker.com/get-started/</code></pre><p><strong>run</strong> 启动流程：</p><p><img src="/img/Docker/Docker_2.jpg"></p><h2 id="2-2-获取镜像"><a href="#2-2-获取镜像" class="headerlink" title="2.2 获取镜像"></a>2.2 获取镜像</h2><h3 id="Docker-Hub-官方镜像"><a href="#Docker-Hub-官方镜像" class="headerlink" title="Docker Hub 官方镜像"></a>Docker Hub 官方镜像</h3><p>官方镜像地址：<a href="https://hub.docker.com/explore">https://hub.docker.com/explore</a></p><h3 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h3><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li>网易：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></li><li>阿里云：https://&lt;你的ID&gt;.mirror.aliyuncs.com</li></ul><p>阿里云镜像获取地址：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a> ，登录后可见加速地址。</p><p><img src="/img/Docker/Docker_3.jpg"></p><p>通过修改 <code>/etc/docker/daemon.json</code> 文件配置镜像加速器：</p><pre><code class="hljs awk"><span class="hljs-comment">#-p 确保目录名称存在，不存在的就建一个。</span>sudo mkdir -p <span class="hljs-regexp">/etc/</span>docker<span class="hljs-comment">#下面加速二选一，如果效果不理想，试着切换</span><span class="hljs-comment">#163加速</span>sudo tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span>&#123;  &#123;<span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>] &#125;&#125;EOF<span class="hljs-comment">#阿里源加速</span>sudo tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span>&#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://0hm4nl4c.mirror.aliyuncs.com&quot;</span>]&#125;EOFcat <span class="hljs-regexp">/etc/</span>docker/daemon.json &#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://0hm4nl4c.mirror.aliyuncs.com&quot;</span>]&#125;sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h1 id="三、-Docker-常用命令"><a href="#三、-Docker-常用命令" class="headerlink" title="三、 Docker 常用命令"></a>三、 Docker 常用命令</h1><h2 id="3-1-帮助命令"><a href="#3-1-帮助命令" class="headerlink" title="3.1 帮助命令"></a>3.1 帮助命令</h2><h3 id="3-1-1-docker-version"><a href="#3-1-1-docker-version" class="headerlink" title="3.1.1 docker version"></a>3.1.1 docker version</h3><pre><code class="hljs yaml">[<span class="hljs-string">root@test</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># docker version</span><span class="hljs-attr">Client:</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Engine</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Community</span> <span class="hljs-attr">Version:</span>           <span class="hljs-number">19.03</span><span class="hljs-number">.13</span> <span class="hljs-attr">API version:</span>       <span class="hljs-number">1.40</span> <span class="hljs-attr">Go version:</span>        <span class="hljs-string">go1.13.15</span> <span class="hljs-attr">Git commit:</span>        <span class="hljs-string">4484c46d9d</span> <span class="hljs-attr">Built:</span>             <span class="hljs-string">Wed</span> <span class="hljs-string">Sep</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span><span class="hljs-string">:03:45</span> <span class="hljs-number">2020</span> <span class="hljs-attr">OS/Arch:</span>           <span class="hljs-string">linux/amd64</span> <span class="hljs-attr">Experimental:</span>      <span class="hljs-literal">false</span><span class="hljs-attr">Server:</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Engine</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Community</span> <span class="hljs-attr">Engine:</span>  <span class="hljs-attr">Version:</span>          <span class="hljs-number">19.03</span><span class="hljs-number">.13</span>  <span class="hljs-attr">API version:</span>      <span class="hljs-number">1.40</span> <span class="hljs-string">(minimum</span> <span class="hljs-string">version</span> <span class="hljs-number">1.12</span><span class="hljs-string">)</span>  <span class="hljs-attr">Go version:</span>       <span class="hljs-string">go1.13.15</span>  <span class="hljs-attr">Git commit:</span>       <span class="hljs-string">4484c46d9d</span>  <span class="hljs-attr">Built:</span>            <span class="hljs-string">Wed</span> <span class="hljs-string">Sep</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span><span class="hljs-string">:02:21</span> <span class="hljs-number">2020</span>  <span class="hljs-attr">OS/Arch:</span>          <span class="hljs-string">linux/amd64</span>  <span class="hljs-attr">Experimental:</span>     <span class="hljs-literal">false</span> <span class="hljs-attr">containerd:</span>  <span class="hljs-attr">Version:</span>          <span class="hljs-number">1.3</span><span class="hljs-number">.7</span>  <span class="hljs-attr">GitCommit:</span>        <span class="hljs-string">8fba4e9a7d01810a393d5d25a3621dc101981175</span> <span class="hljs-attr">runc:</span>  <span class="hljs-attr">Version:</span>          <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><span class="hljs-string">-rc10</span>  <span class="hljs-attr">GitCommit:</span>        <span class="hljs-string">dc9208a3303feef5b3839f4323d9beb36df0a9dd</span> <span class="hljs-attr">docker-init:</span>  <span class="hljs-attr">Version:</span>          <span class="hljs-number">0.18</span><span class="hljs-number">.0</span>  <span class="hljs-attr">GitCommit:</span>        <span class="hljs-string">fec3683</span></code></pre><h3 id="3-1-2-docker-info"><a href="#3-1-2-docker-info" class="headerlink" title="3.1.2 docker info"></a>3.1.2 docker info</h3><h3 id="3-1-3-docker-–help"><a href="#3-1-3-docker-–help" class="headerlink" title="3.1.3 docker –help"></a>3.1.3 docker –help</h3><h2 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h2><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>ls</td><td>列出镜像</td></tr><tr><td>build</td><td>构建镜像来自 Dockerfile</td></tr><tr><td>history</td><td>查看镜像历史</td></tr><tr><td>inspect</td><td>显示一个或多个镜像详细信息</td></tr><tr><td>pull</td><td>从镜像仓库拉去镜像</td></tr><tr><td>push</td><td>推送一个或多个镜像到镜像仓库</td></tr><tr><td>rm</td><td>移除一个或者多个镜像</td></tr><tr><td>prune</td><td>移除未使用的镜像。没有被标记或被任何容器引用的</td></tr><tr><td>tag</td><td>创建一个引用源镜像标记目标镜像</td></tr><tr><td>export</td><td>导出容器文件系统到tar归档文件</td></tr><tr><td>import</td><td>导入容器文件系统tar归档文件创建镜像</td></tr><tr><td>save</td><td>保存一个或多个镜像到一个tar归档文件</td></tr><tr><td>load</td><td>加载镜像来自tar归档或标准输入</td></tr></tbody></table><h3 id="3-2-1-docker-images"><a href="#3-2-1-docker-images" class="headerlink" title="3.2.1 docker images"></a>3.2.1 docker images</h3><p>显示本地镜像：</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>test ~]# docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEnginx               latest              <span class="hljs-number">992e3</span>b7be046        <span class="hljs-number">6</span> days ago          <span class="hljs-number">133</span>MBhello-world         latest              bf756fb1ae65        <span class="hljs-number">9</span> months ago        <span class="hljs-number">13.3</span>kB</code></pre><h4 id="options"><a href="#options" class="headerlink" title="options:"></a>options:</h4><ul><li>-a ：列出本地所有镜像</li><li>-q ：只显示镜像 ID</li><li>–digests ：显示镜像的摘要信息</li><li>–no-trunc ：显示完整的镜像信息</li></ul><h3 id="3-2-2-docker-search"><a href="#3-2-2-docker-search" class="headerlink" title="3.2.2 docker search"></a>3.2.2 docker search</h3><p><code>docker search 指定镜像名</code></p><pre><code class="hljs routeros">[root@test ~]# docker search nginxNAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDnginx                              Official build of Nginx.                        13838               [OK]                jwilder/nginx-proxy                Automated Nginx reverse<span class="hljs-built_in"> proxy </span><span class="hljs-keyword">for</span> docker con…   1893                                    [OK]richarvey/nginx-php-fpm            Container running Nginx + PHP-FPM capable of…   790                                     [OK]linuxserver/nginx                  An Nginx container, brought <span class="hljs-keyword">to</span> you by LinuxS…   127                                     jc21/nginx-proxy-manager           Docker container <span class="hljs-keyword">for</span> managing Nginx<span class="hljs-built_in"> proxy </span>ho…   96                                      tiangolo/nginx-rtmp                Docker image with Nginx using the nginx-rtmp…   95                                      [OK]</code></pre><h4 id="options-1"><a href="#options-1" class="headerlink" title="options:"></a>options:</h4><p>docker search [options] 镜像名字</p><ul><li>–no-trunc ：显示完整的镜像描述</li><li>-s ：列出收藏数不小于指定值的镜像</li><li>–automated ：只列出 automated build 类型镜像</li></ul><h3 id="3-2-3-docker-pull"><a href="#3-2-3-docker-pull" class="headerlink" title="3.2.3 docker pull"></a>3.2.3 docker pull</h3><p><code>docker pull 镜像名[:TAG]</code> ：下载镜像，不加 TAG 默认下载 latest</p><pre><code class="hljs routeros">[root@test ~]# docker pull nginxUsing<span class="hljs-built_in"> default </span>tag: latestlatest: Pulling <span class="hljs-keyword">from</span> library/nginx</code></pre><h3 id="3-2-4-docker-image-rm"><a href="#3-2-4-docker-image-rm" class="headerlink" title="3.2.4 docker image rm"></a>3.2.4 docker image rm</h3><p><code>docker image rm 镜像ID</code> ：删除镜像</p><ul><li>docker image rm -f 镜像ID ：删除单个</li><li>docker image rm -f 镜像1ID 镜像2ID ：删除多个镜像</li><li>docker image rm -f $(docker images -qa) ：删除所有镜像</li></ul><h2 id="3-3-容器命令"><a href="#3-3-容器命令" class="headerlink" title="3.3 容器命令"></a>3.3 容器命令</h2><p><font color=red>有镜像才能够创建容器</font>，下载 CentOS 镜像演示：<code>docker pull centos</code></p><h3 id="3-3-1-新建并启动容器"><a href="#3-3-1-新建并启动容器" class="headerlink" title="3.3.1 新建并启动容器"></a>3.3.1 新建并启动容器</h3><p><code>docker run [options] image [command] [arg]</code></p><h4 id="options-2"><a href="#options-2" class="headerlink" title="options"></a>options</h4><ul><li>–name=”new name” ：为容器指定一个名称</li><li>-d,-detach ：后台运行容器，并返回容器ID，也即启动守护式容器</li><li>-e,-env ：设置环境变量</li><li>-i,-interactive ：以交互模式运行容器，通常与 -t 同时使用</li><li>-t,-tty ：为容器重新分配一个伪终端，通常与 -i 同时使用</li><li>-P ：发布容器所有 EXPOSE 的端口到宿主机随机端口</li><li>-p ：发布容器端口到主机<ul><li>ip:hostPort:containerPort</li><li>ip::containerPort</li><li>hostPort:containerPort</li><li>containerPort</li></ul></li><li>-h ：设置容器主机名</li><li>-ip string ：指定容器 ip，只能用于自定义网络</li><li>-network ：连接容器到一个网络</li><li>-mount mount ：将文件系统附加到容器</li><li>-v，-volume list ：绑定挂载一个卷</li><li>-restart string ：容器退出时重启策略，默认 no，可选值：[always|on-failure]</li></ul><pre><code class="hljs gradle">#使用镜像centos:latest以交互模式启动一个容器，在容器内执行<span class="hljs-regexp">/bin/</span>bash命令[root@test ~]# docker run -it centos <span class="hljs-regexp">/bin/</span>bash[root@<span class="hljs-number">7808</span>a5311ae1 <span class="hljs-regexp">/]# cat /</span>etc/redhat-release CentOS Linux release <span class="hljs-number">8.2</span>.<span class="hljs-number">2004</span> (Core)</code></pre><h3 id="3-3-2-列出当前运行的容器"><a href="#3-3-2-列出当前运行的容器" class="headerlink" title="3.3.2 列出当前运行的容器"></a>3.3.2 列出当前运行的容器</h3><p><code>docker ps [options]</code></p><h4 id="options-3"><a href="#options-3" class="headerlink" title="options"></a>options</h4><ul><li>-a ：列出当前所有正在运行的容器和历史上运行过的</li><li>-l ：显示最新创建的容器</li><li>-q ：静默模式，只显示容器编号</li><li>–no-trunc ：不截断输出</li></ul><h3 id="3-3-3-退出容器"><a href="#3-3-3-退出容器" class="headerlink" title="3.3.3 退出容器"></a>3.3.3 退出容器</h3><h4 id="容器停止并退出"><a href="#容器停止并退出" class="headerlink" title="容器停止并退出"></a>容器停止并退出</h4><p><code>exit</code></p><h4 id="容器不停止退出"><a href="#容器不停止退出" class="headerlink" title="容器不停止退出"></a>容器不停止退出</h4><p><code>ctrl+P+Q</code></p><h3 id="3-3-4-启动容器"><a href="#3-3-4-启动容器" class="headerlink" title="3.3.4 启动容器"></a>3.3.4 启动容器</h3><p><code>docker start 容器ID或者容器名</code></p><h3 id="3-3-5-重启容器"><a href="#3-3-5-重启容器" class="headerlink" title="3.3.5 重启容器"></a>3.3.5 重启容器</h3><p><code>docker restart 容器ID或者容器名</code></p><h3 id="3-3-6-停止容器"><a href="#3-3-6-停止容器" class="headerlink" title="3.3.6 停止容器"></a>3.3.6 停止容器</h3><p><code>docker stop 容器ID或者容器名</code></p><h3 id="3-3-7-强制停止容器"><a href="#3-3-7-强制停止容器" class="headerlink" title="3.3.7 强制停止容器"></a>3.3.7 强制停止容器</h3><p><code>docker kill 容器ID或者容器名</code></p><h3 id="3-3-8-删除已停止的容器"><a href="#3-3-8-删除已停止的容器" class="headerlink" title="3.3.8 删除已停止的容器"></a>3.3.8 删除已停止的容器</h3><p><code>docker rm 容器ID</code></p><p>一次性删除多个容器：</p><ul><li><code>docker rm -f $(docker pa -a -q)</code></li><li><code>docker ps -a -q | xargs docker rm</code></li></ul><h2 id="3-4-比较重要的命令"><a href="#3-4-比较重要的命令" class="headerlink" title="3.4 比较重要的命令"></a>3.4 比较重要的命令</h2><h3 id="3-4-1-启动守护式容器"><a href="#3-4-1-启动守护式容器" class="headerlink" title="3.4.1 启动守护式容器"></a>3.4.1 启动守护式容器</h3><p><code>docker run -d 容器名</code></p><p>使用镜像centos:latest以后台模式启动一个容器<code>docker run -d centos</code></p><p><strong>问题</strong>：<br>然后 <code>docker ps -a</code> 进行查看, 会发现容器已经退出。很重要的要说明的一点: <font color=red>Docker容器后台运行，就必须有一个前台进程。</font>容器运行的命令如果不是那些<font color=red>一直挂起的命令</font>（比如运行top，tail），就是会自动退出的。<br>这个是 docker 的机制问题，比如你的 web 容器，我们以 nginx 为例，正常情况下，我们配置启动服务只需要启动响应的 service 即可。例如 <code>service nginx start</code>，但是，这样做，nginx 为后台进程模式运行，就导致 docker 前台没有运行的应用，这样的容器后台启动后，会立即自杀因为他觉得他没事可做了。所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行</p><h3 id="3-4-2-查看容器日志"><a href="#3-4-2-查看容器日志" class="headerlink" title="3.4.2 查看容器日志"></a>3.4.2 查看容器日志</h3><p><code>docker logs -f -t --tail 容器ID</code></p><ul><li>-t ：加入时间戳</li><li>-f ：跟随最新的日志打印</li><li>–tail 数字 显示最后几条</li></ul><h3 id="3-4-3-查看容器内运行的进程"><a href="#3-4-3-查看容器内运行的进程" class="headerlink" title="3.4.3 查看容器内运行的进程"></a>3.4.3 查看容器内运行的进程</h3><p><code>docker top 容器ID</code></p><h3 id="3-4-4-查看容器内部细节"><a href="#3-4-4-查看容器内部细节" class="headerlink" title="3.4.4 查看容器内部细节"></a>3.4.4 查看容器内部细节</h3><p><code>docker inspect 容器ID</code></p><h3 id="3-4-5-进入正在运行的容器并以命令行交互"><a href="#3-4-5-进入正在运行的容器并以命令行交互" class="headerlink" title="3.4.5 进入正在运行的容器并以命令行交互"></a>3.4.5 进入正在运行的容器并以命令行交互</h3><h4 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h4><p><code>docker exec -it 容器ID /bin/bash</code>，在容器中打开终端，并且可以启动新的进程</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>test ~]# docker ps -a CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES<span class="hljs-number">150f</span>cfbacdfa        centos              <span class="hljs-string">&quot;/bin/bash&quot;</span>              <span class="hljs-number">3</span> minutes ago       Up <span class="hljs-number">3</span> minutes                                    flamboyant_driscoll[<span class="hljs-symbol">root@</span>test ~]# docker exec -it <span class="hljs-number">150f</span>cfbacdfa /bin/bash[<span class="hljs-symbol">root@</span><span class="hljs-number">150f</span>cfbacdfa /]# ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         <span class="hljs-number">1</span>     <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">12</span>:<span class="hljs-number">08</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /bin/bashroot        <span class="hljs-number">14</span>     <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">12</span>:<span class="hljs-number">13</span> pts/<span class="hljs-number">1</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /bin/bashroot        <span class="hljs-number">27</span>    <span class="hljs-number">14</span>  <span class="hljs-number">0</span> <span class="hljs-number">12</span>:<span class="hljs-number">13</span> pts/<span class="hljs-number">1</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ps -ef</code></pre><h4 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h4><p><code>docker attach 容器ID</code>，直接进入容器启动命令终端，不会启动新的进程</p><h3 id="3-4-6-从容器内拷贝文件到主机上"><a href="#3-4-6-从容器内拷贝文件到主机上" class="headerlink" title="3.4.6 从容器内拷贝文件到主机上"></a>3.4.6 从容器内拷贝文件到主机上</h3><p><code>docker cp 容器ID:容器内路径 目的主机路径</code></p><pre><code class="hljs autoit"><span class="hljs-meta">#在容器内创建 hello 文件</span>[root<span class="hljs-symbol">@b7394537e333</span> ~]<span class="hljs-meta"># pwd</span>/root[root<span class="hljs-symbol">@b7394537e333</span> ~]<span class="hljs-meta"># ls</span>hello<span class="hljs-meta">#将容器内 /root/hello 文件拷贝到主机 /tmp 下</span>[root<span class="hljs-symbol">@test</span> ~]<span class="hljs-meta"># docker cp b7394537e333:/root/hello /tmp/</span>[root<span class="hljs-symbol">@test</span> ~]<span class="hljs-meta"># ls /tmp/</span>hello</code></pre><h1 id="四、-Docker-镜像"><a href="#四、-Docker-镜像" class="headerlink" title="四、 Docker 镜像"></a>四、 Docker 镜像</h1><h2 id="4-1-镜像是什么"><a href="#4-1-镜像是什么" class="headerlink" title="4.1 镜像是什么"></a>4.1 镜像是什么</h2><ul><li>一个分层存储的文件</li><li>一个软件的环境</li><li>一个镜像可以创建 N 个容器</li><li>一种标准化的交付</li><li>一个不包含 Linux 内核而又精简的 Linux 操作系统</li></ul><p>镜像不是一个单一的文件，而是有多层结构。我们可以通过 <code>docker history &lt;ID/NAME&gt;</code> 查看镜像中各层内容及大小，每层对应着 Dockerfile 中的一条指令。Docker 镜像默认存储在 `/var/lib/docker/&lt;storage-driver&gt;中。</p><pre><code class="hljs leaf">[root@docker ~]# docker history nginxIMAGE               CREATED             CREATED BY                                      SIZE                COMMENT7e4d58f0e5f3        4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B                  &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  STOPSIGNAL SIGTERM           0B                  &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  EXPOSE 80                    0B                  &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  ENTRYPOINT [&quot;/docker-entr…   0B                  &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span> COPY file:0fd5fca330dcd6a7…   1.04kB              &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span> COPY file:1d0a4127e78a26c1…   1.96kB              &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span> COPY file:e7e183879c35719c…   1.2kB               &lt;missing&gt;           4 weeks ago         /bin/sh -c set -x     &amp;&amp; addgroup --system -…   63.4MB              &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  ENV PKG_RELEASE=1~buster     0B                  &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  ENV NJS_VERSION=0.4.3        0B                  &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  ENV NGINX_VERSION=1.19.2     0B                  &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  LABEL maintainer=NGINX Do…   0B                  &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span>  CMD [&quot;bash&quot;]                 0B                  &lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-params">(<span class="hljs-variable">nop</span>)</span></span> ADD file:e7407f2294ad23634…   69.2MB</code></pre><h3 id="4-1-1-UnionFS"><a href="#4-1-1-UnionFS" class="headerlink" title="4.1.1 UnionFS"></a>4.1.1 UnionFS</h3><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种<strong>分层</strong>、<strong>轻量级</strong>并且<strong>高性能</strong>的文件系统，它支持对文件系统的修改作为<font color=red>一次提交来一层层的叠加</font>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><strong>特性</strong>：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><p>镜像文件分层结构的好处–<strong>共享资源</strong>。比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h3 id="4-1-2-Docker-镜像加载原理"><a href="#4-1-2-Docker-镜像加载原理" class="headerlink" title="4.1.2 Docker 镜像加载原理"></a>4.1.2 Docker 镜像加载原理</h3><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含 <strong>bootloader</strong> 和 <strong>kernel</strong> , <strong>bootloader</strong> 主要是引导加载 kernel, Linux 刚启动时会加载 bootfs 文件系统，<font color=red>在 Docker 镜像的最底层是 bootfs</font>。这一层与我们典型的 Linux/Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p><p>rootfs (root file system) ，在 bootfs 之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu，Centos 等等。 </p><p><img src="/img/Docker/Docker_5.png"></p><h2 id="4-2-镜像特点"><a href="#4-2-镜像特点" class="headerlink" title="4.2 镜像特点"></a>4.2 镜像特点</h2><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为“容器层”，“容器层”下都叫“镜像层”。</p><h2 id="4-3-镜像与容器的联系"><a href="#4-3-镜像与容器的联系" class="headerlink" title="4.3 镜像与容器的联系"></a>4.3 镜像与容器的联系</h2><p><img src="/img/Docker/Docker_4.jpg"></p><p>如图，容器其实是在镜像的最上面加了一层读写层，在运行容器里文件改动时，会先从镜像里要写的文件复制到容器自己的文件系统中（读写层）。如果容器删除了，最上面的读写层也就删除了，改动也就丢失了。所以无论多少个容器共享一个镜像，所做的写操作都是从镜像的文件系统中复制过来操作的，<font color=red>并不会修改镜像的源文件</font>，这种方式<font color=red>提高磁盘利用率</font>。<br>若想持久化这些改动，可以通过 <code>docker commit</code> 将容器保存成一个新镜像。</p><ul><li>一个镜像创建多个容器</li><li>镜像增量式存储</li><li>创建的容器里面修改不会影响到镜像</li></ul><h2 id="4-4-镜像-commit-操作"><a href="#4-4-镜像-commit-操作" class="headerlink" title="4.4 镜像 commit 操作"></a>4.4 镜像 commit 操作</h2><p><code>docker commit [options]</code> ：提交容器副本使之成为一个新的镜像</p><ul><li>-m ：提交的描述信息</li><li>-a ：作者</li></ul><p><code>docker commit -m &quot;xxxx&quot; -a &quot;xxx&quot; 容器ID new_image_name:[tag] </code> ：将容器打包成新的镜像</p><h1 id="五、-Docker-容器"><a href="#五、-Docker-容器" class="headerlink" title="五、 Docker 容器"></a>五、 Docker 容器</h1><h2 id="5-1-容器资源限制"><a href="#5-1-容器资源限制" class="headerlink" title="5.1 容器资源限制"></a>5.1 容器资源限制</h2><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-m,-memory</td><td>容器可以使用的最大内存</td></tr><tr><td>-memory-swap</td><td>允许交换到磁盘的内存量</td></tr><tr><td>-memory-swappiness=&lt;0-100&gt;</td><td>容器使用SWAP分区交换的百分比（0-100，默认为-1）</td></tr><tr><td>-oom-kill-disable</td><td>禁用OOM Killer</td></tr><tr><td>-cpus</td><td>可使用的CPU数量</td></tr><tr><td>-cpuset-cpus</td><td>限制容器使用特定的CPU核心，如（0-3）</td></tr><tr><td>-cpu-shares</td><td>CPU共享（相对权重）</td></tr></tbody></table><h3 id="5-1-1-内存限额"><a href="#5-1-1-内存限额" class="headerlink" title="5.1.1 内存限额"></a>5.1.1 内存限额</h3><p>允许容器最多使用 500MB 内存和 100MB 的 Swap，并禁用 OOM Killer：</p><p><code>docker run -d --name nginx01 --memory=&quot;500m&quot; --memory-swap=&quot;600m --oom-kill-disable nginx</code></p><h3 id="5-1-2-CPU-限制"><a href="#5-1-2-CPU-限制" class="headerlink" title="5.1.2 CPU 限制"></a>5.1.2 CPU 限制</h3><p>允许容器使用两个 CPU：</p><p><code>docker run -d --name nginx02 --cpus=&quot;2&quot; nginx</code></p><p>允许容器最多使用 50% 的 CPU：</p><p><code>docker run -d --name nginx03 --cpus=&quot;.5&quot; nginx</code></p><h3 id="5-1-3-正在运行的容器限制"><a href="#5-1-3-正在运行的容器限制" class="headerlink" title="5.1.3 正在运行的容器限制"></a>5.1.3 正在运行的容器限制</h3><p><code>docker update</code></p><h2 id="5-2-将数据从宿主机挂载到容器中的三种方式"><a href="#5-2-将数据从宿主机挂载到容器中的三种方式" class="headerlink" title="5.2 将数据从宿主机挂载到容器中的三种方式"></a>5.2 将数据从宿主机挂载到容器中的三种方式</h2><p>Docker提供三种方式将数据从宿主机挂载到容器中：</p><ul><li>volumes：Docker 管理宿主机文件系统的一部分（/var/lib/docker/volumes）。保存数据的最佳方式。</li><li>bind mounts：将宿主机上的任意位置的文件或者目录挂载到容器中。</li><li>tmpfs：挂载存储在主机系统的内存中，而不会写入主机的文件系统。如果不希望将数据持久存储在任何位置，可以使用 tmpfs，同时避免写入容器可写层提高性能。</li></ul><p><img src="/img/Docker/Docker_6.jpg"></p><h3 id="5-2-1-Volume"><a href="#5-2-1-Volume" class="headerlink" title="5.2.1 Volume"></a>5.2.1 Volume</h3><p><strong>管理卷</strong></p><ul><li><code>docker volume create volume_name</code> ：创建一个数据卷</li><li><code>docker volume ls</code> ：列出已创建的数据卷</li><li><code>docker volume inspect volume_mame</code> ：显示所创建数据卷的信息</li><li><code>docker volume rm volume_name</code> ：删除一个或者多个数据卷</li></ul><h4 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h4><pre><code class="hljs csharp">[<span class="hljs-meta">root@test volumes</span>]<span class="hljs-meta"># docker volume create nginx_vol</span>nginx_vol[<span class="hljs-meta">root@test volumes</span>]<span class="hljs-meta"># docker volume ls</span>DRIVER              VOLUME NAMElocal               nginx_vol<span class="hljs-meta">#查看所创建的数据卷</span>[<span class="hljs-meta">root@test volumes</span>]<span class="hljs-meta"># docker volume inspect nginx_vol</span>[<span class="hljs-meta"></span><span class="hljs-meta">    &#123;</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;CreatedAt&quot;</span>: <span class="hljs-meta-string">&quot;2020-10-13T20:55:56+08:00&quot;</span>,</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Driver&quot;</span>: <span class="hljs-meta-string">&quot;local&quot;</span>,</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Labels&quot;</span>: &#123;&#125;,</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Mountpoint&quot;</span>: <span class="hljs-meta-string">&quot;/var/lib/docker/volumes/nginx_vol/_data&quot;</span>,</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Name&quot;</span>: <span class="hljs-meta-string">&quot;nginx_vol&quot;</span>,</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Options&quot;</span>: &#123;&#125;,</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Scope&quot;</span>: <span class="hljs-meta-string">&quot;local&quot;</span></span><span class="hljs-meta">    &#125;</span><span class="hljs-meta"></span>]<span class="hljs-meta">#数据卷在宿主机上的目录</span>[<span class="hljs-meta">root@test volumes</span>]<span class="hljs-meta"># pwd</span>/<span class="hljs-keyword">var</span>/lib/docker/volumes[<span class="hljs-meta">root@test volumes</span>]<span class="hljs-meta"># tree</span>.└── nginx_vol    └── _data</code></pre><p><strong>容器中重要数据可以存放到数据卷当中，当容器删除，存放在数据卷中的数据将不会丢失，且能够实现数据共享</strong></p><h4 id="将数据卷挂载到将要创建的容器中"><a href="#将数据卷挂载到将要创建的容器中" class="headerlink" title="将数据卷挂载到将要创建的容器中"></a>将数据卷挂载到将要创建的容器中</h4><p>创建容器 nginx01，并将数据卷 nginx_vol 挂在到容器中：</p><pre><code class="hljs autoit">[root<span class="hljs-symbol">@test</span> volumes]<span class="hljs-meta"># docker run -d --name nginx01 --mount src=nginx_vol,dst=/usr/share/nginx/html -p 2333:80 nginx</span>[root<span class="hljs-symbol">@test</span> _data]<span class="hljs-meta"># docker inspect nginx01</span>        <span class="hljs-string">&quot;Mounts&quot;</span>: [            &#123;                <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;volume&quot;</span>,                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;nginx_vol&quot;</span>,                <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/nginx_vol/_data&quot;</span>,                <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span>,                <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,                <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;z&quot;</span>,                <span class="hljs-string">&quot;RW&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;&quot;</span>            &#125;        ],[root<span class="hljs-symbol">@test</span> volumes]<span class="hljs-meta"># tree</span>.└── nginx_vol    └── _data        ├── <span class="hljs-number">50</span>x.html        └── index.html</code></pre><p>修改主页内容，显示 Hello Nginx!，打开网页</p><p><img src="/img/Docker/Docker_7.jpg"></p><p>创建容器 nginx02，并将数据卷 nginx_vol 挂在到容器中：</p><pre><code class="hljs gradle">[root@test _data]# docker run -d --name nginx02 --mount src=nginx_vol,dst=<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html -p <span class="hljs-number">2334</span>:<span class="hljs-number">80</span> nginx</code></pre><p>打开网页，显示和 nginx01 一样</p><p><img src="/img/Docker/Docker_8.jpg"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>多个运行容器之间共享数据，多个容器可以同时挂载相同的卷。</li><li>当容器停止或被移除时，该卷依然存在。</li><li>当明确删除卷时，卷才会被删除。</li><li>将容器的数据存储在远程主机或其他存储上（间接）</li><li>将数据从一台 Docker 主机迁移到另一台时，先停止容器，然后备份卷的目录（/var/lib/docker/volumes/）</li></ul><h3 id="5-2-2-Bind-Mounts"><a href="#5-2-2-Bind-Mounts" class="headerlink" title="5.2.2 Bind Mounts"></a>5.2.2 Bind Mounts</h3><p>用卷创建一个容器：</p><ul><li><code>docker run -d -it --name=nginx-test --mount type=bind,src=/app/wwwroot,dst=/usr/share/nginx/html nginx</code></li><li><code>docker run -d -it --name=nginx-test -v /app/wwwroot:/usr/share/nginx/html nginx</code></li></ul><p>验证绑定：</p><ul><li><code>docker inspect nginx-test</code></li></ul><p>清理：</p><ul><li><code>docker stop nginx-test</code></li><li><code>docker rm nginx-test</code></li></ul><p><strong>注意：</strong></p><ol><li>如果源文件/目录没有存在如果挂载目标在容器中非空目录，则该目录现有内容将被隐藏。</li><li>不会自动创建，会抛出一个错误。</li></ol><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>从主机共享配置文件到容器。默认情况下，挂载主机 <code>/etc/resolv.conf</code> 到每个容器，提供 DNS 解析。</li><li>在 Docker 主机上的开发环境和容器之间共享源代码。例如，可以将 Maven target 目录挂载到容器中，每次在 Docker 主机上构建 Maven 项目时，容器都可以访问构建的项目包。</li><li>当 Docker 主机的文件或目录结构保证与容器所需的绑定挂载一致时</li></ul><h2 id="5-3-容器网络"><a href="#5-3-容器网络" class="headerlink" title="5.3 容器网络"></a>5.3 容器网络</h2><h1 id="六、-DockerFile"><a href="#六、-DockerFile" class="headerlink" title="六、 DockerFile"></a>六、 DockerFile</h1><h2 id="6-1-DockerFile-是什么"><a href="#6-1-DockerFile-是什么" class="headerlink" title="6.1 DockerFile 是什么"></a>6.1 DockerFile 是什么</h2><p>Dockerfile 是用来构建 Docker 镜像的构建文件，是由一系列命令和参数构成的脚本</p><p>构建步骤：</p><ol><li>编写 Dockerfile 文件</li><li><code>docker build</code></li><li><code>docker run</code></li></ol><p>文件结构：</p><p>CentOS Dockerfile:</p><pre><code class="hljs stylus">FROM scratchADD centos-<span class="hljs-number">7</span>-x86_64-docker<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.xz</span> /LABEL \    org<span class="hljs-selector-class">.label-schema</span>.schema-version=<span class="hljs-string">&quot;1.0&quot;</span> \    org<span class="hljs-selector-class">.label-schema</span>.name=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \    org<span class="hljs-selector-class">.label-schema</span>.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \    org<span class="hljs-selector-class">.label-schema</span>.license=<span class="hljs-string">&quot;GPLv2&quot;</span> \    org<span class="hljs-selector-class">.label-schema</span>.build-date=<span class="hljs-string">&quot;20200809&quot;</span> \    org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.title=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \    org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \    org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.licenses=<span class="hljs-string">&quot;GPL-2.0-only&quot;</span> \    org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.created=<span class="hljs-string">&quot;2020-08-09 00:00:00+01:00&quot;</span>CMD [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</code></pre><p>基础内容：</p><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ol><h2 id="6-2-Dockerfile-指令"><a href="#6-2-Dockerfile-指令" class="headerlink" title="6.2 Dockerfile 指令"></a>6.2 Dockerfile 指令</h2><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>FROM</td><td>构建新镜像是基于哪个镜像</td></tr><tr><td>MAINTAINER</br>LABEL</td><td>镜像维护者姓名或邮箱地址</td></tr><tr><td>RUN</td><td>构建镜像时运行的Shell命令</td></tr><tr><td>COPY</td><td>拷贝文件或目录到镜像中</td></tr><tr><td>ENV</td><td>设置环境变量</td></tr><tr><td>USER</td><td>为RUN、CMD和ENTRYPOINT执行命令指定运行用户</td></tr><tr><td>EXPOSE</td><td>声明容器运行的服务端口</td></tr><tr><td>HEALTHCHECK</td><td>容器中服务健康检查</td></tr><tr><td>WORKDIR</td><td>为RUN、CMD、ENTRYPOINT、COPY和ADD设置工作目录</td></tr><tr><td>ENTRYPOINT</td><td>运行容器时执行，如果有多个ENTRYPOINT指令，最后一个生效</td></tr><tr><td>CMD</td><td>运行容器时执行，如果有多个CMD指令，最后一个生效</td></tr></tbody></table><h2 id="6-3-Dockerfile-与-Docker容器、镜像的关系"><a href="#6-3-Dockerfile-与-Docker容器、镜像的关系" class="headerlink" title="6.3 Dockerfile 与 Docker容器、镜像的关系"></a>6.3 Dockerfile 与 Docker容器、镜像的关系</h2><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p><ul><li>Dockerfile是软件的原材料</li><li>Docker镜像是软件的交付品</li><li>Docker容器则可以认为是软件的运行态。</li></ul><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><p><img src="/img/Docker/Docker_9.png"></p><ol><li>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li><li>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</li><li>Docker容器，容器是直接提供服务的。</li></ol><h2 id="6-4-Build-镜像"><a href="#6-4-Build-镜像" class="headerlink" title="6.4 Build 镜像"></a>6.4 Build 镜像</h2><p>Usage:<code>docker build [option] PATH |URL| -[flags]</code></p><h4 id="option"><a href="#option" class="headerlink" title="option:"></a>option:</h4><ul><li>-t,–tag list ：镜像名称</li><li>-f，–file string :指定 Dockerfile 文件位置</li></ul><h2 id="6-5-构建-Nginx-基础镜像"><a href="#6-5-构建-Nginx-基础镜像" class="headerlink" title="6.5 构建 Nginx 基础镜像"></a>6.5 构建 Nginx 基础镜像</h2><h3 id="6-5-1-编写-Dockerfile"><a href="#6-5-1-编写-Dockerfile" class="headerlink" title="6.5.1 编写 Dockerfile"></a>6.5.1 编写 Dockerfile</h3><pre><code class="hljs awk">FROM centos:<span class="hljs-number">7</span>MAINTAINER ecarry<span class="hljs-comment">#安装 nginx 依赖</span>RUN yum install -y gcc gcc-c++ make \    openssl-devel pcre-devel gd-devel \    iproute net-tools wget &amp;&amp; \    yum clean all &amp;&amp; \    rm -rf <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/yum/</span>*<span class="hljs-comment">#源码编译 nginx，为nginx设置安装目录和启用的模块</span>RUN wget http:<span class="hljs-regexp">//</span>nginx.org<span class="hljs-regexp">/download/</span>nginx-<span class="hljs-number">1.19</span>.<span class="hljs-number">3</span>.tar.gz &amp;&amp; \    tar zxf nginx-<span class="hljs-number">1.19</span>.<span class="hljs-number">3</span>.tar.gz &amp;&amp; \    cd nginx-<span class="hljs-number">1.19</span>.<span class="hljs-number">3</span> &amp;&amp; \    .<span class="hljs-regexp">/configure --prefix=/u</span>sr<span class="hljs-regexp">/local/</span>nginx \    --with-http_ssl_module \    --with-http_stub_status_module &amp;&amp; \    make -j <span class="hljs-number">4</span> &amp;&amp; make install &amp;&amp; \    cd / &amp;&amp; rm -rf nginx-* &amp;&amp; \    ln -sf <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zoneinfo/</span>Asia<span class="hljs-regexp">/Shanghai /</span>etc/localtimeENV PATH <span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbinWORKDIR <span class="hljs-regexp">/usr/</span>local/nginxEXPOSE <span class="hljs-number">80</span>CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]</code></pre><p><strong>参数说明：</strong></p><ul><li>–prefix ：用于指定nginx编译后的安装目录</li><li>–add-module ：为添加的第三方模块，此次添加了fdfs的nginx模块</li><li>–with…_module ：表示启用的nginx模块</li></ul><h3 id="6-5-2-构建镜像"><a href="#6-5-2-构建镜像" class="headerlink" title="6.5.2 构建镜像"></a>6.5.2 构建镜像</h3><p><code>docker build -t nginx:v1 -f dockerfile .</code></p><ul><li>-t ：指定镜像名称</li><li>-f ：指定编写的 dockerfile 文件</li><li>. ：代表 dockerfile 文件里上下文</li></ul><pre><code class="hljs crmsh">[root@docker ~]<span class="hljs-comment"># docker image ls</span>REPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZEnginx               v1                  a4906a1a6692        <span class="hljs-number">39</span> minutes ago      <span class="hljs-number">335M</span>B</code></pre><h2 id="6-6-php"><a href="#6-6-php" class="headerlink" title="6.6 php"></a>6.6 php</h2><h3 id="6-6-1-编写-Dockerfile"><a href="#6-6-1-编写-Dockerfile" class="headerlink" title="6.6.1 编写 Dockerfile"></a>6.6.1 编写 Dockerfile</h3><pre><code class="hljs awk">FROM centos:<span class="hljs-number">7</span>MAINTAINER ecarryRUN yum install epel-release -y &amp;&amp; \    yum install -y gcc gcc-c++ make gd-devel libxml2-devel \    libcurl-devel libjpeg-devel libpng-devel openssl-devel \    libmcrypt-devel libxslt-devel libtidy-devel autoconf \    iproute net-tools telnet wget curl &amp;&amp; \    yum clean all &amp;&amp; \    rm -rf <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/yum/</span>*RUN wget https:<span class="hljs-regexp">//</span>www.php.net<span class="hljs-regexp">/distributions/</span>php-<span class="hljs-number">5.6</span>.<span class="hljs-number">40</span>.tar.gz &amp;&amp; \    tar zxf php-<span class="hljs-number">5.6</span>.<span class="hljs-number">40</span>.tar.gz &amp;&amp; \    cd php-<span class="hljs-number">5.6</span>.<span class="hljs-number">40</span> &amp;&amp; \    .<span class="hljs-regexp">/configure --prefix=/u</span>sr<span class="hljs-regexp">/local/</span>php \    --with-config-file-path=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/php/</span>etc \    --enable-fpm --enable-opcache \    --with-mysql --with-mysqli --with-pdo-mysql \    --with-openssl --with-zlib --with-curl --with-gd \    --with-jpeg-dir --with-png-dir --with-freetype-dir \    --enable-mbstring --with-mcrypt --enable-hash &amp;&amp; \    make -j <span class="hljs-number">4</span> &amp;&amp; make install &amp;&amp; \    cp php.ini-production <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/php/</span>etc/php.ini &amp;&amp; \    cp sapi<span class="hljs-regexp">/fpm/</span>php-fpm.conf <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/php/</span>etc/php-fpm.conf &amp;&amp; \    sed -i <span class="hljs-string">&quot;90a \daemonize = no&quot;</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/php/</span>etc/php-fpm.conf &amp;&amp; \    mkdir <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/php/</span>log &amp;&amp; \    cd / &amp;&amp; rm -rf php* &amp;&amp; \    ln -sf <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zonginfo/</span>Asia<span class="hljs-regexp">/Shanghai /</span>etc/localtimeENV PATH <span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/php/</span>sbin:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/php/</span>binWORKDIR <span class="hljs-regexp">/usr/</span>local/phpEXPOSE <span class="hljs-number">9000</span>CMD [<span class="hljs-string">&quot;php-fpm&quot;</span>]</code></pre><h3 id="6-5-2-构建镜像-1"><a href="#6-5-2-构建镜像-1" class="headerlink" title="6.5.2 构建镜像"></a>6.5.2 构建镜像</h3><p><code>docker build -t php:v1 -f dockerfile_php .</code></p><h2 id="6-6-关系图"><a href="#6-6-关系图" class="headerlink" title="6.6 关系图"></a>6.6 关系图</h2><p><img src="/img/Docker/Docker_10.png"></p><h2 id="6-7-搭建-LNMP-网站平台"><a href="#6-7-搭建-LNMP-网站平台" class="headerlink" title="6.7 搭建 LNMP 网站平台"></a>6.7 搭建 LNMP 网站平台</h2><p><img src="/img/Docker/Docker_11.jpg"></p><h3 id="6-7-1-创建自定义网络"><a href="#6-7-1-创建自定义网络" class="headerlink" title="6.7.1 创建自定义网络"></a>6.7.1 创建自定义网络</h3><p><code>docker network create lnmp</code></p><h3 id="6-7-2-创建-MySQL-容器"><a href="#6-7-2-创建-MySQL-容器" class="headerlink" title="6.7.2 创建 MySQL 容器"></a>6.7.2 创建 MySQL 容器</h3><pre><code class="hljs routeros">[root@docker ~]# docker <span class="hljs-builtin-name">run</span> -d \   --name lnmp_mysql \   --net lnmp \   --mount <span class="hljs-attribute">src</span>=mysql_vol,dst=/var/lib/mysql \   -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=root123 \   -e <span class="hljs-attribute">MYSQL_DATABASE</span>=wordpress mysql:5.7 <span class="hljs-attribute">--character-set-server</span>=utf8</code></pre><h3 id="6-7-3-创建-PHP-容器"><a href="#6-7-3-创建-PHP-容器" class="headerlink" title="6.7.3 创建 PHP 容器"></a>6.7.3 创建 PHP 容器</h3><pre><code class="hljs nginx"><span class="hljs-attribute">user</span>  nobody;<span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">2</span>;<span class="hljs-attribute">worker_rlimit_nofile</span> <span class="hljs-number">65535</span>;<span class="hljs-attribute">error_log</span> logs/error.log <span class="hljs-literal">notice</span>;<span class="hljs-attribute">pid</span>        /var/run/nginx.pid;<span class="hljs-section">events</span> &#123;    <span class="hljs-attribute">use</span> <span class="hljs-literal">epoll</span>;    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">4096</span>;&#125;<span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">include</span>       mime.types;    <span class="hljs-attribute">default_type</span>  application/octet-stream;    <span class="hljs-attribute">access_log</span>  <span class="hljs-literal">off</span>;    <span class="hljs-attribute">log_format</span> main <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] &quot;<span class="hljs-variable">$request</span>&quot; &#x27;</span>                    <span class="hljs-string">&#x27;<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span>                    <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot; &quot;<span class="hljs-variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;            <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;    <span class="hljs-comment">#tcp_nopush     on;</span>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;    <span class="hljs-attribute">clinet_max_body_size</span> <span class="hljs-number">64m</span>;    <span class="hljs-comment">#gzip  on;</span>    <span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;        <span class="hljs-attribute">server_name</span>  www.ecarry.com;        <span class="hljs-attribute">index</span> index.php index.html;        <span class="hljs-comment">#charset koi8-r;</span>        <span class="hljs-attribute">access_log</span>  logs/www.ecarry.com_access.log;        <span class="hljs-attribute">error_log</span> log/www.ecarry.com_error.log;        <span class="hljs-attribute">location</span> / &#123;            <span class="hljs-attribute">root</span>   /wwwroot;        &#125;        <span class="hljs-attribute">location</span> <span class="hljs-regexp">~* \.php$</span> &#123;            <span class="hljs-attribute">root</span>   /wwwroot;            <span class="hljs-attribute">fastcgi_pass</span> lnmp_php:<span class="hljs-number">9000</span>;            <span class="hljs-attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="hljs-variable">$document_root</span><span class="hljs-variable">$fastcgi_script_name</span>;            <span class="hljs-attribute">include</span> fastcgi_params;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zabbix 5.0 LTS 添加主机及监控</title>
    <link href="/2020/10/10/zabbix_host/"/>
    <url>/2020/10/10/zabbix_host/</url>
    
    <content type="html"><![CDATA[<p>服务端及客户端安装配置文档：<a href="https://ecarry.cc/2020/08/27/zabbix_install/">在 CentOS 7 下 搭建 Zabbix 5.0 LTS 日志</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>Zabbix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zabbix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell 从入门到精通</title>
    <link href="/2020/09/28/linux_shell/"/>
    <url>/2020/09/28/linux_shell/</url>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><hr><h5 id="关于本文档"><a href="#关于本文档" class="headerlink" title="关于本文档"></a>关于本文档</h5><table><thead><tr><th>文档名称</th><th>Shell 从入门到精通</th></tr></thead><tbody><tr><td>作者信息</td><td>李振良（阿良），微信：init 1024</td></tr><tr><td>官方网站</td><td><a href="http://www.ctnrs.com/">http://www.ctnrs.com</a></td></tr><tr><td>技术博客</td><td><a href="http://blog.51cto.com/lizhenliang">http://blog.51cto.com/lizhenliang</a></td></tr><tr><td>最后更新时间</td><td>2019 - 2 - 1</td></tr></tbody></table><h5 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h5><p>熟悉 Linux 系统常用命令与工具，掌握 Shell 脚本语言语法结构，能独立编写 Shell 脚本，完成自动化运维常规任务，提高工作效率，为以后学习其他语言打下坚实的基础。</p><p>目标人群</p><p>运维工程师、开发工程师、Linux 系统爱好者或已经具备其他编程语言的人群。</p><h1 id="一、-Shell-基础知识"><a href="#一、-Shell-基础知识" class="headerlink" title="一、 Shell 基础知识"></a>一、 Shell 基础知识</h1><h2 id="1-1-Shell-简介"><a href="#1-1-Shell-简介" class="headerlink" title="1.1 Shell 简介"></a>1.1 Shell 简介</h2><p>Shell 是一个 C 语言编写的脚本语言，它是用户与 Linux 的桥梁，用户输入命令交给 Shell 处理，Shell 将相应的操作传递给内核（Kernel），内核把处理的结果输出给用户。<br>下面是流程示意图：</p><p><img src="/img/linux_shell/linux_shell_1.jpg"></p><p>Shell 既然是工作在 Linux 内核之上，那我们也有必要了解下 Linux 相关知识。<br>Linux 是一套免费试用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>1983 年 9 月 27 日，Richard Stallman（理查德 - 马修 - 斯托曼）发起 GNU 计划，它的目标是创建一套完全自由的操作系统。为保证 GNU 软件可以自由的使用、复制、修改和发布，所有的 GNU 软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，GNU 通用公共许可证（GNU General Plubic License，GPL），说白了就是不能做商业用途。</p><p>GNU 是 “GNU is Not Unix” 的递归缩写。UNIX 是一种广泛使用的商业操作系统的名称。1985 年，Richard Stallman 又创立了自由软件基金会（Free Software Foundation，FSF）来为 GNU 计划提供技术、法律以及财政支持。</p><p>1990 年，GNU 计划开发主要项目有 Emacs（文本编辑器）、GCC（GNU Compiler Collection，GNU 编译器集合）、Bash 等，GCC 是一套 GNU 开发的编程语言编译器。还有开发一些 UNIX 系统的程序库和工具。</p><p>1991 年，Linuxs Torvalds（林纳斯 - 托瓦兹）开发出了与 UNIX 兼容的 Linux 操作系统内核并在 GPL 条款下发布。</p><p>1992 年，Linux 与其他 GUN 软件结合，完全自由的 GUN/Linux 操作系统正式诞生，简称 Linux。</p><p>1995 年 1 月，Bob Young 创办 ACC 公司，以 GNU/Linux 为核心，开发出了 RedHat Linux 商业版。</p><p>Linux 基本思想有两点：第一，<strong>一切都是文件</strong>；第二，<strong>每个软件都有确定的用途</strong>。与 Unix 思想十分相近。</p><h2 id="1-2-Shell-基本分两大类"><a href="#1-2-Shell-基本分两大类" class="headerlink" title="1.2 Shell 基本分两大类"></a>1.2 Shell 基本分两大类</h2><h3 id="1-2-1-图形界面-Shell（GUI-Shell）"><a href="#1-2-1-图形界面-Shell（GUI-Shell）" class="headerlink" title="1.2.1 图形界面 Shell（GUI Shell）"></a>1.2.1 图形界面 Shell（GUI Shell）</h3><p>GUI 为 Unix 或者类 Unix 操作系统构造一个功能完善、操作简单以及界面友好的桌面环境。主流桌面环境有 KDE，Gnome 等。</p><h3 id="1-2-2-命令行界面-Shell（CLI-Shell）"><a href="#1-2-2-命令行界面-Shell（CLI-Shell）" class="headerlink" title="1.2.2 命令行界面 Shell（CLI Shell）"></a>1.2.2 命令行界面 Shell（CLI Shell）</h3><p>CLI 是在用户提示符下键入可执行指令的界面，用户通过键盘输入指令，完成一系列操作。</p><p>在 Linux 系统上主流的 CLI 实现是 Bash，是许多 Linux 发行版默认的 Shell。还有许多 Unix 上 Shell，例如 <strong>tcsh、csh、ash、bsh、ksh</strong> 等。</p><h2 id="1-3-第一个-Shell-脚本"><a href="#1-3-第一个-Shell-脚本" class="headerlink" title="1.3 第一个 Shell 脚本"></a>1.3 第一个 Shell 脚本</h2><p>本教程主要讲解在大多 Linux 发行版下默认 Bash Shell。Linux 系统是 RedHat 下的 CentOS 操作系统，完全免费。与其商业版 RHEL（Red Hat Enterprise Linux）出自同样的源代码，不同的是 CentOS 并不包含封闭源代码软件和售后支持。</p><p>用 vi 打开 test.sh，编写：</p><pre><code class="hljs bash"><span class="hljs-comment"># vi test.sh</span><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello world!&quot;</span></code></pre><p>第一行指定解释器，第二行打印 Hello world！<br>写好后，开始执行，执行 Shell 脚本有三种方法：</p><p><strong>方法 1</strong> ：直接用 bash 解释器执行</p><pre><code class="hljs bash"><span class="hljs-comment"># bash test.sh</span>Hello world!</code></pre><p>当前终端会新生成一个子 bash 去执行脚本。</p><p><strong>方法 2</strong> ：添加可执行权限</p><pre><code class="hljs bash"><span class="hljs-comment"># ll test.sh</span>- rw-r--r--. 1 root root 32 Aug 18 01:07 test.sh<span class="hljs-comment"># chmod +x test.sh</span><span class="hljs-comment"># ./test.sh</span>- bash: ./test.sh: Permission denied<span class="hljs-comment"># chmod +x test.sh</span><span class="hljs-comment"># ./test.sh # ./ 在当前目录</span>Hello world!</code></pre><p>这种方式默认根据脚本第一行指定的解释器处理，如果没写以当前默认 Shell 解释器执行。</p><p><strong>方法 3</strong>：source 命令执行，以当前默认 Shell 解释器执行</p><pre><code class="hljs bash"><span class="hljs-comment"># source test.sh</span>Hello world!</code></pre><h2 id="1-4-Shell-变量"><a href="#1-4-Shell-变量" class="headerlink" title="1.4 Shell 变量"></a>1.4 Shell 变量</h2><h3 id="1-4-1-系统变量"><a href="#1-4-1-系统变量" class="headerlink" title="1.4.1 系统变量"></a>1.4.1 系统变量</h3><p>在命令行提示符直接执行 env、set 查看系统或环境变量。env 显示用户环境变量，set 显示 Shell 预先定义好的变量以及用户变量。可以通过 export 导出成用户变量。</p><p>一些写 Shell 脚本时常用的系统变量：</p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$SHELL</td><td>默认 Shell</td></tr><tr><td>$HOME</td><td>当前用户家目录</td></tr><tr><td>$IFS</td><td>内部字段分隔符</td></tr><tr><td>$LANG</td><td>默认语言</td></tr><tr><td>$PATH</td><td>默认可执行程序路径</td></tr><tr><td>$PWD</td><td>当前目录</td></tr><tr><td>$UID</td><td>当前用户 ID</td></tr><tr><td>$USER</td><td>当前用户</td></tr><tr><td>$HISTSIZE</td><td>历史命令大小，可通过 HISTTIMEFORMAT 变量设置命令执行时间</td></tr><tr><td>$RANDOM</td><td>随机生成一个 0 至 32767 的整数</td></tr><tr><td>$HOSTNAME</td><td>主机名</td></tr></tbody></table><h3 id="1-4-2-普通变量与临时环境变量"><a href="#1-4-2-普通变量与临时环境变量" class="headerlink" title="1.4.2 普通变量与临时环境变量"></a>1.4.2 普通变量与临时环境变量</h3><p><strong>普通变量定义</strong>：VAR=value</p><p><strong>临时环境变量定义</strong>：export VAR=value</p><p><strong>变量引用</strong>：$VAR</p><p>下面看下他们之间区别：</p><p>Shell 进程的环境变量作用域是 Shell 进程，当 export 导入到系统变量时，则作用域是 Shell 进程及其 Shell 子进程。</p><p><img src="/img/linux_shell/linux_shell_2.jpg"></p><p><img src="/img/linux_shell/linux_shell_3.jpg"></p><p>ps axjf 输出的第一列是 PPID（父进程 ID），第二列是 PID（子进程 ID）<br>当 SSH 连接 Shell 时，当前终端 PPID（-bash）是 sshd 守护程序的 PID（root@pts/0），因此在当前终端下的所有进程的 PPID 都是 -bash 的 PID，比如执行命令、运行脚本。<br>所以当在 -bash 下设置的变量，只在 -bash 进程下有效，而 -bash 下的子进程 bash 是无效的，当 export 后才有效。</p><p>进一步说明：再重新连接 SSH，去除上面定义的变量测试下</p><p><img src="/img/linux_shell/linux_shell_4.jpg"></p><p>所以在当前 shell 定义的变量一定要 export，否则在写脚本时，会引用不到。</p><p>还需要注意的是退出终端后，所有用户定义的变量都会清除。</p><p>在 <code>/etc/profile</code> 下定义的变量就是这个原理，后面有章节会讲解 Linux 常用变量文件。</p><h3 id="1-4-3-位置变量"><a href="#1-4-3-位置变量" class="headerlink" title="1.4.3 位置变量"></a>1.4.3 位置变量</h3><p>位置变量指的是函数或脚本后跟的第 n 个参数。</p><p>$1-$n，需要注意的是从第 10 个开始要用花括号调用，例如 ${10}</p><p>shift 可对位置变量控制，例如：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1: <span class="hljs-variable">$1</span>&quot;</span><span class="hljs-built_in">shift</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2: <span class="hljs-variable">$2</span>&quot;</span><span class="hljs-built_in">shift</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;3: <span class="hljs-variable">$3</span>&quot;</span><span class="hljs-comment"># bash test.sh a b c</span>1: a2: c3:</code></pre><p>每执行一次 shift 命令，位置变量个数就会减一，而变量值则提前一位。shift n，可设置向前移动 n 位。</p><h3 id="1-4-4-特殊变量"><a href="#1-4-4-特殊变量" class="headerlink" title="1.4.4 特殊变量"></a>1.4.4 特殊变量</h3><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$0</td><td>脚本自身名字</td></tr><tr><td>$?</td><td>返回上一条命令是否执行成功， 0 为执行成功，非 0 则为执行失败</td></tr><tr><td>$#</td><td>位置参数总数</td></tr><tr><td>$*</td><td>所有的位置参数被看做一个字符串</td></tr><tr><td>$@</td><td>每个位置参数被看做独立的字符串</td></tr><tr><td>$$</td><td>当前进程 PID</td></tr><tr><td>$!</td><td>上一条运行后台进程的 PID</td></tr></tbody></table><h2 id="1-5-变量引用"><a href="#1-5-变量引用" class="headerlink" title="1.5 变量引用"></a>1.5 变量引用</h2><table><thead><tr><th>赋值运算符</th><th>示例</th></tr></thead><tbody><tr><td>=</td><td>变量赋值</td></tr><tr><td>+=</td><td>两个变量相加</td></tr></tbody></table><h3 id="1-5-1-自定义变量与引用"><a href="#1-5-1-自定义变量与引用" class="headerlink" title="1.5.1 自定义变量与引用"></a>1.5.1 自定义变量与引用</h3><pre><code class="hljs bash"><span class="hljs-comment"># VAR=123</span><span class="hljs-comment"># echo $VAR</span>123<span class="hljs-comment"># VAR+=456</span><span class="hljs-comment"># echo $VAR</span>123456</code></pre><p>Shell 中所有变量引用使用 $ 符，后跟变量名。<br>有时个别特殊字符会影响正常引用，那么需要使用 ${VAR}，例如：</p><pre><code class="hljs bash"><span class="hljs-comment"># VAR=123</span><span class="hljs-comment"># echo $VAR</span>123<span class="hljs-comment"># echo $VAR_  # Shell 允许 VAR_为变量名，所以此引用认为这是一个有效的变量名，故此返回空</span><span class="hljs-comment"># echo $&#123;VAR&#125;</span>123</code></pre><p>还有时候变量名与其他字符串紧碍着，也会误认为是整个变量：</p><pre><code class="hljs bash"><span class="hljs-comment"># echo $VAR456</span><span class="hljs-comment"># echo $&#123;VAR&#125;456</span>123456</code></pre><h3 id="1-5-2-将命令结果作为变量值"><a href="#1-5-2-将命令结果作为变量值" class="headerlink" title="1.5.2 将命令结果作为变量值"></a>1.5.2 将命令结果作为变量值</h3><pre><code class="hljs bash"><span class="hljs-comment"># VAR=`echo 123`</span><span class="hljs-comment"># echo $VAR</span>123<span class="hljs-comment"># VAR=$(echo 123)</span><span class="hljs-comment"># echo $VAR</span>123</code></pre><p>这里的反撇号等效于 $()，都是用于执行 Shell 命令。</p><h2 id="1-6-双引号和单引号"><a href="#1-6-双引号和单引号" class="headerlink" title="1.6 双引号和单引号"></a>1.6 双引号和单引号</h2><p>在变量赋值时，如果值有空格，Shell 会把空格后面的字符串解释为命令：</p><pre><code class="hljs bash"><span class="hljs-comment"># VAR=1 2 3</span>- bash: 2: <span class="hljs-built_in">command</span> not found<span class="hljs-comment"># VAR=&quot;1 2 3&quot;</span><span class="hljs-comment"># echo $VAR</span>1 2 3<span class="hljs-comment"># VAR=&#x27;1 2 3&#x27;</span><span class="hljs-comment"># echo $VAR</span>1 2 3</code></pre><p>看不出什么区别，再举个说明：</p><pre><code class="hljs bash"><span class="hljs-comment"># N=3</span><span class="hljs-comment"># VAR=&quot;1 2 $N&quot;</span><span class="hljs-comment"># echo $VAR</span>1 2 3<span class="hljs-comment"># VAR=&#x27;1 2 $N&#x27;</span><span class="hljs-comment"># echo $VAR</span>1 2 <span class="hljs-variable">$N</span></code></pre><p>单引号是告诉  Shell 忽略特殊字符，而双引号则解释特殊符号原有的意义，比如 $、！。</p><h2 id="1-7-注释"><a href="#1-7-注释" class="headerlink" title="1.7 注释"></a>1.7 注释</h2><p>Shell 注释也很简单，只要在每行前面加个 # 号，即表示 Shell 忽略解释。</p><h1 id="二、-Shell-字符串处理之"><a href="#二、-Shell-字符串处理之" class="headerlink" title="二、 Shell 字符串处理之 ${}"></a>二、 Shell 字符串处理之 ${}</h1><p>上一章节讲解了为什么用 ${} 引用变量，${} 还有一个重要的功能，就是文本处理，单行文本基本上可以满足你所有需求。</p><h2 id="2-1-获取字符串长度"><a href="#2-1-获取字符串长度" class="headerlink" title="2.1 获取字符串长度"></a>2.1 获取字符串长度</h2><pre><code class="hljs bash"><span class="hljs-comment"># VAR=&#x27;hello world!&#x27;</span><span class="hljs-comment"># echo $VAR</span>hello world!<span class="hljs-comment"># echo $&#123;#VAR&#125;</span>12</code></pre><h2 id="2-2-字符串切片"><a href="#2-2-字符串切片" class="headerlink" title="2.2 字符串切片"></a>2.2 字符串切片</h2><p><strong>格式：</strong></p><ul><li>${parameter:offset}</li><li>${parameter:offset:length}</li></ul><p>截取从 offset 个字符开始，向后 length 个字符。</p><pre><code class="hljs bash">截取 hello 字符串：<span class="hljs-comment"># VAR=&#x27;hello world!&#x27;</span><span class="hljs-comment"># echo $&#123;VAR:0:5&#125;</span>hello截取 wo 字符：<span class="hljs-comment"># echo $&#123;VAR:6:2&#125;</span>wo截取 world! 字符串：<span class="hljs-comment"># echo $&#123;VAR:5&#125;</span>world!截取最后一个字符：<span class="hljs-comment"># echo $&#123;VAR:(-1)&#125;</span>!截取最后二个字符：<span class="hljs-comment"># echo $&#123;VAR:(-2)&#125;</span>d!截取从倒数第 3 个字符后的 2 个字符：<span class="hljs-comment"># echo $&#123;VAR:(-3):2&#125;</span>ld</code></pre><h2 id="2-3-替换字符串"><a href="#2-3-替换字符串" class="headerlink" title="2.3 替换字符串"></a>2.3 替换字符串</h2><p><strong>格式：</strong></p><ul><li>${parameter/pattern/string}</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># VAR=&#x27;hello world world!&#x27;</span>将第一个 world 字符串替换为 WORLD：<span class="hljs-comment"># echo $&#123;VAR/world/WORLD&#125;</span>hello WORLD world!将全部 world 字符串替换为 WORLD：<span class="hljs-comment"># echo $&#123;VAR//world/WORLD&#125;</span>hello WORLD WORLD!替换正则匹配为空：<span class="hljs-comment"># VAR=123abc</span><span class="hljs-comment"># echo $&#123;VAR//[^0-9]/&#125;</span>123<span class="hljs-comment"># echo $&#123;VAR//[0-9]/&#125;</span>abc</code></pre><p>patterm 前面开头一个正斜杠为只匹配第一个字符串，两个正斜杠为匹配所有字符。</p><h2 id="2-4-字符串截取"><a href="#2-4-字符串截取" class="headerlink" title="2.4 字符串截取"></a>2.4 字符串截取</h2><p><strong>格式：</strong></p><ul><li>${parameter#word}         # 删除匹配前缀</li><li>${parameter##word}</li><li>${parameter%word}         # 删除匹配后缀</li><li>${parameter%%word}</li><li>#   去掉左边，最短匹配模式，## 最长匹配模式。</li><li>%    去掉右边，最短匹配模式，%% 最长匹配模式。</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># URL=&quot;http://www.baidu.com/baike/user.html&quot;</span>以 // 为分隔符截取右边字符串：<span class="hljs-comment"># echo $&#123;URL#*//&#125;</span>http://www.baidu.com/baike/user.html以 / 为分隔符截取右边字符串：<span class="hljs-comment"># echo $&#123;URL##*/&#125;</span>user.html以 // 为分隔符截取左边字符串：<span class="hljs-comment"># echo $&#123;URL%%//*&#125;</span>http:以 / 为分隔符截取左边字符串：<span class="hljs-comment"># echo $&#123;URL%/*&#125;</span>http://www.baidu.com/baike以. 为分隔符截取左边：<span class="hljs-comment"># echo $&#123;URL%.*&#125;</span>http://www.baidu.com/baike/user以. 为分隔符截取右边：<span class="hljs-comment"># echo $&#123;URL##*.&#125;</span>html</code></pre><h2 id="2-5-变量状态赋值"><a href="#2-5-变量状态赋值" class="headerlink" title="2.5 变量状态赋值"></a>2.5 变量状态赋值</h2><ul><li>${VAR:-string}   如果 VAR 变量为空则返回 string</li><li>${VAR:+string}   如果 VAR 变量不为空则返回 string</li><li>${VAR:=string}   如果 VAR 变量为空则重新赋值 VAR 变量值为 string</li><li>${VAR:?string}   如果 VAR 变量为空则将 string 输出到 stderr</li></ul><pre><code class="hljs bash">如果变量为空就返回 hello world!：<span class="hljs-comment"># VAR=</span><span class="hljs-comment"># echo $&#123;VAR:-&#x27;hello world!&#x27;&#125;</span>hello world!如果变量不为空就返回 hello world!：<span class="hljs-comment"># VAR=&quot;hello&quot;</span><span class="hljs-comment"># echo $&#123;VAR:+&#x27;hello world!&#x27;&#125;</span>hello world!如果变量为空就重新赋值：<span class="hljs-comment"># VAR=</span><span class="hljs-comment"># echo $&#123;VAR:=hello&#125;</span>hello<span class="hljs-comment"># echo $VAR</span>hello如果变量为空就将信息输出 stderr：<span class="hljs-comment"># VAR=</span><span class="hljs-comment"># echo $&#123;VAR:?value is null&#125;</span>- bash: VAR: value is null</code></pre><p>${} 主要用途大概就这么多了，另外还可以获取数组元素，在后面章节会讲到。</p><h2 id="2-6-字符串颜色"><a href="#2-6-字符串颜色" class="headerlink" title="2.6 字符串颜色"></a>2.6 字符串颜色</h2><p>再介绍下字符串输出颜色，有时候关键地方需要醒目，颜色是最好的方式：</p><table><thead><tr><th>字体颜色</th><th>字体背景颜色</th><th>显示方式</th></tr></thead><tbody><tr><td>30 ：黑</td><td>40：黑</td><td>0 ：终端默认设置</td></tr><tr><td>31 ：红</td><td>41：深红</td><td>1 ：高亮显示</td></tr><tr><td>32 ：绿</td><td>42：绿</td><td>4 ：下划线</td></tr><tr><td>33 ：黄</td><td>43：黄色</td><td>5 ：闪烁</td></tr><tr><td>34 ：蓝色</td><td>44：蓝色</td><td>7 ：反白显示</td></tr><tr><td>35 ：紫色</td><td>45：紫色</td><td>8 ：隐藏</td></tr><tr><td>36 ：深绿</td><td>46：深绿</td><td></td></tr><tr><td>37 ：白色</td><td>47：白色</td><td></td></tr></tbody></table><table><thead><tr><th>格式</th></tr></thead><tbody><tr><td>\033[1;31;40m # 1 是显示方式，可选。31 是字体颜色。40m 是字体背景颜色。</td></tr><tr><td>\033[0m       # 恢复终端默认颜色，即取消颜色设置。</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># 字体颜色</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;31..37&#125;; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> - e <span class="hljs-string">&quot;\033[<span class="hljs-variable">$i</span>;40mHello world!\033[0m&quot;</span><span class="hljs-keyword">done</span><span class="hljs-comment"># 背景颜色</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;41..47&#125;; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> - e <span class="hljs-string">&quot;\033[47;<span class="hljs-variable">$&#123;i&#125;</span>mHello world!\033[0m&quot;</span><span class="hljs-keyword">done</span><span class="hljs-comment"># 显示方式</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..8&#125;; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> - e <span class="hljs-string">&quot;\033[<span class="hljs-variable">$i</span>;31;40mHello world!\033[0m&quot;</span><span class="hljs-keyword">done</span></code></pre><p><img src="/img/linux_shell/linux_shell_5.jpg"></p><h1 id="三、-Shell-表达式与运算符"><a href="#三、-Shell-表达式与运算符" class="headerlink" title="三、 Shell 表达式与运算符"></a>三、 Shell 表达式与运算符</h1><h2 id="3-1-条件表达式"><a href="#3-1-条件表达式" class="headerlink" title="3.1 条件表达式"></a>3.1 条件表达式</h2><table><thead><tr><th>表达式</th><th>示例</th></tr></thead><tbody><tr><td>[expression]</td><td>[ 1 -eq 1 ]</td></tr><tr><td>[[expression]]</td><td>[[ 1 -eq 1 ]]</td></tr><tr><td>test expression</td><td>test 1 -eq 1 , 等同于 []</td></tr></tbody></table><h2 id="3-2-整数比较符"><a href="#3-2-整数比较符" class="headerlink" title="3.2 整数比较符"></a>3.2 整数比较符</h2><table><thead><tr><th>比较符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>- eq，equal</td><td>等于</td><td>[1 -eq 1] 为 true</td></tr><tr><td>- ne，not equal</td><td>不等于</td><td>[1 -ne 1] 为 false</td></tr><tr><td>- gt，greater than</td><td>大于</td><td>[2 -gt 1] 为 true</td></tr><tr><td>- lt，lesser than</td><td>小于</td><td>[2 -lt 1] 为 false</td></tr><tr><td>- ge，greater or equal</td><td>大于或等于</td><td>[2 -ge 1] 为 true</td></tr><tr><td>- le，lesser or equal</td><td>小于或等于</td><td>[2 -le 1] 为 false</td></tr></tbody></table><h2 id="3-3-字符串比较符"><a href="#3-3-字符串比较符" class="headerlink" title="3.3 字符串比较符"></a>3.3 字符串比较符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>==</td><td>等于</td><td>[“a” == “a”] 为 true</td></tr><tr><td>!=</td><td>不等于</td><td>[“a” != “a”] 为 false</td></tr><tr><td>&gt;</td><td>大于，判断字符串时根据 <br>ASCII 码表顺序，不常用</td><td>在 [] 表达式中：[ 2 &gt; 1 ]为 true<br > 在 [[]] 表达式中：[[ 2 &gt; 1 ]]为 true<br > 在 (()) 表达式中：(( 3 &gt; 2 ))为 true</td></tr><tr><td>&lt;</td><td>小于，判断字符串时根据 &lt; br&gt;ASCII 码表顺序，不常用</td><td>在 [] 表达式中：[ 2 &lt; 1 ]为 false<br > 在 [[]] 表达式中：[[ 2 &lt; 1 ]]为 false<br > 在 (()) 表达式中：(( 3 &lt; 2 ))为 false</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>在 (()) 表达式中：(( 3 &gt;= 2 ))为 true</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>在 (()) 表达式中：(( 3 &lt;= 2 ))为 false</td></tr><tr><td>- n</td><td>字符串长度不等于 0 为真</td><td>VAR1=1;VAR2=””<br>[ -n”$VAR1”] 为 true<br>[ -n”$VAR2” ] 为 false</td></tr><tr><td>- z</td><td>字符串长度等于 0 为真</td><td>VAR1=1;VAR2=””<br>[ -z”$VAR1”] 为 false<br>[ -z”$VAR2” ] 为 true</td></tr><tr><td>str</td><td>字符串存在为真</td><td>VAR1=1;VAR2=””<br>[ $VAR1 ] 为 true<br>[ $VAR2 ] 为 false</td></tr></tbody></table><p>需要注意的是，使用 -z 或 -n 判断字符串长度时，变量要加双引号。</p><p><strong>举例说明：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># [-z $a] &amp;&amp; echo yes || echo no</span>yes<span class="hljs-comment"># [-n $a] &amp;&amp; echo yes || echo no</span>yes<span class="hljs-comment"># 加了双引号才能正常判断是否为空</span><span class="hljs-comment"># [-z &quot;$a&quot;] &amp;&amp; echo yes || echo no</span>yes<span class="hljs-comment"># [-n &quot;$a&quot;] &amp;&amp; echo yes || echo no</span>no<span class="hljs-comment"># 使用了双中括号就不用了双引号</span><span class="hljs-comment"># [[-n $a]] &amp;&amp; echo yes || echo no</span>no<span class="hljs-comment"># [[-z $a]] &amp;&amp; echo yes || echo no</span>yes</code></pre><h2 id="3-4-文件测试"><a href="#3-4-文件测试" class="headerlink" title="3.4 文件测试"></a>3.4 文件测试</h2><table><thead><tr><th>测试符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>- e</td><td>文件或目录存在为真</td><td>[-e path] path 存在为 true</td></tr><tr><td>- f</td><td>文件存在为真</td><td>[-f file_path] 文件存在为 true</td></tr><tr><td>- d</td><td>目录存在为真</td><td>[-d dir_path] 目录存在为 true</td></tr><tr><td>- r</td><td>有读权限为真</td><td>[-r file_path] file_path 有读权限为 true</td></tr><tr><td>- w</td><td>有写权限为真</td><td>[-w file_path] file_path 有写权限为 true</td></tr><tr><td>- x</td><td>有执行权限为真</td><td>[-x file_path] file_path 有执行权限为 true</td></tr><tr><td>- s</td><td>文件存在并且大小大于 0 为真</td><td>[-s file_path] file_path 存在并且大小大于 0 为 true</td></tr></tbody></table><h2 id="3-5-布尔运算符"><a href="#3-5-布尔运算符" class="headerlink" title="3.5 布尔运算符"></a>3.5 布尔运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>!</td><td>非关系，条件结果取反</td><td>[! 1 -eq 2] 为 true</td></tr><tr><td>- a</td><td>和关系，在 [] 表达式中使用</td><td>[ 1 -eq 1 -a 2 -eq 2] 为 true</td></tr><tr><td>- o</td><td>或关系，在 [] 表达式中使用</td><td>[ 1 -eq 1 -o 2 -eq 1] 为 true</td></tr></tbody></table><h2 id="3-6-逻辑判断符"><a href="#3-6-逻辑判断符" class="headerlink" title="3.6 逻辑判断符"></a>3.6 逻辑判断符</h2><table><thead><tr><th>判断符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑和，在 [[]] 和(( ))表达式中 &lt; br &gt; 或判断表达式是否为真时使用</td><td>[[ 1 -eq 1 &amp;&amp; 2 -eq 2 ]]为 true<br>(( 1 == 1 &amp;&amp; 2 == 2 ))为 true<br>[ 1 -eq 1 ] &amp;&amp; echo yes 如果 &amp;&amp; 前 &lt; br &gt; 面表达式为 true 则执行后面的</td></tr><tr><td>||</td><td>逻辑或，在 [[]] 和(( ))表达式中 &lt; br &gt; 或判断表达式是否为真时使用</td><td>[[ 1 -eq 1</td></tr></tbody></table><h2 id="3-7-整数运算"><a href="#3-7-整数运算" class="headerlink" title="3.7 整数运算"></a>3.7 整数运算</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>%</td><td>取余</td></tr></tbody></table><table><thead><tr><th>运算表达式</th><th>示例</th></tr></thead><tbody><tr><td>$(())</td><td>$((1+1))</td></tr><tr><td>$[]</td><td>$[1+1]</td></tr></tbody></table><p>上面两个都不支持浮点运算。</p><p>$(()) 表达式还有一个用途，三目运算：</p><pre><code class="hljs bash"><span class="hljs-comment"># 如果条件为真返回 1 ，否则返回 0</span><span class="hljs-comment"># echo $((1&lt;0))</span>0<span class="hljs-comment"># echo $((1&gt;0))</span>1指定输出数字：<span class="hljs-comment"># echo $((1&gt;0?1:2))</span>1<span class="hljs-comment"># echo $((1&lt;0?1:2))</span>2注意：返回值不支持字符串</code></pre><h2 id="3-8-其他运算工具（let-expr-bc）"><a href="#3-8-其他运算工具（let-expr-bc）" class="headerlink" title="3.8 其他运算工具（let/expr/bc）"></a>3.8 其他运算工具（let/expr/bc）</h2><p>除了 Shell 本身的算数运算表达式，还有几个命令支持复杂的算数运算：</p><table><thead><tr><th>命令</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>let</td><td>赋值并运算，支持 ++、–</td><td>let VAR=(1+2)*3 ; echo $VAR<br>x=10 ; y=5<br>let x++;echo $x 每执行一次 x 加 1<br>let y–;echo $y 每执行一次 y 减 1<br>let x+=2 每执行一次 x 加 2<br>let x-=2 每执行一次 x 减 2</td></tr><tr><td>expr</td><td>乘法 \* 需要加反斜杠转义 \*</td><td>expr 1 \* 2 运算符两边必须有空格 <br>expr \( 1 + 2 \) \* 2 使用双括号时要转义</td></tr><tr><td>bc</td><td>计算器，支持浮点运算、平方等</td><td>bc 本身就是一个计算器，可直接输入命令，进入解释器。<br>echo 1 + 2 |bc 将管道符前面标准输出作为 bc 的标准输入 &lt; br&gt;echo “1.2+2” |bc<br>echo “10^10” |bc<br>echo ‘scale=2;10/3’ |bc 用 scale 保留两位小数点</td></tr></tbody></table><p>由于 Shell 不支持浮点数比较，可以借助 bc 来完成需求：</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;1.2 &lt; 2&quot; |bc</span>1<span class="hljs-comment"># echo &quot;1.2 &gt; 2&quot; |bc</span>0<span class="hljs-comment"># echo &quot;1.2 == 2.2&quot; |bc</span>0<span class="hljs-comment"># echo &quot;1.2 != 2.2&quot; |bc</span>1看出规律了嘛？运算如果为真返回 1 ，否则返回 0 ，写一个例子：<span class="hljs-comment"># [$(echo &quot;2.2&gt; 2&quot; |bc) -eq 1 ] &amp;&amp; echo yes || echo no</span>yes<span class="hljs-comment"># [$(echo &quot;2.2 &lt; 2&quot; |bc) -eq 1 ] &amp;&amp; echo yes || echo no</span>no</code></pre><p>expr 还可以对字符串操作, 获取字符串长度：</p><pre><code class="hljs bash"><span class="hljs-comment"># expr length &quot;string&quot;</span>6截取字符串：<span class="hljs-comment"># expr substr &quot;string&quot; 4 6</span>ing获取字符在字符串中出现的位置：<span class="hljs-comment"># expr index &quot;string&quot; str</span>1<span class="hljs-comment"># expr index &quot;string&quot; i</span>4获取字符串开始字符出现的长度：<span class="hljs-comment"># expr match &quot;string&quot; s.*</span>6<span class="hljs-comment"># expr match &quot;string&quot; str</span>3</code></pre><h2 id="3-9-Shell-括号用途总结"><a href="#3-9-Shell-括号用途总结" class="headerlink" title="3.9 Shell 括号用途总结"></a>3.9 Shell 括号用途总结</h2><p>看到这里，想一想里面所讲的小括号、中括号的用途，是不是有点懵逼了。那我们总结一下！</p><table><thead><tr><th>括号</th><th>用途</th></tr></thead><tbody><tr><td>()</td><td>用途 1 ：在运算中，先计算小括号里面的内容 &lt; br&gt; 用途 2 ：数组 &lt; br &gt; 用途 3 ：匹配分组</td></tr><tr><td>(())</td><td>用途 1 ：表达式，不支持 - eq 这类的运算符。不支持 - a 和 - o，支持 &lt;=、&gt;=、&lt;、&gt; 这类 &lt; br &gt; 比较符和 &amp;&amp;、||<br > 用途 2 ：C 语言风格的 for(())表达式</td></tr><tr><td>$( )</td><td>执行 Shell 命令，与反撇号等效</td></tr><tr><td>$(())</td><td>用途 1 ：简单算数运算 &lt; br &gt; 用途 2 ：支持三目运算符 $(( 表达式? 数字: 数字 ))</td></tr><tr><td>[ ]</td><td>条件表达式，里面不支持逻辑判断符</td></tr><tr><td>[[]]</td><td>条件表达式，里面不支持 - a 和 - o，不支持 &lt;= 和&gt;= 比较符，支持 - eq、&lt;、&gt; 这类比较 &lt; br &gt; 符。支持 =~ 模式匹配，也可以不用双引号也不会影响原意，比 [] 更加通用</td></tr><tr><td>$[ ]</td><td>简单算数运算</td></tr><tr><td>{}</td><td>对逗号（,）和点点（…）起作用，比如 touch {1,2} 创建 1 和 2 文件，touch<br>{1..3} 创建 1 、 2 和 3 文件</td></tr><tr><td>${}</td><td>用途 1 ：引用变量 &lt; br&gt; 用途 2 ：字符串处理</td></tr></tbody></table><h1 id="四、-Shell-流程控制"><a href="#四、-Shell-流程控制" class="headerlink" title="四、 Shell 流程控制"></a>四、 Shell 流程控制</h1><p>流程控制是改变程序运行顺序的指令。</p><h2 id="4-1-if-语句"><a href="#4-1-if-语句" class="headerlink" title="4.1 if 语句"></a>4.1 if 语句</h2><p>格式：<strong>if list; then list; [elif list; then list;] … [ else list; ] fi</strong></p><h3 id="4-1-1-单分支"><a href="#4-1-1-单分支" class="headerlink" title="4.1.1 单分支"></a>4.1.1 单分支</h3><pre><code class="hljs bash"><span class="hljs-keyword">if</span> 条件表达式; <span class="hljs-keyword">then</span>命令<span class="hljs-keyword">fi</span></code></pre><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>N=10<span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -gt 5]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> yes<span class="hljs-keyword">fi</span><span class="hljs-comment"># bash test.sh</span>yes</code></pre><h3 id="4-1-2-双分支"><a href="#4-1-2-双分支" class="headerlink" title="4.1.2 双分支"></a>4.1.2 双分支</h3><pre><code class="hljs bash"><span class="hljs-keyword">if</span> 条件表达式; <span class="hljs-keyword">then</span>命令<span class="hljs-keyword">else</span>命令<span class="hljs-keyword">fi</span></code></pre><p><strong>示例 1 ：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>N=10<span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -lt 5]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> yes<span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> no<span class="hljs-keyword">fi</span><span class="hljs-comment"># bash test.sh</span>no</code></pre><p><strong>示例 2 ：判断 crond 进程是否运行</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>NAME=crondNUM=$(ps -ef |grep <span class="hljs-variable">$NAME</span> |grep -vc grep)<span class="hljs-keyword">if</span> [<span class="hljs-variable">$NUM</span> -eq 1]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> running.&quot;</span><span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> is not running!&quot;</span><span class="hljs-keyword">fi</span></code></pre><p><strong>示例 3 ：检查主机是否存活</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">if</span> ping -c 1 192.168.1. 1 &gt;/dev/null; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;OK.&quot;</span><span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;NO!&quot;</span><span class="hljs-keyword">fi</span></code></pre><p>if 语句可以直接对命令状态进行判断，就省去了获取 $? 这一步！</p><h3 id="4-1-3-多分支"><a href="#4-1-3-多分支" class="headerlink" title="4.1.3 多分支"></a>4.1.3 多分支</h3><pre><code class="hljs bash"><span class="hljs-keyword">if</span> 条件表达式; <span class="hljs-keyword">then</span>命令<span class="hljs-keyword">elif</span> 条件表达式; <span class="hljs-keyword">then</span>命令<span class="hljs-keyword">else</span>命令<span class="hljs-keyword">fi</span></code></pre><p>当不确定条件符合哪一个时，就可以把已知条件判断写出来，做相应的处理。</p><p><strong>示例 1 ：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>N=<span class="hljs-variable">$1</span><span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -eq 3]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eq 3&quot;</span><span class="hljs-keyword">elif</span> [<span class="hljs-variable">$N</span> -eq 5]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eq 5&quot;</span><span class="hljs-keyword">elif</span> [<span class="hljs-variable">$N</span> -eq 8]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eq 8&quot;</span><span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;no&quot;</span><span class="hljs-keyword">fi</span></code></pre><p>如果第一个条件符合就不再向下匹配。</p><p><strong>示例 2 ：根据 Linux 不同发行版使用不同的命令安装软件</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">if</span> [-e /etc/redhat-release]; <span class="hljs-keyword">then</span>  yum install wget -y<span class="hljs-keyword">elif</span> [$(cat /etc/issue |cut -d<span class="hljs-string">&#x27;&#x27;</span> -f 1) ==<span class="hljs-string">&quot;Ubuntu&quot;</span> ]; <span class="hljs-keyword">then</span>  apt-get install wget -y<span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;perating system does not support.&#x27;</span>  <span class="hljs-built_in">exit</span><span class="hljs-keyword">fi</span></code></pre><h2 id="4-2-for-语句"><a href="#4-2-for-语句" class="headerlink" title="4.2 for 语句"></a>4.2 for 语句</h2><p>格式：<strong>for name [[ in [ word …] ] ; ] do list ; done</strong></p><pre><code class="hljs bash"><span class="hljs-keyword">for</span> 变量名 <span class="hljs-keyword">in</span> 取值列表; <span class="hljs-keyword">do</span>命令<span class="hljs-keyword">done</span></code></pre><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..3&#125;; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>123</code></pre><p>for 的语法也可以这么写：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; &#123; <span class="hljs-comment"># $@是将位置参数作为单个来处理</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>&#125;<span class="hljs-comment"># bash test.sh 1 2 3</span>123</code></pre><p>默认 for 循环的取值列表是以空白符分隔，也就是第一章讲系统变量里的 $IFS:</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 12 34; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>1234</code></pre><p>如果想指定分隔符，可以重新赋值 $IFS 变量：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>OLD_IFS=<span class="hljs-variable">$IFS</span>IFS=<span class="hljs-string">&quot;:&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(head -1 /etc/passwd); <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><span class="hljs-keyword">done</span>IFS=<span class="hljs-variable">$OLD_IFS</span> <span class="hljs-comment"># 恢复默认值</span><span class="hljs-comment"># bash test.sh</span>rootx00root/root/bin/bash</code></pre><p>for 循环还有一种 C 语言风格的语法，常用于计数、打印数字序列：</p><p><strong>for ((expr1 ; expr2 ; expr3)) ; do list ; done</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">for</span> ((i=1;i&lt;=5;i++)); <span class="hljs-keyword">do</span> <span class="hljs-comment"># 也可以 i--</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><span class="hljs-keyword">done</span></code></pre><p><strong>示例 1 ：检查多个主机是否存活</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> 192.168.1.&#123;1..254&#125;; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> ping -c 1 <span class="hljs-variable">$ip</span> &gt;/dev/null; <span class="hljs-keyword">then</span>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$ip</span> OK.&quot;</span>  <span class="hljs-keyword">else</span>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$ip</span> NO!&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><p><strong>示例 2 ：检查多个域名是否可以访问</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>URL=<span class="hljs-string">&quot;www.baidu.com www.sina.com www.jd.com&quot;</span><span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> <span class="hljs-variable">$URL</span>; <span class="hljs-keyword">do</span>  HTTP_CODE=$(curl -o /dev/null -s -w %&#123;http_code&#125; http://<span class="hljs-variable">$url</span>)  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -eq 200 -o <span class="hljs-variable">$HTTP_CODE</span> -eq 301]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$url</span> OK.&quot;</span>  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$url</span> NO!&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><h2 id="4-3-while-语句"><a href="#4-3-while-语句" class="headerlink" title="4.3 while 语句"></a>4.3 while 语句</h2><p>格式：<strong>while list; do list; done</strong></p><pre><code class="hljs bash"><span class="hljs-keyword">while</span> 条件表达式; <span class="hljs-keyword">do</span>命令<span class="hljs-keyword">done</span></code></pre><p><strong>示例 1 ：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>N=0<span class="hljs-keyword">while</span> [<span class="hljs-variable">$N</span> -lt 5]; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">let</span> N++  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$N</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>12345</code></pre><p>当条件表达式为 false 时，终止循环。</p><p><strong>示例 2 ：条件表达式为 true，将会产生死循环</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">while</span> [1 -eq 1]; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes&quot;</span><span class="hljs-keyword">done</span></code></pre><p>也可以条件表达式直接用 true：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes&quot;</span><span class="hljs-keyword">done</span></code></pre><p>还可以条件表达式用冒号，冒号在 Shell 中的意思是不做任何操作。但状态是 0 ，因此为 true：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">while</span> :; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes&quot;</span><span class="hljs-keyword">done</span></code></pre><p><strong>示例 3 ：逐行处理文本</strong></p><p>文本内容：</p><pre><code class="hljs bash"><span class="hljs-comment"># cat a.txt</span>a b c1 2 3x y z</code></pre><p>要想使用 while 循环逐行读取 a.txt 文件，有三种方式：</p><p><strong>方式 1 ：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>cat ./a.txt | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> LINE; <span class="hljs-keyword">do</span>                <span class="hljs-built_in">echo</span> <span class="hljs-variable">$LINE</span><span class="hljs-keyword">done</span></code></pre><p><strong>方式 2 ：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> LINE; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$LINE</span><span class="hljs-keyword">done</span> &lt; ./a.txt</code></pre><p><strong>方式 3 ：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">exec</span> &lt; ./a.txt <span class="hljs-comment"># 读取文件作为标准输出</span><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> LINE; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$LINE</span><span class="hljs-keyword">done</span></code></pre><p>与 while 关联的还有一个 until 语句，它与 while 不同之处在于，是当条件表达式为 false 时才循环，实际使用中比较少，这里不再讲解。</p><h2 id="4-4-break-和-continue-语句"><a href="#4-4-break-和-continue-语句" class="headerlink" title="4.4 break 和 continue 语句"></a>4.4 break 和 continue 语句</h2><ul><li>break    是终止循环。</li><li>continue 是跳出当前循环。</li></ul><p><strong>示例 1 ：在死循环中，满足条件终止循环</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>N=0<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">let</span> N++  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -eq 5]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">break</span>  <span class="hljs-keyword">fi</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$N</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>1234</code></pre><p>里面用了 <strong>if</strong> 判断，并用了 <strong>break</strong> 语句，它是跳出循环。与其关联的还有一个 <strong>continue</strong> 语句，它是跳出本次循环。</p><p><strong>示例 2 ：举例子说明 continue 用法</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>N=0<span class="hljs-keyword">while</span> [<span class="hljs-variable">$N</span> -lt 5]; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">let</span> N++  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -eq 3]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">continue</span>  <span class="hljs-keyword">fi</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$N</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>1245</code></pre><p>当变量 N 等于 3 时，continue 跳过了当前循环，没有执行下面的 echo。</p><p><strong>注意：continue 与 break 语句只能循环语句中使用。</strong></p><h2 id="4-5-case-语句"><a href="#4-5-case-语句" class="headerlink" title="4.5 case 语句"></a>4.5 case 语句</h2><p>case 语句一般用于选择性来执行对应部分块命令。</p><p>格式：<strong>case word in [[(] pattern [ | pattern ] … ) list ;; ] … esac</strong></p><pre><code class="hljs bash"><span class="hljs-keyword">case</span> 模式名 <span class="hljs-keyword">in</span>  模式 1)    命令    ;;  模式 2)    命令    ;;  *)    不符合以上模式执行的命令<span class="hljs-keyword">esac</span></code></pre><p>每个模式必须以右括号结束，命令结尾以双分号结束。</p><p><strong>示例：根据位置参数匹配不同的模式</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>  start)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;start.&quot;</span>    ;;  stop)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;stop.&quot;</span>    ;;  restart)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;restart.&quot;</span>    ;;  *)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$0</span> &#123;start|stop|restart&#125;&quot;</span><span class="hljs-keyword">esac</span><span class="hljs-comment"># bash test.sh</span>Usage: test.sh &#123;start|stop|restart&#125;<span class="hljs-comment"># bash test.sh start</span>start.<span class="hljs-comment"># bash test.sh stop</span>stop.<span class="hljs-comment"># bash test.sh restart</span>restart.</code></pre><p>上面例子是不是有点眼熟，在 Linux 下有一部分服务启动脚本都是这么写的。</p><p>模式也支持正则，匹配哪个模式就执行那个：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>  [0-9])    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;match number.&quot;</span>    ;;  [a-z])    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;match letter.&quot;</span>    ;;  <span class="hljs-string">&#x27;-h&#x27;</span>|<span class="hljs-string">&#x27;--help&#x27;</span>)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;help&quot;</span>    ;;  *)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Input error!&quot;</span>    <span class="hljs-built_in">exit</span><span class="hljs-keyword">esac</span><span class="hljs-comment"># bash test.sh 1</span>match number.<span class="hljs-comment"># bash test.sh a</span>match letter.<span class="hljs-comment"># bash test.sh - h</span><span class="hljs-built_in">help</span><span class="hljs-comment"># bash test.sh --help</span><span class="hljs-built_in">help</span></code></pre><p>模式支持的正则有：*、?、[]、[.-.]、|。后面有章节单独讲解 Shell 正则表达式。</p><h2 id="4-6-select-语句"><a href="#4-6-select-语句" class="headerlink" title="4.6 select 语句"></a>4.6 select 语句</h2><p>select 是一个类似于 for 循环的语句。</p><p>格式：<strong>select name [in word] ; do list ; done</strong></p><pre><code class="hljs bash">select 变量 <span class="hljs-keyword">in</span> 选项 1 选项 2; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">break</span><span class="hljs-keyword">done</span></code></pre><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>select mysql_version <span class="hljs-keyword">in</span> 5.1 5.6; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$mysql_version</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>1) 5.12) 5.6<span class="hljs-comment">#? 1</span>5.1<span class="hljs-comment">#? 2</span>5.6</code></pre><p>用户输入编号会直接赋值给变量 mysql_version。作为菜单用的话，循环第二次后就不再显示菜单了，并不能满足需求。</p><p>在外面加个死循环，每次执行一次 select 就 break 一次，这样就能每次显示菜单了：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>  select mysql_version <span class="hljs-keyword">in</span> 5.1 5.6; <span class="hljs-keyword">do</span>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$mysql_version</span>    <span class="hljs-built_in">break</span>  <span class="hljs-keyword">done</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>1) 5.12) 5.6<span class="hljs-comment">#? 1</span>5.11) 5.12) 5.6<span class="hljs-comment">#? 2</span>5.61) 5.12) 5.6</code></pre><p>如果再判断对用户输入的编号执行相应的命令，如果用 if 语句多分支的话要复杂许多，用 case 语句就简单多了：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>PS3=<span class="hljs-string">&quot;Select a number:&quot;</span><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>  select mysql_version <span class="hljs-keyword">in</span> 5.1 5.6 quit; <span class="hljs-keyword">do</span>    <span class="hljs-keyword">case</span> <span class="hljs-variable">$mysql_version</span> <span class="hljs-keyword">in</span>      5.1)        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;mysql 5.1&quot;</span>        <span class="hljs-built_in">break</span>        ;;      5.6)        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;mysql 5.6&quot;</span>        <span class="hljs-built_in">break</span>        ;;      quit)        <span class="hljs-built_in">exit</span>        ;;      *)         <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Input error, Please enter again!&quot;</span>      <span class="hljs-built_in">break</span>    <span class="hljs-keyword">esac</span>  <span class="hljs-keyword">done</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>1) 5.12) 5.63) quitSelect a number: 1mysql 5.11) 5.12) 5.63) quitSelect a number: 2mysql 5.61) 5.12) 5.63) quitSelect a number: 3</code></pre><p>如果不想用默认的提示符，可以通过重新赋值变量 PS3 来自定义。这下就比较完美了！</p><h1 id="五、-Shell-函数与数组"><a href="#五、-Shell-函数与数组" class="headerlink" title="五、 Shell 函数与数组"></a>五、 Shell 函数与数组</h1><h2 id="5-1-函数"><a href="#5-1-函数" class="headerlink" title="5.1 函数"></a>5.1 函数</h2><p><strong>格式：</strong></p><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;<span class="hljs-built_in">command</span>&#125;</code></pre><p><strong>function</strong> 关键字可写，也可不写。</p><p><strong>示例 1 ：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a function.&quot;</span>&#125;func<span class="hljs-comment"># bash test.sh</span>This is a <span class="hljs-keyword">function</span>.</code></pre><p>Shell 函数很简单，函数名后跟双括号，再跟双大括号。通过函数名直接调用，不加小括号。</p><p><strong>示例 2 ：函数返回值</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;  VAR=$((<span class="hljs-number">1</span>+<span class="hljs-number">1</span>))  <span class="hljs-built_in">return</span> <span class="hljs-variable">$VAR</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a function.&quot;</span>&#125;func<span class="hljs-built_in">echo</span> $?<span class="hljs-comment"># bash test.sh</span>2</code></pre><p>return 在函数中定义状态返回值，返回并终止函数，但返回的只能是 0 - 255 的数字，类似于 exit。</p><p><strong>示例 3 ：函数传参</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$1</span>&quot;</span>&#125;func world<span class="hljs-comment"># bash test.sh</span>Hello world</code></pre><p>通过 Shell 位置参数给函数传参。</p><p>函数也支持递归调用，也就是自己调用自己。</p><p><strong>例如：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-function"><span class="hljs-title">test</span></span>() &#123;  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span>  sleep 1  <span class="hljs-built_in">test</span> hello&#125;<span class="hljs-built_in">test</span></code></pre><p>执行会一直在调用本身打印 hello，这就形成了闭环。</p><p>像经典的 fork 炸弹就是函数递归调用：</p><p><code>:()&#123; :|:&amp;&#125;;:</code> 或 <code>.()&#123;.|.&amp;&#125;;.</code></p><p>这样看起来不好理解，我们更改下格式：</p><pre><code class="hljs bash">:() &#123;  :|:&amp;&#125;;:</code></pre><p>再易读一点：</p><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">bomb</span></span>() &#123;  bomb|bomb&amp;&#125;;bomb</code></pre><p>分析下：</p><ul><li>:(){} 定义一个函数，函数名是冒号。</li><li>: 调用自身函数</li><li>| 管道符</li><li>: 再一次递归调用自身函数</li><li>:|: 表示每次调用函数 “:” 的时候就会生成两份拷贝。</li><li>&amp; 放到后台</li><li>; 分号是继续执行下一个命令，可以理解为换行。</li><li>: 最后一个冒号是调用函数。</li></ul><p>因此不断生成新进程，直到系统资源崩溃。</p><p>一般递归函数用的也少，了解下即可！</p><h2 id="5-2-数组"><a href="#5-2-数组" class="headerlink" title="5.2 数组"></a>5.2 数组</h2><p>数组是相同类型的元素按一定顺序排列的集合。</p><p><strong>格式：</strong></p><p>array=(元素 1 元素 2 元素 3 …)</p><p>用小括号初始化数组，元素之间用空格分隔。</p><p><strong>定义方法 1</strong> ：初始化数组</p><p>array=(a b c)</p><p><strong>定义方法 2</strong> ：新建数组并添加元素</p><p>array[下标]= 元素</p><p><strong>定义方法 3</strong>：将命令输出作为数组元素</p><p>array=($(command))</p><p><strong>数组操作：</strong></p><pre><code class="hljs bash">获取所有元素：<span class="hljs-comment"># echo $&#123;array[*]&#125; # * 和 @ 都是代表所有元素</span>a b c获取元素下标：<span class="hljs-comment"># echo $&#123;!a[@]&#125;</span>0 1 2获取数组长度：<span class="hljs-comment"># echo $&#123;#array[*]&#125;</span>3获取第一个元素：<span class="hljs-comment"># echo $&#123;array[0]&#125;</span>a获取第二个元素：<span class="hljs-comment"># echo $&#123;array[1]&#125;</span>b获取第三个元素：<span class="hljs-comment"># echo $&#123;array[2]&#125;</span>c添加元素：<span class="hljs-comment"># array[3]=d</span><span class="hljs-comment"># echo $&#123;array[*]&#125;</span>a b c d添加多个元素：<span class="hljs-comment"># array+=(e f g)</span><span class="hljs-comment"># echo $&#123;array[*]&#125;</span>a b c d e f g删除第一个元素：<span class="hljs-comment"># unset array[0] # 删除会保留元素下标</span><span class="hljs-comment"># echo $&#123;array[*]&#125;</span>b c d e f g删除数组：<span class="hljs-comment"># unset array</span></code></pre><p><font color=red> 数组下标从 0 开始。</font></p><p><strong>示例 1</strong>：讲 seq 生成的数字序列循环放到数组里面</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(seq 1 10); <span class="hljs-keyword">do</span>  array[a]=<span class="hljs-variable">$i</span>  <span class="hljs-built_in">let</span> a++<span class="hljs-keyword">done</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[*]&#125;</span><span class="hljs-comment"># bash test.sh</span>1 2 3 4 5 6 7 8 9 10</code></pre><p><strong>示例 2</strong> ：遍历数组元素</p><pre><code class="hljs bash">方法 1 ：<span class="hljs-meta">#!/bin/bash</span>IP=(192.168.1.1 192.168.1.2 192.168.1.3)<span class="hljs-keyword">for</span> ((i=0;i&lt;<span class="hljs-variable">$&#123;#IP[*]&#125;</span>;i++)); <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;IP[$i]&#125;</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>192.168.1.1192.168.1.2192.168.1.3方法 2 ：<span class="hljs-meta">#!/bin/bash</span>IP=(192.168.1.1 192.168.1.2 192.168.1.3)<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;IP[*]&#125;</span>; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span><span class="hljs-keyword">done</span></code></pre><h1 id="六、-Shell-正则表达式"><a href="#六、-Shell-正则表达式" class="headerlink" title="六、 Shell 正则表达式"></a>六、 Shell 正则表达式</h1><p>正则表达式在每种语言中都会有，功能就是匹配符合你预期要求的字符串。</p><p>Shell 正则表达式分为 <strong>两种</strong>：</p><ul><li>基础正则表达式：BRE（basic regular express）</li><li>扩展正则表达式：ERE（extend regular express），扩展的表达式有 +、?、| 和 ()</li></ul><p>下面是一些常用的正则表达式符号，我们先拿 grep 工具举例说明。</p><table><thead><tr><th>符号</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符 (\n) 之外的任 &lt; br &gt; 意单个字符</td><td>匹配 123 ：<br>echo -e “123\n456” |grep ‘1.3’</td></tr><tr><td>^</td><td>匹配前面字符串开头</td><td>匹配以 abc 开头的行：<br>echo -e “abc\nxyz” |grep ^abc</td></tr><tr><td>$</td><td>匹配前面字符串结尾</td><td>匹配以 xyz 结尾的行：<br>echo -e “abc\nxyz” |grep xyz$</td></tr><tr><td>*</td><td>匹配前一个字符零个或多个</td><td>匹配 x、xo 和 xoo：<br>echo -e “x\nxo\nxoo\no\noo” |grep “xo*”<br>x 是必须的，批量了 0 零个或多个</td></tr><tr><td>+</td><td>匹配前面字符 1 个或多个</td><td>匹配 abc 和 abcc：<br>echo -e “abc\nabcc\nadd” |grep -E ‘ab+’<br > 匹配单个数字：echo “113” |grep -o ‘[0-9]’<br > 连续匹配多个数字：echo “113” |grep -E -o ‘[0-9]+’</td></tr><tr><td>？</td><td>匹配前面字符 0 个或 1 个</td><td>匹配 ac 或 abc：<br>echo -e “ac\nabc\nadd” |grep -E ‘a?c’</td></tr><tr><td>[]</td><td>匹配中括号之中的任意一个字符</td><td>匹配 a 或 c：<br>echo -e “a\nb\nc” |grep ‘[ac]’</td></tr><tr><td>[.-.]</td><td>匹配中括号中范围内的任意一个字符</td><td>匹配所有字母：<br>echo -e “a\nb\nc” |grep ‘[a-z]’</td></tr><tr><td>[^]</td><td>匹配 [^ 字符] 之外的任意一个字符</td><td>匹配 a 或 b：<br>echo -e “a\nb\nc” |grep ‘[^c-z]’<br > 匹配末尾数字：echo “abc:cde;123” |grep -E<br>‘[^;]+$’</td></tr><tr><td>^[^]</td><td>匹配不是中括号内任意一个 &lt; br &gt; 字符开头的行</td><td>匹配不是 #开头的行：<br>grep ‘^[^#]’ /etc/httpd/conf/httpd.conf</td></tr><tr><td>{n} 或 &lt; br&gt;{n,}</td><td>匹配花括号前面字符至少 n 个字符</td><td>匹配 abc 字符串（至少三个字符以上字符串）：<br>echo -e “a\nabc\nc” |grep -E ‘[a-z]{3}’</td></tr><tr><td>{n,m}</td><td>匹配花括号前面字符至少 n<br > 个字符，最多 m 个字符</td><td>匹配 12 和 123 （不加边界符会匹配单个字符）：<br>echo -e “1\n12\n123\n1234” |grep -E -w -o ‘[0-9]{2,3}’</td></tr><tr><td>&lt;</td><td>边界符，匹配字符串开始</td><td>匹配开始是 123 和 1234 ：<br>echo - e “1\n12\n123\n1234” |grep ‘&lt;123’</td></tr><tr><td>&gt;</td><td>边界符，匹配字符串结束</td><td>匹配结束是 1234 ：<br>echo - e “1\n12\n123\n1234” |grep ‘4&gt;‘</td></tr><tr><td>()</td><td>单元或组合：将小括号里面 &lt; br&gt; 作为一个组合 &lt; br &gt; 分组：匹配小括号中正则表 &lt; br &gt; 达式或字符。\n 反向引 &lt; br &gt; 用，n 是数字，从 1 开始编 &lt; br &gt; 号，表示引用第 n 个分组匹 &lt; br &gt; 配的内容</td><td>单元：匹配 123a 字符串 &lt; br&gt;echo “123abc” |grep -E -o ‘([0-9a-z]){4}’<br > 分组：匹配 11<br>echo “113abc” |grep -E -o ‘(1)\1’<br > 匹配出现 xo 出现零次或多次：<br>echo -e “x\nxo\nxoo\no\noo” |egrep “(xo)*”</td></tr><tr><td>|</td><td>匹配竖杠两边的任意一个</td><td>匹配 12 和 123 ：<br>echo -e “1\n12\n123\n1234” |grep -E ‘12&gt;|123&gt;‘</td></tr><tr><td>\</td><td>转义符，将特殊符号转成原 <br> 有意义</td><td>1.2，匹配 1.2： 1 .2，否则 112 也会匹配到</td></tr></tbody></table><table><thead><tr><th>Posix 字符</th><th>描述</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>等效 [a-zA-Z0-9]</td></tr><tr><td>[:alpha:]</td><td>等效 [a-zA-Z]</td></tr><tr><td>[:lower:]</td><td>等效 [a-z]</td></tr><tr><td>[:upper:]</td><td>等效 [A-Z]</td></tr><tr><td>[:digit:]</td><td>等效 [0-9]</td></tr><tr><td>[:space:]</td><td>匹配任意空白字符，等效 [\t\n\r\f\v]</td></tr><tr><td>[:graph:]</td><td>非空白字符</td></tr><tr><td>[:blank:]</td><td>空格与定位字符</td></tr><tr><td>[:cntrl:]</td><td>控制字符</td></tr><tr><td>[:print:]</td><td>可显示的字符</td></tr><tr><td>[:punct:]</td><td>标点符号字符</td></tr><tr><td>[:xdigit:]</td><td>十六进制</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;1\n12\n123\n1234a&quot;</span> |grep <span class="hljs-string">&#x27;[[:digit:]]&#x27;</span></code></pre><p>在 Shell 下使用这些正则表达式处理文本最多的命令有下面几个工具：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>grep</td><td>默认不支持扩展表达式，加 - E 选项开启 ERE。如果不加 - E 使用花括号要加 <br> 转义符 {}</td></tr><tr><td>egrep</td><td>支持基础和扩展表达式</td></tr><tr><td>awk</td><td>支持 egrep 所有的正则表达式</td></tr><tr><td>sed</td><td>默认不支持扩展表达式，加 - r 选项开启 ERE。如果不加 - r 使用花括号要加 <br> 转义符 {}</td></tr></tbody></table><table><thead><tr><th>支持的特殊字符</th><th>描述</th></tr></thead><tbody><tr><td>\w</td><td>匹配任意数字和字母，等效 [a-zA-Z0-9_]</td></tr><tr><td>\W</td><td>与 \ w 相反，等效 [^a-zA-Z0-9_]</td></tr><tr><td>\b</td><td>匹配字符串开始或结束，等效 \&lt;和 \&gt;</td></tr><tr><td>\s</td><td>匹配任意的空白字符</td></tr><tr><td>\S</td><td>匹配非空白字符</td></tr></tbody></table><table><thead><tr><th>空白符</th><th>描述</th></tr></thead><tbody><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\ 0</td><td>空值符</td></tr><tr><td>\b</td><td>退后一格</td></tr></tbody></table><h1 id="七、-Shell-文本处理三剑客"><a href="#七、-Shell-文本处理三剑客" class="headerlink" title="七、 Shell 文本处理三剑客"></a>七、 Shell 文本处理三剑客</h1><h2 id="7-1-grep"><a href="#7-1-grep" class="headerlink" title="7.1 grep"></a>7.1 grep</h2><p>过滤来自一个文件或标准输入匹配模式内容。</p><p>除了 grep 外，还有 egrep、fgrep。egrep 是 grep 的扩展，相当于 grep -E。fgrep 相当于 grep -f，用的少。</p><p><strong>Usage: grep [OPTION]… PATTERN [FILE]…</strong></p><table><thead><tr><th>支持的正则</th><th>描述</th></tr></thead><tbody><tr><td>- E，–extended-regexp</td><td>模式是扩展正则表达式（ERE）</td></tr><tr><td>- P，–perl-regexp</td><td>模式是 Perl 正则表达式</td></tr><tr><td>- e，–regexp=PATTERN</td><td>使用模式匹配，可指定多个模式匹配</td></tr><tr><td>- f，–file=FILE</td><td>从文件每一行获取匹配模式</td></tr><tr><td>- i，–ignore-case</td><td>忽略大小写</td></tr><tr><td>- w，–word-regexp</td><td>模式匹配整个单词</td></tr><tr><td>- x，–line-regexp</td><td>模式匹配整行</td></tr><tr><td>- v，–invert-match</td><td>打印不匹配的行</td></tr></tbody></table><table><thead><tr><th>输出控制</th><th>描述</th></tr></thead><tbody><tr><td>- m，–max-count=NUM</td><td>输出匹配的结果 num 数</td></tr><tr><td>- n，–line-number</td><td>打印行号</td></tr><tr><td>- H，–with-filename</td><td>打印每个匹配的文件名</td></tr><tr><td>- h，–no-filename</td><td>不输出文件名</td></tr><tr><td>- o，–only-matching</td><td>只打印匹配的内容</td></tr><tr><td>- q，–quiet</td><td>不输出正常信息</td></tr><tr><td>- s, –no-messages</td><td>不输出错误信息</td></tr><tr><td>- r，–recursive</td><td>递归目录</td></tr><tr><td>- c，–count</td><td>只打印每个文件匹配的行数</td></tr><tr><td>–include=FILE_PATTERN</td><td>只检索匹配的文件</td></tr><tr><td>–exclude=FILE_PATTERN</td><td>跳过匹配的文件</td></tr><tr><td>–exclude-from=FILE</td><td>跳过匹配的文件，来自文件模式</td></tr><tr><td>–exclude-dir=PATTERN</td><td>跳过匹配的目录</td></tr></tbody></table><table><thead><tr><th>内容行控制</th><th>描述</th></tr></thead><tbody><tr><td>- B，–before-context=NUM</td><td>打印匹配的前几行</td></tr><tr><td>- A，–after-context=NUM</td><td>打印匹配的后几行</td></tr><tr><td>- C，–context=NUM</td><td>打印匹配的前后几行</td></tr><tr><td>–color[=WHEN]</td><td>匹配的字体颜色</td></tr></tbody></table><p><strong>示例：</strong></p><p>1 ）输出 b 文件中在 a 文件相同的行</p><pre><code class="hljs bash"><span class="hljs-comment"># grep -f a b</span></code></pre><p>2 ）输出 b 文件中在 a 文件不同的行</p><pre><code class="hljs bash"><span class="hljs-comment"># grep -v -f a b</span></code></pre><p>3 ） 匹配多个模式</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a bc de&quot; |xargs -n1 |grep -e &#x27;a&#x27; -e &#x27;bc&#x27;</span>abc</code></pre><p>4 ）去除空格 http.conf 文件空行或开头 #号的行</p><pre><code class="hljs bash"><span class="hljs-comment"># grep -E -v &quot;^$|^#&quot; /etc/httpd/conf/httpd.conf</span></code></pre><p>5 ） 匹配开头不分大小写的单词</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;A a b c&quot; |xargs -n1 |grep -i a</span>或<span class="hljs-comment"># echo &quot;A a b c&quot; |xargs -n1 |grep &#x27;[Aa]&#x27;</span>Aa</code></pre><p>6 ）只显示匹配的字符串</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;this is a test&quot; |grep -o &#x27;is&#x27;</span>isis</code></pre><p>7 ）输出匹配的前五个结果</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 1 20 |grep -m 5 -E &#x27;[0-9]&#123;2&#125;&#x27;</span>1011121314</code></pre><p>8 ）统计匹配多少行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 1 20 |grep -c -E &#x27;[0-9]&#123;2&#125;&#x27;</span>11</code></pre><p>9 ） 匹配 b 字符开头的行</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a bc de&quot; |xargs -n1 |grep &#x27;^b&#x27;</span>bc</code></pre><p>10 ） 匹配 de 字符结尾的行并输出匹配的行</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a ab abc abcd abcde&quot; |xargs -n1 |grep -n &#x27;de$&#x27;</span>5:abcde</code></pre><p>11 ） 递归搜索 / etc 目录下包含 ip 的 conf 后缀文件</p><pre><code class="hljs bash"><span class="hljs-comment"># grep -r &#x27;192.167.1.1&#x27; /etc --include *.conf</span></code></pre><p>12 ） 排除搜索 bak 后缀的文件</p><pre><code class="hljs bash"><span class="hljs-comment"># grep -r &#x27;192.167.1.1&#x27; /opt --exclude *.bak</span></code></pre><p>13 ） 排除来自 file 中的文件</p><pre><code class="hljs bash"><span class="hljs-comment"># grep -r &#x27;192.167.1.1&#x27; /opt --exclude-from file</span></code></pre><p>14 ） 匹配 41 或 42 的数字</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 41 45 |grep -E &#x27;4[12]&#x27;</span>4142</code></pre><p>15 ） 匹配至少 2 个字符</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 13 |grep -E &#x27;[0-9]&#123;2&#125;&#x27;</span>10111213</code></pre><p>16 ） 匹配至少 2 个字符的单词，最多 3 个字符的单词</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a ab abc abcd abcde&quot; |xargs -n1 |grep -E -w -o &#x27;[a-z]&#123;2,3&#125;&#x27;</span>ababc</code></pre><p>17 ） 匹配所有 IP</p><pre><code class="hljs bash"><span class="hljs-comment"># ifconfig |grep -E -o &quot;[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;&quot;</span></code></pre><p>18 ） 打印匹配结果及后 3 行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 1 10 |grep 5 -A 3</span>5678</code></pre><p>19 ） 打印匹配结果及前 3 行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 1 10 |grep 5 -B 3</span>2345</code></pre><p>20 ） 打印匹配结果及前后 3 行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 1 10 |grep 5 -C 3</span>2 3 4 5 6 7 8</code></pre><p>21 ） 不显示输出</p><pre><code class="hljs bash">不显示错误输出：<span class="hljs-comment"># grep &#x27;a&#x27; abc</span>grep: abc: No such file or directory<span class="hljs-comment"># grep -s &#x27;a&#x27; abc</span><span class="hljs-comment"># echo $?</span>2不显示正常输出：<span class="hljs-comment"># grep -q &#x27;a&#x27; a.txt</span></code></pre><p>grep 支持上一章的基础和扩展正则表达式字符。</p><h2 id="7-2-sed"><a href="#7-2-sed" class="headerlink" title="7.2 sed"></a>7.2 sed</h2><p>流编辑器，过滤和替换文本。</p><p><strong>工作原理</strong>：sed 命令将当前处理的行读入模式空间进行处理，处理完把结果输出，并清空模式空间。然后再将下一行读入模式空间进行处理输出，以此类推，直到最后一行。还有一个空间叫保持空间，又称暂存空间，可以暂时存放一些处理的数据，但不能直接输出，只能放到模式空间输出。这两个空间其实就是在内存中初始化的一个内存区域，存放正在处理的数据和临时存放的数据。</p><p><strong>Usage:</strong></p><p>sed [OPTION]… {script-only-if-no-other-script} [input-file]…</p><p>sed [选项] ‘地址 命令’ file</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-n</td><td>不打印模式空间</td></tr><tr><td>-e</td><td>执行脚本、表达式来处理</td></tr><tr><td>-f</td><td>执行动作从文件读取执行</td></tr><tr><td>-i</td><td>修改原文件</td></tr><tr><td>-r</td><td>使用扩展正则表达式</td></tr></tbody></table><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>s/regexp/replacement/</td><td>替换字符串</td></tr><tr><td>p</td><td>打印当前模式空间</td></tr><tr><td>P</td><td>打印模式空间的第一行</td></tr><tr><td>d</td><td>删除模式空间，开始下一个循环</td></tr><tr><td>D</td><td>删除模式空间的第一行，开始下一个循环</td></tr><tr><td>=</td><td>打印当前行号</td></tr><tr><td>a \text</td><td>当前行追加文本</td></tr><tr><td>i \text</td><td>当前行上面插入文本</td></tr><tr><td>c \text</td><td>所选行替换新文本</td></tr><tr><td>q</td><td>立即退出 sed 脚本</td></tr><tr><td>r</td><td>追加文本来自文件</td></tr><tr><td>: label</td><td>label 为 b 和 t 命令</td></tr><tr><td>b label</td><td>分支到脚本中带有标签的位置，如果分支不存在则分支到脚本的末尾</td></tr><tr><td>t label</td><td>如果 s/// 是一个成功的替换，才跳转到标签</td></tr><tr><td>h H</td><td>复制 / 追加模式空间到保持空间</td></tr><tr><td>g G</td><td>复制 / 追加保持空间到模式空间</td></tr><tr><td>x</td><td>交换模式空间和保持空间内容</td></tr><tr><td>l</td><td>打印模式空间的行，并显示控制字符 $</td></tr><tr><td>n N</td><td>读取 / 追加下一行输入到模式空间</td></tr><tr><td>w</td><td>filename 写入当前模式空间到文件</td></tr><tr><td>!</td><td>取反、否定</td></tr><tr><td>&amp;</td><td>引用已匹配字符串</td></tr></tbody></table><table><thead><tr><th>地址</th><th>描述</th></tr></thead><tbody><tr><td>first~step</td><td>步长，每 step 行，从第 first 开始</td></tr><tr><td>$</td><td>匹配最后一行</td></tr><tr><td>/regexp/</td><td>正则表达式匹配行</td></tr><tr><td>number</td><td>只匹配指定行</td></tr><tr><td>addr1,addr2</td><td>开始匹配 addr1 行开始，直接 addr2 行结束</td></tr><tr><td>addr1,+N</td><td>从 addr1 行开始，向后的 N 行</td></tr><tr><td>addr1,~N</td><td>从 addr1 行开始，到 N 行结束</td></tr></tbody></table><p>借助以下文本内容作为示例讲解：</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services</span>nimgtw        48003/udp   <span class="hljs-comment"># Nimbus Gateway</span>3gpp-cbsp     48049/tcp   <span class="hljs-comment"># 3GPP Cell Broadcast Service Protocol</span>isnetserv     48128/tcp   <span class="hljs-comment"># Image Systems Network Services</span>isnetserv     48128/udp   <span class="hljs-comment"># Image Systems Network Services</span>blp5          48129/tcp   <span class="hljs-comment"># Bloomberg locator</span>blp5          48129/udp   <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp   <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp   <span class="hljs-comment"># com-bardac-dw</span>iqobject      48619/tcp   <span class="hljs-comment"># iqobject</span>iqobject      48619/udp   <span class="hljs-comment"># iqobject</span></code></pre><h3 id="7-2-1-匹配打印（p）"><a href="#7-2-1-匹配打印（p）" class="headerlink" title="7.2.1 匹配打印（p）"></a>7.2.1 匹配打印（p）</h3><p>1 ）打印匹配 blp5 开头的行</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;/^blp5/p&#x27;</span>blp5     48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>blp5     48129/udp     <span class="hljs-comment"># Bloomberg locator</span></code></pre><p>2 ）打印第一行</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;1p&#x27;</span>nimgtw     48003/udp     <span class="hljs-comment"># Nimbus Gateway</span></code></pre><p>3 ）打印第一行至第三行</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;1,3p&#x27;</span>nimgtw         48003/udp     <span class="hljs-comment"># Nimbus Gateway</span>3gpp-cbsp      48049/tcp     <span class="hljs-comment"># 3GPP Cell Broadcast Service Protocol</span>isnetserv      48128/tcp     <span class="hljs-comment"># Image Systems Network Services</span></code></pre><p>4 ）打印奇数行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 10 |sed -n &#x27;1~2p&#x27;</span>13579</code></pre><p>5 ）打印匹配行及后一行</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;/blp5/,+1p&#x27;</span>blp5      48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>blp5      48129/udp     <span class="hljs-comment"># Bloomberg locator</span></code></pre><p>6 ）打印最后一行</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;$p&#x27;</span>iqobject       48619/udp      <span class="hljs-comment"># iqobject</span></code></pre><p>7 ）不打印最后一行</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;$!p&#x27;</span>3gpp-cbsp      48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>Protocolisnetserv      48128/tcp     <span class="hljs-comment"># Image Systems Network Services</span>isnetserv      48128/udp     <span class="hljs-comment"># Image Systems Network Services</span>blp5           48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>blp5           48129/udp     <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw  48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw  48556/udp     <span class="hljs-comment"># com-bardac-dw</span>iqobject       48619/tcp     <span class="hljs-comment"># iqobject</span>iqobject       48619/udp     <span class="hljs-comment"># iqobject</span></code></pre><p>感叹号也就是对后面的命令取反。</p><p>8 ）匹配范围</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;/^blp5/,/^com/p&#x27;</span>blp5            48129/tcp       <span class="hljs-comment"># Bloomberg locator</span>blp5            48129/udp       <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw   48556/tcp       <span class="hljs-comment"># com-bardac-dw</span></code></pre><p>匹配开头行到最后一行：</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;/blp5/,$p&#x27;</span>blp5          48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>blp5          48129/udp     <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp     <span class="hljs-comment"># com-bardac-dw</span>iqobject      48619/tcp     <span class="hljs-comment"># iqobject</span>iqobject      48619/udp     <span class="hljs-comment"># iqobject</span></code></pre><p>以逗号分开两个样式选择某个范围。</p><p>9 ）引用系统变量，用引号</p><pre><code class="hljs bash"><span class="hljs-comment"># a=1</span><span class="hljs-comment"># tail /etc/services |sed -n &#x27;&#x27;$a&#x27;,3p&#x27;</span>或<span class="hljs-comment"># tail /etc/services |sed -n &quot;$a,3p&quot;</span></code></pre><p>sed 命令用单引号时，里面变量用单引号引起来，或者 sed 命令用双引号，因为双引号解释特殊符号原有意义。</p><h3 id="7-2-2-匹配删除（d）"><a href="#7-2-2-匹配删除（d）" class="headerlink" title="7.2.2 匹配删除（d）"></a>7.2.2 匹配删除（d）</h3><p>删除与打印使用方法类似，简单举几个例子。</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/d&#x27;</span>nimgtw            48003/udp    <span class="hljs-comment"># Nimbus Gateway</span>3gpp-cbsp         48049/tcp    <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv         48128/tcp    <span class="hljs-comment"># Image Systems Network Services</span>isnetserv         48128/udp    <span class="hljs-comment"># Image Systems Network Services</span>com-bardac-dw     48556/tcp    <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw     48556/udp    <span class="hljs-comment"># com-bardac-dw</span>iqobject          48619/tcp    <span class="hljs-comment"># iqobject</span>iqobject          48619/udp    <span class="hljs-comment"># iqobject</span><span class="hljs-comment"># tail /etc/services |sed &#x27;1d&#x27;</span>3gpp-cbsp        48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>Protocolisnetserv        48128/tcp     <span class="hljs-comment"># Image Systems Network Services</span>isnetserv        48128/udp     <span class="hljs-comment"># Image Systems Network Services</span>blp5             48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>blp5             48129/udp     <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw    48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw    48556/udp     <span class="hljs-comment"># com-bardac-dw</span>iqobject         48619/tcp     <span class="hljs-comment"># iqobject</span>iqobject         48619/udp     <span class="hljs-comment"># iqobject</span><span class="hljs-comment"># tail /etc/services |sed &#x27;1~2d&#x27;</span>3gpp-cbsp         48049/tcp     <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv         48128/udp     <span class="hljs-comment"># Image Systems Network Services</span>blp5              48129/udp     <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw     48556/udp     <span class="hljs-comment"># com-bardac-dw</span>iqobject          48619/udp     <span class="hljs-comment"># iqobject</span><span class="hljs-comment"># tail /etc/services |sed &#x27;1,3d&#x27;</span>isnetserv         48128/udp     <span class="hljs-comment"># Image Systems Network Services</span>blp5              48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>blp5              48129/udp     <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw     48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw     48556/udp     <span class="hljs-comment"># com-bardac-dw</span>iqobject          48619/tcp     <span class="hljs-comment"># iqobject</span>iqobject          48619/udp     <span class="hljs-comment"># iqobject</span></code></pre><p>去除空格 http.conf 文件空行或开头 # 号的行：</p><pre><code class="hljs bash"><span class="hljs-comment"># sed &#x27;/^#/d;/^$/d&#x27; /etc/httpd/conf/httpd.conf</span></code></pre><p>打印是把匹配的打印出来，删除是把匹配的删除，删除只是不用 -n 选项。</p><h3 id="7-2-3-替换（s-）"><a href="#7-2-3-替换（s-）" class="headerlink" title="7.2.3 替换（s///）"></a>7.2.3 替换（s///）</h3><p>1 ）替换 blp5 字符串为 test</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;s/blp5/test/&#x27;</span>3gpp-cbsp          48049/tcp     <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv          48128/tcp     <span class="hljs-comment"># Image Systems Network Services</span>isnetserv          48128/udp     <span class="hljs-comment"># Image Systems Network Services</span><span class="hljs-built_in">test</span>               48129/tcp     <span class="hljs-comment"># Bloomberg locator</span><span class="hljs-built_in">test</span>               48129/udp     <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw      48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw      48556/udp     <span class="hljs-comment"># com-bardac-dw</span>iqobject           48619/tcp     <span class="hljs-comment"># iqobject</span>iqobject           48619/udp     <span class="hljs-comment"># iqobject</span>matahari           49000/tcp     <span class="hljs-comment"># Matahari Broker</span></code></pre><p>全局替换加 g：</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;s/blp5/test/g&#x27;</span></code></pre><p>2 ）替换开头是 blp5 的字符串并打印</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;s/^blp5/test/p&#x27;</span><span class="hljs-built_in">test</span>          481 29/tcp      <span class="hljs-comment"># Bloomberg locator</span><span class="hljs-built_in">test</span>          48129/udp       <span class="hljs-comment"># Bloomberg locator</span></code></pre><p>3 ）使用 &amp; 命令引用匹配内容并替换</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;s/48049/&amp;.0/&#x27;</span>3gpp-cbsp             48049.0/tcp     <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv             48128/tcp       <span class="hljs-comment"># Image Systems Network Services</span>isnetserv             48128/udp       <span class="hljs-comment"># Image Systems Network Services</span>blp5                  48129/tcp       <span class="hljs-comment"># Bloomberg locator</span>blp5                  48129/udp       <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw         48556/tcp       <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw         48556/udp       <span class="hljs-comment"># com-bardac-dw</span>iqobject              48619/tcp       <span class="hljs-comment"># iqobject</span>iqobject              48619/udp       <span class="hljs-comment"># iqobject</span>matahari              49000/tcp       <span class="hljs-comment"># Matahari Broker</span></code></pre><p>IP 加单引号：</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &#x27;10.10.10.1 10.10.10.2 10.10.10.3&#x27; |sed -r &#x27;s/[^]+/&quot;&amp;&quot;/g&#x27;</span><span class="hljs-string">&quot;10.10.10.1&quot;</span> <span class="hljs-string">&quot;10.10.10.2&quot;</span> <span class="hljs-string">&quot;10.10.10.3&quot;</span></code></pre><p>4 ）对 1 - 4 行的 blp5 进行替换</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services | sed &#x27;1,4s/blp5/test/&#x27;</span>3gpp-cbsp           48049/tcp       <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv           48128/tcp       <span class="hljs-comment"># Image Systems Network Services</span>isnetserv           48128/udp       <span class="hljs-comment"># Image Systems Network Services</span><span class="hljs-built_in">test</span>                48129/tcp       <span class="hljs-comment"># Bloomberg locator</span>blp5                48129/udp       <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw       48556/tcp       <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw       48556/udp       <span class="hljs-comment"># com-bardac-dw</span>iqobject            48619/tcp       <span class="hljs-comment"># iqobject</span>iqobject            48619/udp       <span class="hljs-comment"># iqobject</span>matahari            49000/tcp       <span class="hljs-comment"># Matahari Broker</span></code></pre><p>5 ）对匹配行进行替换</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services | sed &#x27;/48129\/tcp/s/blp5/test/&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128 /tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span><span class="hljs-built_in">test</span> 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p>6 ）二次匹配替换</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;s/blp5/test/;s/3g/4g/&#x27;</span>4gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span><span class="hljs-built_in">test</span> 48129/tcp <span class="hljs-comment"># Bloomberg locator</span><span class="hljs-built_in">test</span> 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p>7 ）分组使用，在每个字符串后面添加 123</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -r &#x27;s/(.*) (.*)(#.*)/\ 1 \2test \3/&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-built_in">test</span> <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-built_in">test</span> <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Matahari Broker</span></code></pre><p>第一列是第一个小括号匹配，第二列第二个小括号匹配，第三列一样。将不变的字符串匹配分组，再通过 \ 数字按分组顺序反向引用。</p><p>8 ）将协议与端口号位置调换</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -r &#x27;s/(.*)(\&lt;[0-9]+\&gt;)\/(tcp|udp)(.*)/\ 1 \ 3 \/\ 2 \4/&#x27;</span>3gpp-cbsp tcp/48049 <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv tcp/48128 <span class="hljs-comment"># Image Systems Network Services</span>isnetserv udp/48128 <span class="hljs-comment"># Image Systems Network Services</span>blp5 tcp/48129 <span class="hljs-comment"># Bloomberg locator</span>blp5 udp/48129 <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw tcp/48556 <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw udp/48556 <span class="hljs-comment"># com-bardac-dw</span>iqobject tcp/48619 <span class="hljs-comment"># iqobject</span>iqobject udp/48619 <span class="hljs-comment"># iqobject</span>matahari tcp/49000 <span class="hljs-comment"># Matahari Broker</span></code></pre><p>9 ）位置调换</p><pre><code class="hljs bash">替换 x 字符为大写：<span class="hljs-comment"># echo &quot;abc cde xyz&quot; |sed -r &#x27;s/(.*)x/\1X/&#x27;</span>abc cde Xyz456 与 cde 调换：<span class="hljs-comment"># echo &quot;abc:cde;123:456&quot; |sed -r &#x27;s/([^:]+)(;.*:)([^:]+$)/\ 3 \ 2 \1/&#x27;</span>abc:456;123:cde</code></pre><p>10 ）注释匹配行后的多少行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 10 |sed &#x27;/5/,+3s/^/#/&#x27;</span>1234<span class="hljs-comment">#5</span><span class="hljs-comment">#6</span><span class="hljs-comment">#7</span><span class="hljs-comment">#8</span>910</code></pre><p>11 ）注释指定多行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -r &#x27;s/^3|^4/&amp;#/&#x27;</span>123<span class="hljs-comment">#</span>4<span class="hljs-comment">#</span>5<span class="hljs-comment"># seq 5 |sed -r &#x27;/^3|^4/s/^/#/&#x27;</span>12<span class="hljs-comment">#3</span><span class="hljs-comment">#4</span>5<span class="hljs-comment"># seq 5 |sed -r &#x27;s/^3|^4/#\0/&#x27;</span>12<span class="hljs-comment">#3</span><span class="hljs-comment">#4</span>5</code></pre><p>12 ）去除开头和结尾空格或制表符</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;1 2 3&quot; |sed &#x27;s/^[\t]*//;s/[ \t]*$//&#x27;</span>1 2 3</code></pre><h3 id="7-2-4-多重编辑（-e）"><a href="#7-2-4-多重编辑（-e）" class="headerlink" title="7.2.4 多重编辑（-e）"></a>7.2.4 多重编辑（-e）</h3><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -e &#x27;1,2d&#x27; -e &#x27;s/blp5/test/&#x27;</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span><span class="hljs-built_in">test</span> 48129/tcp <span class="hljs-comment"># Bloomberg locator</span><span class="hljs-built_in">test</span> 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p>也可以使用分号分隔：</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;1,2d;s/blp5/test/&#x27;</span></code></pre><h3 id="7-2-5-添加新内容（a、i-和-c）"><a href="#7-2-5-添加新内容（a、i-和-c）" class="headerlink" title="7.2.5 添加新内容（a、i 和 c）"></a>7.2.5 添加新内容（a、i 和 c）</h3><p>1 ）在 blp5 上一行添加 test</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/i \test&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span><span class="hljs-built_in">test</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span><span class="hljs-built_in">test</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p>2 ）在 blp5 下一行添加 test</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/a \test&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span><span class="hljs-built_in">test</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span><span class="hljs-built_in">test</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p>3 ）将 blp5 替换新行</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/c \test&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span><span class="hljs-built_in">test</span><span class="hljs-built_in">test</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p>4 ）在指定行下一行添加一行</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;2a \test&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span><span class="hljs-built_in">test</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p>5 ）在指定行前面和后面添加一行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed &#x27;3s/.*/txt\n&amp;/&#x27;</span>12txt345<span class="hljs-comment"># seq 5 |sed &#x27;3s/.*/&amp;\ntxt/&#x27;</span>123txt45</code></pre><h3 id="7-2-6-读取文件并追加到匹配行后（r）"><a href="#7-2-6-读取文件并追加到匹配行后（r）" class="headerlink" title="7.2.6 读取文件并追加到匹配行后（r）"></a>7.2.6 读取文件并追加到匹配行后（r）</h3><pre><code class="hljs bash"><span class="hljs-comment"># cat a.txt</span>123456<span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/r a.txt&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>123456blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>123456com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><h3 id="7-2-7-将匹配行写到文件（w）"><a href="#7-2-7-将匹配行写到文件（w）" class="headerlink" title="7.2.7 将匹配行写到文件（w）"></a>7.2.7 将匹配行写到文件（w）</h3><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/w b.txt&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 4855 6/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span><span class="hljs-comment"># cat b.txt</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span></code></pre><h3 id="7-2-8-读取下一行（n-和-N）"><a href="#7-2-8-读取下一行（n-和-N）" class="headerlink" title="7.2.8 读取下一行（n 和 N）"></a>7.2.8 读取下一行（n 和 N）</h3><ul><li>n 读取下一行到模式空间。</li><li>N 追加下一行内容到模式空间，并以换行符 \ n 分隔。</li></ul><p><strong>1 ）</strong> 打印匹配的下一行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;/3/&#123;n;p&#125;&#x27;</span>4</code></pre><p><strong>2 ）</strong> 打印偶数</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -n &#x27;n;p&#x27;</span>246</code></pre><p>sed 先读取第一行 1 ，执行 n 命令，获取下一行 2 ，此时模式空间是 2 ，执行 p 命令，打印模式空间。 现在模式空间是 2 ，sed 再读取 3 ，执行 n 命令，获取下一行 4 ，此时模式空间为 4 ，执行 p 命令，以此类推。</p><p><strong>3 ）</strong> 打印奇数</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;n;d&#x27;</span>135</code></pre><p>sed 先读取第一行 1 ，此时模式空间是 1 ，并打印模式空间 1 ，执行 n 命令，获取下一行 2 ，执行 d 命令，删除模式空间的 2 ，sed 再读取 3 ，此时模式空间是 3 ，并打印模式空间，再执行 n 命令，获取下一行 4 ，执行 d 命令，删除模式空间的 3 ，以此类推。</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -n &#x27;p;n&#x27;</span>135</code></pre><p><strong>4 ）</strong> 每三行执行一次 p 命令</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;n;n;p&#x27;</span>12334566</code></pre><p>sed 先读取第一行 1 ，并打印模式空间 1 ，执行 n 命令，获取下一行 2 ，并打印模式空间 2 ，再执行 n 命令，获取下一行 3 ，执行 p 命令，打印模式空间 3 。sed 读取下一行 3 ，并打印模式空间 3, 以此类推。</p><p><strong>5 ）</strong> 每三行替换一次</p><p>方法 1 ：</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;n;n;s/^/=/;s/$/=/&#x27;</span>12=3=45=6=</code></pre><p>我们只是把 p 命令改成了替换命令。</p><p>方法 2 ：</p><p>这次用到了地址匹配，来实现上面的效果：</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;3~3&#123;s/^/=/;s/$/=/&#125;&#x27;</span>12=3=45=6=</code></pre><p>当执行多个 sed 命令时，有时相互会产生影响，我们可以用大括号 {} 把他们括起来。</p><p><strong>6 ）</strong> 再看下 N 命令的功能</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;N;q&#x27;</span>12将两行合并一行：<span class="hljs-comment"># seq 6 |sed &#x27;N;s/\n//&#x27;</span>123456</code></pre><p>第一个命令：sed 读取第一行 1 ，N 命令读取下一行 2 ，并以 \ n2 追加，此时模式空间是 1 \n2，再执行 q 退出。</p><p>为了进一步说明 N 的功能，看第二个命令：执行 N 命令后，此时模式空间是 1 \n2，再执行把 \ n 替换为空，此时模式空间是 12 ，并打印。</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;N;p&#x27;</span>1234<span class="hljs-comment"># seq 6 |sed -n &#x27;N;p&#x27;</span>123456</code></pre><p>为什么第一个不打印 5 呢？</p><p>因为 N 命令是读取下一行追加到 sed 读取的当前行，当 N 读取下一行没有内容时，则退出，也不会执行 p 命令打印当前行。<br>当行数为偶数时，N 始终就能读到下一行，所以也会执行 p 命令。</p><p><strong>7 ）</strong> 打印奇数行数时的最后一行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;$!N;p&#x27;</span>12345</code></pre><p>加一个满足条件，当 sed 执行到最后一行时，用感叹号不去执行 N 命令，随后执行 p 命令。</p><h3 id="7-2-9-打印和删除模式空间第一行（P-和-D）"><a href="#7-2-9-打印和删除模式空间第一行（P-和-D）" class="headerlink" title="7.2.9 打印和删除模式空间第一行（P 和 D）"></a>7.2.9 打印和删除模式空间第一行（P 和 D）</h3><ul><li><p>P 打印模式空间的第一行。</p></li><li><p>D 删除模式空间的第一行。</p></li></ul><p><strong>1 ）</strong> 打印奇数</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -n &#x27;N;P&#x27;</span>135</code></pre><p><strong>2 ）</strong> 保留最后一行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;N;D&#x27;</span>6</code></pre><p>读取第一行 1 ，执行 N 命令读取下一行并追加到模式空间，此时模式空间是 1 \n2，执行 D 命令删除模式空间第一行 1 ，剩余 2 。<br>读取第二行，执行 N 命令，此时模式空间是 3 \n4，执行 D 命令删除模式空间第一行 3 ，剩余 4 。<br>以此类推，读取最后一行打印时，而 N 获取不到下一行则退出，不再执行 D，因此模式空间只剩余 6 就打印。</p><h3 id="7-2-10-保持空间操作（h-与-H、g-与-G-和-x）"><a href="#7-2-10-保持空间操作（h-与-H、g-与-G-和-x）" class="headerlink" title="7.2.10 保持空间操作（h 与 H、g 与 G 和 x）"></a>7.2.10 保持空间操作（h 与 H、g 与 G 和 x）</h3><ul><li>h 复制模式空间内容到保持空间（覆盖）。</li><li>H 复制模式空间内容追加到保持空间。</li><li>g 复制保持空间内容到模式空间（覆盖）。</li><li>G 复制保持空间内容追加到模式空间。</li><li>x 模式空间与保持空间内容互换</li></ul><p><strong>1 ）</strong> 将匹配的内容覆盖到另一个匹配</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -e &#x27;/3/&#123;h;d&#125;&#x27; -e &#x27;/5/g&#x27;</span>12436</code></pre><p>h 命令把匹配的 3 复制到保持空间，d 命令删除模式空间的 3 。后面命令再对模式空间匹配 5 ，并用 g 命令把保持空间 3 覆盖模式空间 5 。</p><p><strong>2 ）</strong> 将匹配的内容放到最后</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -e &#x27;/3/&#123;h;d&#125;&#x27; -e &#x27;$G&#x27;</span>124563</code></pre><p><strong>3 ）</strong> 交换模式空间和保持空间</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -e &#x27;/3/&#123;h;d&#125;&#x27; -e &#x27;/5/x&#x27; -e &#x27;$G&#x27;</span>124365</code></pre><p>看后面命令，在模式空间匹配 5 并将保持空间的 3 与 5 交换， 5 就变成了 3,。最后把保持空间的 5 追加到模式空间的。</p><p><strong>4 ）</strong> 倒叙输出</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed &#x27;1!G;h;$!d&#x27;</span>54321</code></pre><p>分析下：</p><p>1!G 第一行不执行把保持空间内容追加到模式空间，因为现在保持空间还没有数据。</p><p>h 将模式空间放到保持空间暂存。</p><p>$!d 最后一行不执行删除模式空间的内容。</p><p>读取第一行 1 时，跳过 G 命令，执行 h 命令将模式空间 1 复制到保持空间，执行 d 命令删除模式空间的 1 。</p><p>读取第二行 2 时，模式空间是 2 ，执行 G 命令，将保持空间 1 追加到模式空间，此时模式空间是 2 \n1，执行 h 命令将 2 \n1 覆盖到保持空间，d 删除模式空间。</p><p>读取第三行 3 时，模式空间是 3 ，执行 G 命令，将保持空间 2 \n1 追加到模式空间，此时模式空间是 3 \n2\n1，执行 h 命令将模式空间内容复制到保持空间，d 删除模式空间。</p><p>以此类推，读到第 5 行时，模式空间是 5 ，执行 G 命令，将保持空间的 4 \n3\n2\n1 追加模式空间，然后复制到模式空间， 5 \n4\n3\n2\n1，不执行 d，模式空间保留，输出。</p><p>由此可见，每次读取的行先放到模式空间，再复制到保持空间，d 命令删除模式空间内容，防止输出，再追加到模式空间，因为追加到模式空间，会追加到新读取的一行的后面，循环这样操作，就把所有行一行行追加到新读取行的后面，就形成了倒叙。</p><p><strong>5 ）</strong> 每行后面添加新空行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 10 |sed G</span>12345</code></pre><p><strong>6 ）</strong> 打印匹配行的上一行内容</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;/3/&#123;x;p&#125;;h&#x27;</span>2</code></pre><p>读取第一行 1 ，没有匹配到 3 ，不执行 {x;p}，执行 h 命令将模式空间内容 1 覆盖到保持空间。<br>读取第二行 2 ，没有匹配到 3 ，不执行 {x;p}，执行 h 命令将模式空间内容 2 覆盖到保持空间。<br>读取第三行 3 ，匹配到 3 ，执行 x 命令把模式空间 3 与保持空间 2 交换，再执行 p 打印模式空间 2.<br>以此类推。</p><p>7 ）打印匹配行到最后一行或下一行到最后一行</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;/3/,$p&#x27;</span>345<span class="hljs-comment"># seq 5 |sed -n &#x27;/3/,$&#123;h;x;p&#125;&#x27;</span>345<span class="hljs-comment"># seq 5 |sed -n &#x27;/3/&#123;:a;N;$!ba;p&#125;&#x27;</span>345<span class="hljs-comment"># seq 5 |sed -n &#x27;/3/&#123;n;:a;N;$!ba;p&#125;&#x27;</span>45</code></pre><p>匹配到 3 时，n 读取下一行 4 ，此时模式空间是 4 ，执行 N 命令读取下一行并追加到模式空间，此时模式空间是 4 \n5，标签循环完成后打印模式空间 4 \n5。</p><h3 id="7-2-11-标签（-、b-和-t）"><a href="#7-2-11-标签（-、b-和-t）" class="headerlink" title="7.2.11 标签（:、b 和 t）"></a>7.2.11 标签（:、b 和 t）</h3><p>标签可以控制流，实现分支判断。</p><ul><li>: lable name 定义标签</li><li>b lable 跳转到指定标签，如果没有标签则到脚本末尾</li><li>t lable 跳转到指定标签，前提是 s/// 命令执行成功</li></ul><p><strong>1 ）</strong> 将换行符替换成逗号</p><p>方法 1 ：</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;N;s/\n/,/&#x27;</span>1,23,45,6</code></pre><p>这种方式并不能满足我们的需求，每次 sed 读取到模式空间再打印是新行，替换 \ n 也只能对 N 命令追加后的 1 \n2 这样替换。</p><p>这时就可以用到标签了：</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;:a;N;s/\n/,/;b a&#x27;</span>1,2,3,4,5,6</code></pre><p>看看这里的标签使用，:a 是定义的标签名，b a 是跳转到 a 位置。<br>sed 读取第一行 1 ，N 命令读取下一行 2 ，此时模式空间是 1 \n2$，执行替换，此时模式空间是 1,2$，执行 b 命令再跳转到标签 a 位置继续执行 N 命令，读取下一行 3 追加到模式空间，此时模式空间是 1,2\n3$，再替换，以此类推，不断追加替换，直到最后一行 N 读不到下一行内容退出。</p><p>方法 2 ：</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;:a;N;$!b a;s/\n/,/g&#x27;</span>1,2,3,4,5,6</code></pre><p>先将每行读入到模式空间，最后再执行全局替换。$! 是如果是最后一行，则不执行 b a 跳转，最后执行全局替换。</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;:a;N;b a;s/\n/,/g&#x27;</span>123456</code></pre><p>可以看到，不加 $! 是没有替换，因为循环到 N 命令没有读到行就退出了，后面的替换也就没执行。</p><p><strong>2 ）</strong> 每三个数字加个一个逗号</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;123456789&quot; |sed -r &#x27;s/([0-9]+)([0-9]+&#123;3&#125;)/\1,\2/&#x27;</span>123456,789<span class="hljs-comment"># echo &quot;123456789&quot; |sed -r &#x27;:a;s/([0-9]+)([0-9]+&#123;3&#125;)/\1,\2/;t a&#x27;</span>123,456,789<span class="hljs-comment"># echo &quot;123456789&quot; |sed -r &#x27;:a;s/([0-9]+)([0-9]+&#123;2&#125;)/\1,\2/;t a&#x27;</span>1,23,45,67,89</code></pre><p>执行第一次时，替换最后一个，跳转后，再对 123456 匹配替换，直到匹配替换不成功，不执行 t 命令。</p><h3 id="7-2-12-忽略大小写匹配（I）"><a href="#7-2-12-忽略大小写匹配（I）" class="headerlink" title="7.2.12 忽略大小写匹配（I）"></a>7.2.12 忽略大小写匹配（I）</h3><pre><code class="hljs bash"><span class="hljs-comment"># echo -e &quot;a\nA\nb\nc&quot; |sed &#x27;s/a/1/Ig&#x27;</span>11bc</code></pre><h3 id="7-2-13-获取总行数（-）"><a href="#7-2-13-获取总行数（-）" class="headerlink" title="7.2.13 获取总行数（#）"></a>7.2.13 获取总行数（#）</h3><pre><code class="hljs bash"><span class="hljs-comment"># seq 10 |sed -n &#x27;$=&#x27;</span></code></pre><h2 id="7-3-awk"><a href="#7-3-awk" class="headerlink" title="7.3 awk"></a>7.3 awk</h2><p>awk 是一个处理文本的编程语言工具，能用简短的程序处理标准输入或文件、数据排序、计算以及生成报表等等。</p><p>在 Linux 系统下默认 awk 是 gawk，它是 awk 的 GNU 版本。可以通过命令查看应用的版本：<code>ls -l/bin/awk</code></p><p>基本的命令语法：awk option ‘pattern {action}’ file</p><p>其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。</p><p>花括号用于根据特定的模式对一系列指令进行分组。</p><p>awk 处理的工作方式与数据库类似，支持对记录和字段处理，这也是 grep 和 sed 不能实现的。</p><p>在 awk 中，缺省的情况下将文本文件中的一行视为一个记录，逐行放到内存中处理，而将一行中的某一部分作为记录中的一个字段。用 1,2,3… 数字的方式顺序的表示行（记录）中的不同字段。用 $ 后跟数字，引用对应的字段，以逗号分隔， 0 表示整个行。</p><p><img src="/img/linux_shell/linux_shell_6.jpg"></p><h3 id="7-3-1-选项"><a href="#7-3-1-选项" class="headerlink" title="7.3.1 选项"></a>7.3.1 选项</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>- f program-file</td><td>从文件中读取 awk 程序源文件</td></tr><tr><td>- F fs</td><td>指定 fs 为输入字段分隔符</td></tr><tr><td>- v var=value</td><td>变量赋值</td></tr><tr><td>- -posix</td><td>兼容 POSIX 正则表达式</td></tr><tr><td>- -dump-variables=[file]</td><td>把 awk 命令时的全局变量写入文件，<br > 默认文件是 awkvars.out</td></tr><tr><td>- -profile=[file]</td><td>格式化 awk 语句到文件，默认是 awkprof.out</td></tr></tbody></table><h3 id="7-3-2-模式"><a href="#7-3-2-模式" class="headerlink" title="7.3.2 模式"></a>7.3.2 模式</h3><p>常用模式有：</p><table><thead><tr><th>Pattern</th><th>Description</th></tr></thead><tbody><tr><td>BEGIN{ }</td><td>给程序赋予初始状态，先执行的工作</td></tr><tr><td>END{ }</td><td>程序结束之后执行的一些扫尾工作</td></tr><tr><td>/regular expression/</td><td>为每个输入记录匹配正则表达式</td></tr><tr><td>pattern &amp;&amp; pattern</td><td>逻辑 and，满足两个模式</td></tr><tr><td>pattern || pattern</td><td>逻辑 or，满足其中一个模式</td></tr><tr><td>! pattern</td><td>逻辑 not，不满足模式</td></tr><tr><td>pattern1, pattern2</td><td>范围模式，匹配所有模式 1 的记录，直到匹配到模式 2</td></tr></tbody></table><p>而动作呢，就是下面所讲的 print、流程控制、I/O 语句等。</p><p><strong>示例：</strong></p><p><strong>1 ）</strong> 从文件读取 awk 程序处理文件</p><pre><code class="hljs bash"><span class="hljs-comment"># vi test.awk</span>&#123;<span class="hljs-built_in">print</span> <span class="hljs-variable">$2</span>&#125;<span class="hljs-comment"># tail -n3 /etc/services |awk -f test.awk</span>48049/tcp48128/tcp49000/tcp</code></pre><p><strong>2 ）</strong> 指定分隔符，打印指定字段</p><pre><code class="hljs bash">打印第二字段，默认以空格分隔：<span class="hljs-comment"># tail -n3 /etc/services |awk &#x27;&#123;print $2&#125;&#x27;</span>48049/tcp48128/tcp48128/udp指定冒号为分隔符打印第一字段：<span class="hljs-comment"># awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; /etc/passwd</span>rootbindaemonadmlpsync......</code></pre><p>还可以指定多个分隔符，作为同一个分隔符处理：</p><pre><code class="hljs bash"><span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/#]&#x27; &#x27;&#123;print $3&#125;&#x27;</span>iqobjectiqobjectMatahari Broker<span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/#]&#x27; &#x27;&#123;print $1&#125;&#x27;</span>iqobject 48619iqobject 48619matahari 49000<span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/#]&#x27; &#x27;&#123;print $2&#125;&#x27;</span>tcpudptcp<span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/#]&#x27; &#x27;&#123;print $3&#125;&#x27;</span>iqobjectiqobjectMatahari Broker<span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/]+&#x27; &#x27;&#123;print $2&#125;&#x27;</span>486194861949000</code></pre><p>[] 元字符的意思是符号其中任意一个字符，也就是说每遇到一个 / 或 #时就分隔一个字段，当用多个分隔符时，就能更方面处理字段了。</p><p><strong>3 ）</strong> 变量赋值</p><pre><code class="hljs bash"><span class="hljs-comment"># awk -v a=123 &#x27;BEGIN&#123;print a&#125;&#x27;</span>123系统变量作为 awk 变量的值：<span class="hljs-comment"># a=123</span><span class="hljs-comment"># awk -v a=$a &#x27;BEGIN&#123;print a&#125;&#x27;</span>123或使用单引号<span class="hljs-comment"># awk &#x27;BEGIN&#123;print&#x27;$a&#x27;&#125;&#x27;</span>123</code></pre><p><strong>4 ）</strong> 输出 awk 全局变量到文件</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk --dump-variables &#x27;&#123;print $0&#125;&#x27;</span>12345<span class="hljs-comment"># cat awkvars.out</span>ARGC: number (1)ARGIND: number (0)ARGV: array, 1 elementsBINMODE: number (0)CONVFMT: string (<span class="hljs-string">&quot;%.6g&quot;</span>)ERRNO: number (0)FIELDWIDTHS: string (<span class="hljs-string">&quot;&quot;</span>)FILENAME: string (<span class="hljs-string">&quot;-&quot;</span>)FNR: number (5)FS: string (<span class="hljs-string">&quot; &quot;</span>)IGNORECASE: number (0)LINT: number (0)NF: number (1)NR: number (5)OFMT: string (<span class="hljs-string">&quot;%.6g&quot;</span>)OFS: string (<span class="hljs-string">&quot; &quot;</span>)ORS: string (<span class="hljs-string">&quot;\n&quot;</span>)RLENGTH: number (0)RS: string (<span class="hljs-string">&quot;\n&quot;</span>)RSTART: number (0)RT: string (<span class="hljs-string">&quot;\n&quot;</span>)SUBSEP: string (<span class="hljs-string">&quot;\034&quot;</span>)TEXTDOMAIN: string (<span class="hljs-string">&quot;messages&quot;</span>)</code></pre><p><strong>5 ）</strong>BEGIN 和 END</p><p>BEGIN 模式是在处理文件之前执行该操作，常用于修改内置变量、变量赋值和打印输出的页眉或标题。</p><p>例如：打印页眉</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;BEGIN&#123;print&quot;Service\t\tPort\t\t\tDescription\n===&quot;&#125;&#123;print$0&#125;&#x27;</span>Service Port Description===3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p>END 模式是在程序处理完才会执行。</p><p>例如：打印页尾</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;print $0&#125;END&#123;print&quot;===\nEND......&quot;&#125;&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span>===END......</code></pre><p><strong>6 ）</strong> 格式化输出 awk 命令到文件</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk --profile &#x27;BEGIN&#123;print&quot;Service\t\tPort\t\t\tDescription\n===&quot;&#125;&#123;print $0&#125;END&#123;print&quot;===\nEND......&quot;&#125;&#x27;</span>Service Port Description===nimgtw 48003/udp <span class="hljs-comment"># Nimbus Gateway</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service Protocol</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>===END......<span class="hljs-comment"># cat awkprof.out</span>  <span class="hljs-comment"># gawk profile, created Sat Jan 7 19:45:22 2017</span>  <span class="hljs-comment"># BEGIN block(s)</span>  BEGIN &#123;    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Service\t\tPort\t\t\tDescription\n===&quot;</span>  &#125;  <span class="hljs-comment"># Rule(s)</span>  &#123;    <span class="hljs-built_in">print</span> <span class="hljs-variable">$0</span>  &#125;  <span class="hljs-comment"># END block(s)</span>  END &#123;   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;===\nEND......&quot;</span>  &#125;</code></pre><p><strong>7 ）</strong>/re / 正则匹配</p><pre><code class="hljs bash">匹配包含 tcp 的行：<span class="hljs-comment"># tail /etc/services |awk &#x27;/tcp/&#123;print $0&#125;&#x27;</span>3gpp-cbsp 48049/tcp      <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp      <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp           <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp  <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp       <span class="hljs-comment"># iqobject</span>matahari 49000/tcp       <span class="hljs-comment"># Matahari Broker</span>匹配开头是 blp5 的行：<span class="hljs-comment"># tail /etc/services |awk &#x27;/^blp5/&#123;print $0&#125;&#x27;</span>blp5 48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp     <span class="hljs-comment"># Bloomberg locator</span>匹配第一个字段是 8 个字符的行：<span class="hljs-comment"># tail /etc/services |awk &#x27;/^[a-z0-9]&#123;8&#125; /&#123;print $0&#125;&#x27;</span>iqobject 48619/tcp   <span class="hljs-comment"># iqobject</span>iqobject 48619/udp   <span class="hljs-comment"># iqobject</span>matahari 49000/tcp   <span class="hljs-comment"># Matahari Broker</span>如果没有匹配到，请查看你的 awk 版本（awk --version）是不是 3 ，因为 4 才支持 &#123;&#125;</code></pre><p><strong>8 ）</strong> 逻辑 and、or 和 not</p><pre><code class="hljs bash">匹配记录中包含 blp5 和 tcp 的行：<span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/ &amp;&amp; /tcp/&#123;print $0&#125;&#x27;</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>匹配记录中包含 blp5 或 tcp 的行：<span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/ || /tcp/&#123;print $0&#125;&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span>不匹配开头是 <span class="hljs-comment">#和空行：</span><span class="hljs-comment"># awk &#x27;! /^#/ &amp;&amp;! /^$/&#123;print $0&#125;&#x27; /etc/httpd/conf/httpd.conf</span>或<span class="hljs-comment"># awk &#x27;! /^#|^$/&#x27; /etc/httpd/conf/httpd.conf</span>或<span class="hljs-comment"># awk &#x27;/^[^#]|&quot;^$&quot;/&#x27; /etc/httpd/conf/httpd.conf</span></code></pre><p>9 ）匹配范围</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;/^blp5/,/^com/&#x27;</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span></code></pre><p>对匹配范围后记录再次处理，例如匹配关键字下一行到最后一行：</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;/3/,/^$/&#123;printf /3/?&quot;&quot;:$0&quot;\n&quot;&#125;&#x27;</span>45另一种判断真假的方式实现：<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;t=1;next&#125;t&#x27;</span>451 和 2 都不匹配 3 ，不执行后面 &#123;&#125;，执行 t，t 变量还没赋值，为空，空在 awk 中就为假，就不打印当前行。匹配到 3 ，执行 t= 1 ，next 跳出，不执行 t。 4 也不匹配 3 ，执行 t，t 的值上次赋值的 1 ，为真，打印当前行，以此类推。（非 0 的数字都为真，所以 t 可以写任意非 0 数字）如果想打印匹配行都最后一行，就可以这样了：<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;t=1&#125;t&#x27;</span>345</code></pre><h3 id="7-3-3-内置变量"><a href="#7-3-3-内置变量" class="headerlink" title="7.3.3 内置变量"></a>7.3.3 内置变量</h3><table><thead><tr><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>FS</td><td>输入字段分隔符，默认是空格或制表符</td></tr><tr><td>OFS</td><td>输出字段分隔符，默认是空格</td></tr><tr><td>RS</td><td>输入记录分隔符，默认是换行符 \ n</td></tr><tr><td>ORS</td><td>输出记录分隔符，默认是换行符 \ n</td></tr><tr><td>NF</td><td>统计当前记录中字段个数</td></tr><tr><td>NR</td><td>统计记录编号，每处理一行记录，编号就会 + 1</td></tr><tr><td>FNR</td><td>统计记录编号，每处理一行记录，编号也会 + 1，与 NR 不同的是，处理第二个 <br> 文件时，编号会重新计数。</td></tr><tr><td>ARGC</td><td>命令行参数数量</td></tr><tr><td>ARGV</td><td>命令行参数数组序列数组，下标从 0 开始，ARGV[0] 是 awk</td></tr><tr><td>ARGIND</td><td>当前正在处理的文件索引值。第一个文件是 1 ，第二个文件是 2 ，以此类推</td></tr><tr><td>ENVIRON</td><td>当前系统的环境变量</td></tr><tr><td>FILENAME</td><td>输出当前处理的文件名</td></tr><tr><td>IGNORECASE</td><td>忽略大小写</td></tr><tr><td>SUBSEP</td><td>数组中下标的分隔符，默认为 “\034”</td></tr></tbody></table><p><strong>示例：</strong></p><p><strong>1 ）</strong> FS 和 OFS</p><p>在程序开始前重新赋值 FS 变量，改变默认分隔符为冒号，与 - F 一样。</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1,$2&#125;&#x27; /etc/passwd |head -n5</span>root xbin xdaemon xadm xlp x也可以使用 - v 来重新赋值这个变量：<span class="hljs-comment"># awk -vFS=&#x27;:&#x27; &#x27;&#123;print $1,$2&#125;&#x27; /etc/passwd |head -n5 # 中间逗号被换成了 OFS 的默</span>认值root xbin xdaemon xadm xlp x由于 OFS 默认以空格分隔，反向引用多个字段分隔的也是空格，如果想指定输出分隔符这样：<span class="hljs-comment"># awk &#x27;BEGIN&#123;FS=&quot;:&quot;;OFS=&quot;:&quot;&#125;&#123;print $1,$2&#125;&#x27; /etc/passwd |head -n5</span>root:xbin:xdaemon:xadm:xlp:x也可以通过字符串拼接实现分隔：<span class="hljs-comment"># awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1&quot;#&quot;$2&#125;&#x27; /etc/passwd |head -n5</span>root<span class="hljs-comment">#x</span>bin<span class="hljs-comment">#x</span>daemon<span class="hljs-comment">#x</span>adm<span class="hljs-comment">#x</span>lp<span class="hljs-comment">#x</span></code></pre><p><strong>2 ）</strong> RS 和 ORS</p><p>RS 默认是 \n 分隔每行，如果想指定以某个字符作为分隔符来处理记录：</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;www.baidu.com/user/test.html&quot; |awk &#x27;BEGIN&#123;RS=&quot;/&quot;&#125;&#123;print $0&#125;&#x27;</span>www.baidu.comusertest.htmlRS 也支持正则，简单演示下：<span class="hljs-comment"># seq -f &quot;str%02g&quot; 10 |sed &#x27;n;n;a\-----&#x27; |awk &#x27;BEGIN&#123;RS=&quot;-+&quot;&#125;&#123;print $1&#125;&#x27;</span>str01str04str07str10将输出的换行符替换为 + 号：<span class="hljs-comment"># seq 10 |awk &#x27;BEGIN&#123;ORS=&quot;+&quot;&#125;&#123;print $0&#125;&#x27;</span>1+2+3+4+5+6+7+8+9+10+替换某个字符：<span class="hljs-comment"># tail -n2 /etc/services |awk &#x27;BEGIN&#123;RS=&quot;/&quot;;ORS=&quot;#&quot;&#125;&#123;print $0&#125;&#x27;</span>iqobject 48619<span class="hljs-comment">#udp # iqobject</span>matahari 49000<span class="hljs-comment">#tcp # Matahari Broker</span></code></pre><p><strong>3 ）</strong>NF</p><p>NF 是字段个数。</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;print NF&#125;&#x27;</span>6打印最后一个字段：<span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;print $NF&#125;&#x27;</span>f打印倒数第二个字段：<span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;print $(NF-1)&#125;&#x27;</span>e排除最后两个字段：<span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;$NF=&quot;&quot;;$(NF-1)=&quot;&quot;;print $0&#125;&#x27;</span>a b c d排除第一个字段：<span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;$1=&quot;&quot;;print $0&#125;&#x27;</span>b c d e f</code></pre><p><strong>4 ）</strong> NR 和 FNR</p><p>NR 统计记录编号，每处理一行记录，编号就会 +1，FNR 不同的是在统计第二个文件时会重新计数。</p><pre><code class="hljs bash">打印行数：<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;&#123;print NR,$0&#125;&#x27;</span>1 com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>2 com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>3 iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>4 iqobject 48619/udp <span class="hljs-comment"># iqobject</span>5 matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span>打印总行数：<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;END&#123;print NR&#125;&#x27;</span>5打印第三行：<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;NR==3&#x27;</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>打印第三行第二个字段：<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;NR==3&#123;print $2&#125;&#x27;</span>48619/tcp打印前三行：<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;NR&lt;=3&#123;print NR,$0&#125;&#x27;</span>1 com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>2 com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>3 iqobject 48619/tcp <span class="hljs-comment"># iqobject</span></code></pre><p>看下 NR 和 FNR 的区别：</p><pre><code class="hljs bash"><span class="hljs-comment"># cat a</span>abc<span class="hljs-comment"># cat b</span>cde<span class="hljs-comment"># awk &#x27;&#123;print NR,FNR,$0&#125;&#x27; a b</span>1 1 a2 2 b3 3 c4 1 c5 2 d6 3 e</code></pre><p>可以看出 NR 每处理一行就会 +1，而 FNR 在处理第二个文件时，编号重新计数。同时也知道 awk 处理两个文件时，是合并到一起处理。</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;FNR==NR&#123;print $0&quot;1&quot;&#125;FNR!=NR&#123;print $0&quot;2&quot;&#125;&#x27; a b</span>a1b1c1c2d2e2</code></pre><p>当 FNR==NR 时，说明在处理第一个文件内容，不等于时说明在处理第二个文件内容。<br>一般 FNR 在处理多个文件时会用到，下面会讲解。</p><p><strong>5 ）</strong>ARGC 和 ARGV</p><p>ARGC 是命令行参数数量</p><p>ARGV 是将命令行参数存到数组，元素由 ARGC 指定，数组下标从 0 开始</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;print ARGC&#125;&#x27; 1 2 3</span>4<span class="hljs-comment"># awk &#x27;BEGIN&#123;print ARGV[0]&#125;&#x27;</span>awk<span class="hljs-comment"># awk &#x27;BEGIN&#123;print ARGV[1]&#125;&#x27; 1 2</span>1<span class="hljs-comment"># awk &#x27;BEGIN&#123;print ARGV[2]&#125;&#x27; 1 2</span>2</code></pre><p><strong>6 ）</strong>ARGIND</p><p>ARGIND 是当前正在处理的文件索引值，第一个文件是 1 ，第二个文件是 2 ，以此类推，从而可以通过这种方式判断正在处理哪个文件。</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;&#123;print ARGIND,$0&#125;&#x27; a b</span>1 a1 b1 c2 c2 d2 e<span class="hljs-comment"># awk &#x27;ARGIND==1&#123;print&quot;a-&gt;&quot;$0&#125;ARGIND==2&#123;print&quot;b-&gt;&quot;$0&#125;&#x27; a b</span>a-&gt;aa-&gt;ba-&gt;cb-&gt;cb-&gt;db-&gt;e</code></pre><p><strong>7 ）</strong>ENVIRON</p><p>ENVIRON 调用系统变量。</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;print ENVIRON[&quot;HOME&quot;]&#125;&#x27;</span>/root如果是设置的环境变量，还需要用 <span class="hljs-built_in">export</span> 导入到系统变量才可以调用：<span class="hljs-comment"># awk &#x27;BEGIN&#123;print ENVIRON[&quot;a&quot;]&#125;&#x27;</span><span class="hljs-comment"># export a</span><span class="hljs-comment"># awk &#x27;BEGIN&#123;print ENVIRON[&quot;a&quot;]&#125;&#x27;</span>123</code></pre><p><strong>8 ）</strong>FILENAME</p><p>FILENAME 是当前处理文件的文件名。</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;FNR==NR&#123;print FILENAME&quot;-&gt;&quot;$0&#125;FNR!=NR&#123;print FILENAME&quot;-&gt;&quot;$0&#125;&#x27; a b</span>a-&gt;aa-&gt;ba-&gt;cb-&gt;cb-&gt;db-&gt;e</code></pre><p>9 ）忽略大小写</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;A a b c&quot; |xargs -n1 |awk &#x27;BEGIN&#123;IGNORECASE=1&#125;/a/&#x27;</span>Aa</code></pre><p>等于 1 代表忽略大小写。</p><h3 id="7-3-4-操作符"><a href="#7-3-4-操作符" class="headerlink" title="7.3.4 操作符"></a>7.3.4 操作符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>（….）</td><td>分组</td></tr><tr><td>$</td><td>字段引用</td></tr><tr><td>++ –</td><td>递增和递减</td></tr><tr><td>+ -!</td><td>加号，减号，和逻辑否定</td></tr><tr><td>* / %</td><td>乘，除和取余</td></tr><tr><td>+ -</td><td>加法，减法</td></tr><tr><td>| |&amp;</td><td>管道，用于 getline，print 和 printf</td></tr><tr><td>&lt;&gt; &lt;=&gt;= != ==</td><td>关系运算符</td></tr><tr><td>~ !~</td><td>正则表达式匹配，否定正则表达式匹配</td></tr><tr><td>in</td><td>数组成员</td></tr><tr><td>&amp;&amp; ||</td><td>逻辑 and，逻辑 or</td></tr><tr><td>?:</td><td>简写条件表达式：<br>expr1? expr2 : expr3<br > 第一个表达式为真，执行 expr2，否则执行 expr3</td></tr><tr><td>= += -= *= /= %= ^=</td><td>变量赋值运算符</td></tr></tbody></table><p><strong>须知：</strong></p><p><font color=red> 在 awk 中，有 3 种情况表达式为假：数字是 0 ，空字符串和未定义的值。</font><br><font color=red> 数值运算，未定义变量初始值为 0 。字符运算，未定义变量初始值为空。</font></p><p><strong>举例测试：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;n=0;if(n)print&quot;true&quot;;else print&quot;false&quot;&#125;&#x27;</span><span class="hljs-literal">false</span><span class="hljs-comment"># awk &#x27;BEGIN&#123;s=&quot;&quot;;if(s)print &quot;true&quot;;else print &quot;false&quot;&#125;&#x27;</span><span class="hljs-literal">false</span><span class="hljs-comment"># awk &#x27;BEGIN&#123;if(s)print&quot;true&quot;;else print&quot;false&quot;&#125;&#x27;</span><span class="hljs-literal">false</span></code></pre><p><strong>示例：</strong></p><p><strong>1 ）</strong> 截取整数</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;123abc abc123 123abc123&quot; |xargs -n1 | awk &#x27;&#123;print +$0&#125;&#x27;</span>1230123<span class="hljs-comment"># echo &quot;123abc abc123 123abc123&quot; |xargs -n1 | awk &#x27;&#123;print -$0&#125;&#x27;</span>-1230-123</code></pre><p><strong>2 ）</strong> 感叹号</p><pre><code class="hljs bash">打印奇数行：<span class="hljs-comment"># seq 6 |awk &#x27;i=!i&#x27;</span>135打印偶数行：<span class="hljs-comment"># seq 6 |awk &#x27;!(i=!i)&#x27;</span>246</code></pre><p>读取第一行：i 是未定义变量，也就是 i=!0，! 取反意思。感叹号右边是个布尔值， 0 或空字符串为假，非 0 或非空字符串为真，!0 就是真，因此 i=1，条件为真打印当前记录。<br>没有 print 为什么会打印呢？因为模式后面没有动作，默认会打印整条记录。<br>读取第二行：因为上次 i 的值由 0 变成了 1 ，此时就是 i=!1，条件为假不打印。<br>读取第三行：上次条件又为假，i 恢复初始值 0 ，取反，继续打印。以此类推…<br>可以看出，运算时并没有判断行内容，而是利用布尔值真假判断输出当前行。</p><p><strong>3 ）</strong> 不匹配某行</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;!/blp5/&#123;print $0&#125;&#x27;</span>3gpp-cbsp       48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv       48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>isnetserv       48128/udp <span class="hljs-comment"># Image Systems Network Services</span>com-bardac-dw   48556/tcp <span class="hljs-comment"># com-bardac-dw</span>com-bardac-dw   48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject        48619/tcp <span class="hljs-comment"># iqobject</span>iqobject        48619/udp <span class="hljs-comment"># iqobject</span>matahari        49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p><strong>4 ）</strong> 乘法和除法</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;&#123;print $0*2&#125;&#x27;</span>246810<span class="hljs-comment"># seq 5 |awk &#x27;&#123;print $0%2&#125;&#x27;</span>10101打印偶数行：<span class="hljs-comment"># seq 5 |awk &#x27;$0%2==0&#123;print $0&#125;&#x27;</span>24打印奇数行：<span class="hljs-comment"># seq 5 |awk &#x27;$0%2!=0&#123;print $0&#125;&#x27;</span>135</code></pre><p><strong>5 ）</strong> 管道符使用</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |shuf |awk &#x27;&#123;print $0|&quot;sort&quot;&#125;&#x27;</span>12345</code></pre><p><strong>6 ）</strong> 正则表达式匹配</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;$0~3&#123;print $0&#125;&#x27;</span>3<span class="hljs-comment"># seq 5 |awk &#x27;$0!~3&#123;print $0&#125;&#x27;</span>1245<span class="hljs-comment"># seq 5 |awk &#x27;$0~/[34]/&#123;print $0&#125;&#x27;</span>34<span class="hljs-comment"># seq 5 |awk &#x27;$0!~/[34]/&#123;print $0&#125;&#x27;</span>125<span class="hljs-comment"># seq 5 |awk &#x27;$0~/[^34]/&#123;print $0&#125;&#x27;</span>125</code></pre><p><strong>7 ）</strong> 判断数组成员</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;a[&quot;a&quot;]=123&#125;END&#123;if(&quot;a&quot;in a)print&quot;yes&quot;&#125;&#x27; &lt;/dev/null</span>yes</code></pre><p><strong>8 ）</strong> 三目运算符</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;print 1==1?&quot;yes&quot;:&quot;no&quot;&#125;&#x27; # 三目运算作为一个表达式，里面不允许写 print</span>yes<span class="hljs-comment"># seq 3 |awk &#x27;&#123;print $0==2?&quot;yes&quot;:&quot;no&quot;&#125;&#x27;</span>noyesno替换换行符为逗号：<span class="hljs-comment"># seq 5 |awk &#x27;&#123;print n=(n?n&quot;,&quot;$0:$0)&#125;&#x27;</span>11,21,2,31,2,3,41,2,3,4,5<span class="hljs-comment"># seq 5 |awk &#x27;&#123;n=(n?n&quot;,&quot;$0:$0)&#125;END&#123;print n&#125;&#x27;</span>1,2,3,4,5说明：读取第一行时，n 没有变量，为假输出 <span class="hljs-variable">$0</span> 也就是 1 ，并赋值变量 n，读取第二行时，n 是 1 为真，输出 1,2 以此类推，后面会一直为真。每三行后面添加新一行：<span class="hljs-comment"># seq 10 |awk &#x27;&#123;print NR%3?$0:$0&quot;\ntxt&quot;&#125;&#x27;</span>123txt456txt789txt10在两行合并一行：<span class="hljs-comment"># seq 6 |awk &#x27;&#123;printf NR%2!=0?$0&quot; &quot;:$0&quot; \n&quot;&#125;&#x27;</span>1 23 45 6<span class="hljs-comment"># seq 6 |awk &#x27;ORS=NR%2?&quot; &quot;:&quot;\n&quot;&#x27;</span>1 23 45 6<span class="hljs-comment"># seq 6 |awk &#x27;&#123;if(NR%2)ORS=&quot; &quot;;else ORS=&quot;\n&quot;;print&#125;&#x27;</span></code></pre><p><strong>9 ）</strong> 变量赋值</p><pre><code class="hljs bash">字段求和：<span class="hljs-comment"># seq 5 |awk &#x27;&#123;sum+=1&#125;END&#123;print sum&#125;&#x27;</span>5<span class="hljs-comment"># seq 5 |awk &#x27;&#123;sum+=$0&#125;END&#123;print sum&#125;&#x27;</span>15</code></pre><h3 id="7-3-5-流程控制"><a href="#7-3-5-流程控制" class="headerlink" title="7.3.5 流程控制"></a>7.3.5 流程控制</h3><p><strong>1 ）if 语句</strong></p><p>格式：if (condition) statement [ else statement ]</p><pre><code class="hljs bash">单分支：<span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0==3)print $0&#125;&#x27;</span>3也支持正则匹配判断，一般在写复杂语句时使用：<span class="hljs-comment"># echo &quot;123abc#456cde 789aaa#aaabbb&quot; |xargs - n1 |awk - F# &#x27;&#123;if($2~/[0-9]/)print $2&#125;&#x27;</span>456cde<span class="hljs-comment"># echo &quot;123abc#456cde 789aaa#aaabbb&quot; |xargs - n1 |awk - F# &#x27;&#123;if($2!~/[0-9]/)print $2&#125;&#x27;</span>aaabbb或<span class="hljs-comment"># echo &quot;123abc#456cde 789 aaa#aaabbb&quot; |xargs - n1 |awk - F# &#x27;$2!~/[0-9]/&#123;print $2&#125;&#x27;</span>aaabbb双分支：<span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0==3)print $0;else print&quot;no&quot;&#125;&#x27;</span>nono3nono多分支：<span class="hljs-comment"># cat file</span>1 2 34 5 67 8 9<span class="hljs-comment"># awk &#x27;&#123;if($1==4)&#123;print&quot;1&quot;&#125; else if($2==5)&#123;print&quot;2&quot;&#125; else if($3==6)&#123;print&quot;3&quot;&#125; else &#123;print&quot;no&quot;&#125;&#125;&#x27; file</span>no1no</code></pre><p><strong>2 ）while 语句</strong></p><p>格式：while (condition) statement</p><pre><code class="hljs bash">遍历打印所有字段：<span class="hljs-comment"># awk &#x27;&#123;i=1;while(i&lt;=NF)&#123;print $i;i++&#125;&#125;&#x27; file</span>123456789awk 是按行处理的，每次读取一行，并遍历打印每个字段。</code></pre><p><strong>3 ）for 语句 C 语言风格</strong></p><p>格式：for (expr1; expr2; expr3) statement</p><pre><code class="hljs bash">遍历打印所有字段：<span class="hljs-comment"># cat file</span>1 2 34 5 67 8 9<span class="hljs-comment"># awk &#x27;&#123;for(i=1;i&lt;=NF;i++)print $i&#125;&#x27; file</span>123456789倒叙打印文本：<span class="hljs-comment"># awk &#x27;&#123;for(i=NF;i&gt;=1;i--)print $i&#125;&#x27; file</span>321654987都换行了，这并不是我们要的结果。怎么改进呢？<span class="hljs-comment"># awk &#x27;&#123;for(i=NF;i&gt;=1;i--)&#123;printf $i&quot; &quot;&#125;;print&quot;&quot;&#125;&#x27; file # print 本身就会新打印一行</span>3 2 16 5 49 8 7或<span class="hljs-comment"># awk &#x27;&#123;for(i=NF;i&gt;=1;i--)if(i==1)printf $i&quot;\n&quot;;else printf $i&quot; &quot;&#125;&#x27; file</span>3 2 16 5 49 8 7在这种情况下，是不是就排除第一行和倒数第一行呢？我们正序打印看下排除第一行：<span class="hljs-comment"># awk &#x27;&#123;for(i=2;i&lt;=NF;i++)&#123;printf $i&quot; &quot;&#125;;print&quot;&quot;&#125;&#x27; file</span>2 35 68 9排除第二行：<span class="hljs-comment"># awk &#x27;&#123;for(i=1;i&lt;=NF-1;i++)&#123;printf $i&quot; &quot;&#125;;print&quot;&quot;&#125;&#x27; file</span>1 24 57 8IP 加单引号：<span class="hljs-comment"># echo &#x27;10.10.10.1 10.10.10.2 10.10.10.3&#x27; |awk &#x27;&#123;for(i=1;i&lt;=NF;i++)printf&quot;\047&quot;$i&quot;\047&quot;&#125;&#x27;10.10.10.1&#x27;&#x27;10.10.10.2&#x27; &#x27;10.10.10.3&#x27;</span>\047 是 ASCII 码，可以通过 showkey -a 命令查看。</code></pre><p><strong>4 ）for 语句遍历数组</strong></p><p>格式：for (var in array) statement</p><pre><code class="hljs bash"><span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[NR]=$0&#125;END&#123;for(v in a)print v,a[v]&#125;&#x27;</span>4 str45 str51 str12 str23 str3</code></pre><p><strong>5 ）break 和 continue 语句</strong></p><p>break 跳过所有循环，continue 跳过当前循环。</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;for(i=1;i&lt;=5;i++)&#123;if(i==3)&#123;break&#125;;print i&#125;&#125;&#x27;</span>12<span class="hljs-comment"># awk &#x27;BEGIN&#123;for(i=1;i&lt;=5;i++)&#123;if(i==3)&#123;continue&#125;;print i&#125;&#125;&#x27;</span>1245</code></pre><p><strong>6 ）删除数组和元素</strong></p><p>格式：</p><p>delete array[index] 删除数组元素</p><p>delete array 删除数组</p><pre><code class="hljs bash"><span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[NR]=$0&#125;END&#123;delete a;for(v in a)print v,a[v]&#125;&#x27;</span>空的...<span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[NR]=$0&#125;END&#123;delete a[3];for(v in a)print v,a[v]&#125;&#x27;</span>4 str45 str51 str12 str2</code></pre><p><strong>7 ）exit 语句</strong></p><p>格式：exit [expression]</p><p>exit 退出程序，与 shell 的 exit 一样。[expr] 是 0 - 255 之间的数字。</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0~/3/)exit (123)&#125;&#x27;</span><span class="hljs-comment"># echo $?</span>123</code></pre><h3 id="7-3-6-数组"><a href="#7-3-6-数组" class="headerlink" title="7.3.6 数组"></a>7.3.6 数组</h3><p>数组：存储一系列相同类型的元素，键 / 值方式存储，通过下标（键）来访问值。</p><p>awk 中数组称为关联数组，不仅可以使用数字作为下标，还可以使用字符串作为下标。<br>数组元素的键和值存储在 awk 程序内部的一个表中，该表采用散列算法，因此数组元素是随机排序。</p><p>数组格式：array[index]=value</p><p><strong>1 ）自定义数组</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;a[0]=&quot;test&quot;;print a[0]&#125;&#x27;</span><span class="hljs-built_in">test</span></code></pre><p><strong>2 ）通过 NR 设置记录下标，下标从 1 开始</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># tail -n3 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;print a[1]&#125;&#x27;</span>systemd-network<span class="hljs-comment"># tail -n3 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;print a[2]&#125;&#x27;</span>zabbix<span class="hljs-comment"># tail -n3 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;print a[3]&#125;&#x27;</span>user</code></pre><p><strong>3 ）通过 for 循环遍历数组</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># tail -n5 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>zabbix 4user 5admin 1systemd-bus-proxy 2systemd-network 3<span class="hljs-comment"># tail -n5 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;for(i=1;i&lt;=NR;i++)print a[i],i&#125;&#x27;</span>admin 1systemd-bus-proxy 2systemd-network 3zabbix 4user 5</code></pre><p>上面打印的 i 是数组的下标。<br>第一种 for 循环的结果是乱序的，刚说过，数组是无序存储。<br>第二种 for 循环通过下标获取的情况是排序正常。<br>所以当下标是数字序列时，还是用 for(expr1;expr2;expr3) 循环表达式比较好，保持顺序不变。</p><p><strong>4 ）通过 ++ 方式作为下标</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># tail -n5 /etc/passwd |awk -F: &#x27;&#123;a[x++]=$1&#125;END&#123;for(i=0;i&lt;=x-1;i++)print a[i],i&#125;&#x27;</span>admin 0systemd-bus-proxy 1systemd-network 2zabbix 3user 4</code></pre><p>x 被 awk 初始化值是 0 ，没循环一次 + 1</p><p><strong>5 ）使用字段作为下标</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># tail -n5 /etc/passwd |awk -F: &#x27;&#123;a[$1]=$7&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>/sbin/nologin admin/bin/bash user/sbin/nologin systemd-network/sbin/nologin systemd-bus-proxy/sbin/nologin zabbix</code></pre><p><strong>6 ）统计相同字段出现次数</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>2 com-bardac-dw1 3gpp-cbsp2 iqobject1 matahari2 isnetserv2 blp5<span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;a[$1]+=1&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>2 com-bardac-dw1 3gpp-cbsp2 iqobject1 matahari2 isnetserv2 blp5<span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/&#123;a[$1]++&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>2 blp5</code></pre><p>第一个字段作为下标，值被 ++ 初始化是 0 ，每次遇到下标（第一个字段）一样时，对应的值就会被 + 1，因此实现了统计出现次数。<br>想要实现去重的的话就简单了，只要打印下标即可。</p><p><strong>7 ）统计 TCP 连接状态</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># netstat -antp |awk &#x27;/^tcp/&#123;a[$6]++&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>9 LISTEN6 ESTABLISHED6 TIME_WAIT</code></pre><p><strong>8 ）只打印出现次数大于等于 2 的</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a) if(a[v]&gt;=2)&#123;print a[v],v&#125;&#125;&#x27;</span>2 com-bardac-dw2 iqobject2 isnetserv2 blp5</code></pre><p><strong>9 ）去重</strong></p><pre><code class="hljs bash">只打印重复的行：<span class="hljs-comment"># tail /etc/services |awk &#x27;a[$1]++&#x27;</span>isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/udp <span class="hljs-comment"># iqobject</span>不打印重复的行：<span class="hljs-comment"># tail /etc/services |awk &#x27;!a[$1]++&#x27;</span>3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre><p>先明白一个情况，当值是 0 是为假，非 0 整数为真，知道这点就不难理解了。<br>只打印重复的行说明：当处理第一条记录时，执行了 ++，初始值是 0 为假，就不打印，如果再遇到相同的记录，值就会 + 1，不为 0 ，则打印。<br>不打印重复的行说明：当处理第一条记录时，执行了 ++，初始值是 0 为假，感叹号取反为真，打印，如果再遇到相同的记录，值就会 + 1，不为 0 为真，取反为假就不打印。</p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;if(a[$1]++)print $1&#125;&#x27;</span>isnetservblp5com-bardac-dwiqobject使用三目运算：<span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;print a[$1]++?$1:&quot;no&quot;&#125;&#x27;</span>nonoisnetservnoblp5nocom-bardac-dwnoiqobjectno<span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;if(!a[$1]++)print $1&#125;&#x27;</span>3gpp-cbspisnetservblp5com-bardac-dwiqobjectmatahari</code></pre><p><strong>10 ）统计每个相同字段的某字段总数：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk -F&#x27;[/]+&#x27; &#x27;&#123;a[$1]+=$2&#125;END&#123;for(v in a)print v, a[v]&#125;&#x27;</span>com-bardac-dw 971123gpp-cbsp 48049iqobject 97238matahari 49000isnetserv 96256blp5 96258</code></pre><p><strong>11 ）多维数组</strong></p><p>awk 的多维数组，实际上 awk 并不支持多维数组，而是逻辑上模拟二维数组的访问方式，比如<br>a[a,b]=1，使用 SUBSEP（默认 \ 034 ）作为分隔下标字段，存储后是这样 a\034b。</p><p>示例：</p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;a[&quot;x&quot;,&quot;y&quot;]=123;for(v in a) print v,a[v]&#125;&#x27;</span>xy 123我们可以重新复制 SUBSEP 变量，改变下标默认分隔符：<span class="hljs-comment"># awk &#x27;BEGIN&#123;SUBSEP=&quot;:&quot;;a[&quot;x&quot;,&quot;y&quot;]=123;for(v in a) print v,a[v]&#125;&#x27;</span>x:y 123根据指定的字段统计出现次数：<span class="hljs-comment"># cat file</span>A 192.168.1.1 HTTPB 192.168.1.2 HTTPB 192.168.1.2 MYSQLC 192.168.1.1 MYSQLC 192.168.1.1 MQD 192.168.1.4 NGINX<span class="hljs-comment"># awk &#x27;BEGIN&#123;SUBSEP=&quot;-&quot;&#125;&#123;a[$1,$2]++&#125;END&#123;for(v in a)print a[v],v&#125;&#x27; file</span>1 D-192.168.1.41 A-192.168.1.12 C-192.168.1.12 B-192.168.1.2</code></pre><h3 id="7-3-7-内置函数"><a href="#7-3-7-内置函数" class="headerlink" title="7.3.7 内置函数"></a>7.3.7 内置函数</h3><p>| 函数 | 描述 |</p><p>|int(expr) | 截断为整数 |<br>|sqrt(expr) | 平方根 |<br>|rand() | 返回一个随机数 N， 0 和 1 范围，0 &lt; N &lt; 1|<br>|srand([expr]) | 使用 expr 生成随机数，如果不指定，默认使用当前时间为种子，如 &lt; br &gt; 果前面有种子则使用生成随机数 |<br>|asort(a, b) | 对数组 a 的值进行排序，把排序后的值存到新的数组 b 中，新排序 &lt; br &gt; 的数组下标从 1 开始 |<br>|asorti(a,b) | 对数组 a 的下标进行排序，同上 |<br>|sub(r, s [, t]) | 对输入的记录用 s 替换 r 正则匹配，t 可选针对某字段替换，但只替 &lt; br &gt; 换第一个字符串 |<br>|gsub(r, s [, t]) | 对输入的记录用 s 替换 r 正则匹配，t 可选针对某字段替换，否则替 &lt; br &gt; 换所有字符串 |<br>|gensub(r, s, h [, t]) | 对输入的记录用 s 替换 r 正则匹配，h 替换指定索引位置 |<br>|index(s, t) | 返回 s 中字符串 t 的索引位置， 0 为不存在 |<br>|length([s]) | 返回 s 的长度 |<br>|match(s, r [, a]) | 测试字符串 s 是否包含匹配 r 的字符串，如果不包含返回 0|<br>|split(s, a [, r [, seps] ]) | 根据分隔符 seps 将 s 分成数组 a|<br>|substr(s, i [, n]) | 截取字符串 s 从 i 开始到长度 n，如果 n 没指定则是剩余部分 |<br>|tolower(str) |str 中的所有大写转换成小写 |<br>|toupper(str) |str 中的所有小写转换成大写 |<br>|systime() | 当前时间戳 |<br>|strftime<br>([format [,timestamp[, utc-flag]]]) | 格式化输出时间，将时间戳转为字符串 |</p><p><strong>示例：</strong></p><p><strong>1 ）int()</strong></p><pre><code class="hljs bash">截断为整数：<span class="hljs-comment"># echo -e &quot;123abc\nabc123\n123abc123&quot; | awk &#x27;&#123;print int($0)&#125;&#x27;</span>1230123<span class="hljs-comment"># awk &#x27;BEGIN&#123;print int(10/3)&#125;&#x27;</span>3</code></pre><p><strong>2 ）sqrt()</strong></p><pre><code class="hljs bash">获取 9 的平方根：<span class="hljs-comment"># awk &#x27;BEGIN&#123;print sqrt(9)&#125;&#x27;</span>3</code></pre><p><strong>3 ）rand() 和 srand()</strong></p><pre><code class="hljs bash">rand() 并不是每次运行就是一个随机数，会一直保持一个不变：<span class="hljs-comment"># awk &#x27;BEGIN&#123;print rand()&#125;&#x27;</span>0.237788当执行 srand() 函数后，rand() 才会发生变化，所以一般在 awk 着两个函数结合生成随机数，但是也有很大几率生成一样：<span class="hljs-comment"># awk &#x27;BEGIN&#123;srand();print rand()&#125;&#x27;</span>0.31687如果想生成 1 - 10 的随机数可以这样：<span class="hljs-comment"># awk &#x27;BEGIN&#123;srand();print int(rand()*10)&#125;&#x27;</span>4</code></pre><p>如果想更完美生成随机数，还得做相应的处理！</p><p><strong>4 ）asort() 和 asorti()</strong></p><pre><code class="hljs bash">排序数组：<span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[x++]=$0&#125;END&#123;s=asort(a,b);for(i=1;i&lt;=s;i++)print b[i],i&#125;&#x27;</span>str1 1str2 2str3 3str4 4str5 5<span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[x++]=$0&#125;END&#123;s=asorti(a,b);for(i=1;i&lt;=s;i++)print b[i],i&#125;&#x27;</span>0 11 22 33 44 5</code></pre><p>asort 将 a 数组的值放到数组 b，a 下标丢弃，并将数组 b 的总行号赋值给 s，新数组 b 下标从 1 开始，然后遍历。</p><p><strong>5 ）sub() 和 gsub()</strong></p><pre><code class="hljs bash">替换正则匹配的字符串：<span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/&#123;sub(/tcp/,&quot;icmp&quot;);print $0&#125;&#x27;</span>blp5 48129/icmp <span class="hljs-comment"># Bloomberg locator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span><span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/&#123;gsub(/c/,&quot;9&quot;);print $0&#125;&#x27;</span>blp5 48129/t9p <span class="hljs-comment"># Bloomberg lo9ator</span>blp5 48129/udp <span class="hljs-comment"># Bloomberg lo9ator</span><span class="hljs-comment"># echo &quot;1 2 2 3 4 5&quot; |awk &#x27;gsub(2,7,$2)&#123;print $0&#125;&#x27;</span>1 7 2 3 4 5<span class="hljs-comment"># echo &quot;1 2 3 a b c&quot; |awk &#x27;gsub(/[0-9]/,&#x27;0&#x27;)&#123;print $0&#125;&#x27;</span>0 0 0 a b c</code></pre><p>在指定行前后加一行：</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 | awk &#x27;NR==2&#123;sub(&#x27;/.*/&#x27;,&quot;txt\n&amp;&quot;)&#125;&#123;print&#125;&#x27;</span>1txt2345<span class="hljs-comment"># seq 5 | awk &#x27;NR==2&#123;sub(&#x27;/.*/&#x27;,&quot;&amp;\ntxt&quot;)&#125;&#123;print&#125;&#x27;</span>12txt345</code></pre><p><strong>6 ）index()</strong></p><pre><code class="hljs bash">获取字段索引起始位置：<span class="hljs-comment"># tail -n 5 /etc/services |awk &#x27;&#123;print index($2,&quot;tcp&quot;)&#125;&#x27;</span>70707</code></pre><p><strong>7 ）length()</strong></p><pre><code class="hljs bash">统计字段长度：<span class="hljs-comment"># tail -n 5 /etc/services |awk &#x27;&#123;print length($2)&#125;&#x27;</span>99999统计数组的长度：<span class="hljs-comment"># tail -n 5 /etc/services |awk &#x27;&#123;a[$1]=$2&#125;END&#123;print length(a)&#125;&#x27;</span>3</code></pre><p><strong>8 ）match</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;123abc#456cde 789aaa#234bbb 999aaa#aaabbb&quot; |xargs -n1 |awk &#x27;&#123;printmatch($0,234)&#125;&#x27;</span>080如果记录匹配字符串 234 ，则返回索引位置，否则返回 0 。那么，我们只想打印包含这个字符串的记录就可以这样：<span class="hljs-comment"># echo &quot;123abc#456cde 789aaa#234bbb 999aaa#aaabbb&quot; |xargs -n1 |awk</span><span class="hljs-string">&#x27;&#123;if(match($0,234)!=0)print $0&#125;&#x27;</span>789aaa<span class="hljs-comment">#234bbb</span></code></pre><p><strong>9 ）split()</strong></p><pre><code class="hljs bash">切分记录为数组 a：<span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;split($0,a);for(v in a)print a[v],v&#125;&#x27;</span>123<span class="hljs-comment">#456#789 1</span>abc<span class="hljs-comment">#cde#fgh 1</span>以 <span class="hljs-comment">#号切分记录为数据 a：</span><span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;split($0,a,&quot;#&quot;);for(v in a)print a[v],v&#125;&#x27;</span>123 1456 2789 3abc 1cde 2fgh 3</code></pre><p><strong>10 ）substr()</strong></p><pre><code class="hljs bash">截取字符串索引 4 到最后：<span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;printsubstr($0,4)&#125;&#x27;</span><span class="hljs-comment">#456#789</span><span class="hljs-comment">#cde#fgh</span>截取字符串索引 4 到长度 5 ：<span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;print substr($0,4,5)&#125;&#x27;</span><span class="hljs-comment">#456#</span><span class="hljs-comment">#cde#</span></code></pre><p><strong>11 ）tolower() 和 toupper()</strong></p><pre><code class="hljs bash">转换小写：<span class="hljs-comment"># echo -e &quot;123#456#789\nABC#cde#fgh&quot; |awk &#x27;&#123;print tolower($0)&#125;&#x27;</span>123<span class="hljs-comment">#456#789</span>abc<span class="hljs-comment">#cde#fgh</span>转换大写：<span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;print toupper($0)&#125;&#x27;</span>123<span class="hljs-comment">#456#789</span>ABC<span class="hljs-comment">#CDE#FGH</span></code></pre><p><strong>12 ) 时间处理</strong></p><pre><code class="hljs bash">返回当前时间戳：<span class="hljs-comment"># awk &#x27;BEGIN&#123;print systime()&#125;&#x27;</span>1483297766将时间戳转为日期和时间<span class="hljs-comment"># echo &quot;1483297766&quot; |awk &#x27;&#123;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,$0)&#125;&#x27;</span>2017 - 01 - 01 14:09:26</code></pre><h3 id="7-3-8-I-O-语句"><a href="#7-3-8-I-O-语句" class="headerlink" title="7.3.8 I/O 语句"></a>7.3.8 I/O 语句</h3><table><thead><tr><th>语句</th><th>描述</th></tr></thead><tbody><tr><td>getline</td><td>读取下一个输入记录设置给 $0</td></tr><tr><td>getline var</td><td>读取下一个输入记录并赋值给变量 var</td></tr><tr><td>command | getline [var]</td><td>运行 Shell 命令管道输出到 $0 或 var</td></tr><tr><td>next</td><td>停止当前处理的输入记录后面动作</td></tr><tr><td>print</td><td>打印当前记录</td></tr><tr><td>printf fmt, expr-list</td><td>格式化输出</td></tr><tr><td>printf fmt, expr-list &gt;file</td><td>格式输出和写到文件</td></tr><tr><td>system(cmd-line)</td><td>执行命令和返回状态</td></tr><tr><td>print … &gt;&gt; file</td><td>追加输出到文件</td></tr><tr><td>print … | command</td><td>打印输出作为命令输入</td></tr></tbody></table><p><strong>示例：</strong></p><p><strong>1 ）getline</strong></p><pre><code class="hljs bash">获取匹配的下一行：<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;getline;print&#125;&#x27;</span>4<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;print;getline;print&#125;&#x27;</span>34在匹配的下一行加个星号：<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;getline;sub(&quot;.*&quot;,&quot;&amp;*&quot;);print&#125;&#x27;</span>4*<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;print;getline;sub(&quot;.*&quot;,&quot;&amp;*&quot;)&#125;&#123;print&#125;&#x27;</span>1234*5</code></pre><p><strong>2 ）getline var</strong></p><pre><code class="hljs bash">把 a 文件的行追加到 b 文件的行尾：<span class="hljs-comment"># cat a</span>abc<span class="hljs-comment"># cat b</span>1 one2 two3 three<span class="hljs-comment"># awk &#x27;&#123;getline line&lt;&quot;a&quot;;print $0,line&#125;&#x27; b</span>1 one a2 two b3 three c把 a 文件的行替换 b 文件的指定字段：<span class="hljs-comment"># awk &#x27;&#123;getline line&lt;&quot;a&quot;;gsub($2,line,$2);print&#125;&#x27; b</span>1 a2 b3 c把 a 文件的行替换 b 文件的对应字段：<span class="hljs-comment"># awk &#x27;&#123;getline line&lt;&quot;a&quot;;gsub(&quot;two&quot;,line,$2);print&#125;&#x27; b</span>1 one2 b3 three</code></pre><p><strong>3 ）command | getline [var]</strong></p><pre><code class="hljs bash">获取执行 shell 命令后结果的第一行：<span class="hljs-comment"># awk &#x27;BEGIN&#123;&quot;seq 5&quot;|getline var;print var&#125;&#x27;</span>1循环输出执行 shell 命令后的结果：<span class="hljs-comment"># awk &#x27;BEGIN&#123;while(&quot;seq 5&quot;|getline)print&#125;&#x27;</span>12345</code></pre><p><strong>4 ）next</strong></p><pre><code class="hljs bash">不打印匹配行：<span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0==3)&#123;next&#125;else&#123;print&#125;&#125;&#x27;</span>1245删除指定行：<span class="hljs-comment"># seq 5 |awk &#x27;NR==1&#123;next&#125;&#123;print $0&#125;&#x27;</span>2345如果前面动作成功，就遇到 next，后面的动作不再执行，跳过。或者：<span class="hljs-comment"># seq 5 |awk &#x27;NR!=1&#123;print&#125;&#x27;</span>2345把第一行内容放到每行的前面：<span class="hljs-comment"># cat a</span>hello1 a2 b3 c<span class="hljs-comment"># awk &#x27;NR==1&#123;s=$0;next&#125;&#123;print s,$0&#125;&#x27; a</span>hello 1 ahello 2 bhello 3 c<span class="hljs-comment"># awk &#x27;NR==1&#123;s=$0&#125;NF!=1&#123;print s,$0&#125;&#x27; a</span>hello 1 ahello 2 bhello 3 c</code></pre><p><strong>5 ）system()</strong></p><pre><code class="hljs bash">执行 shell 命令判断返回值：<span class="hljs-comment"># awk &#x27;BEGIN&#123;if(system(&quot;grep root /etc/passwd &amp;&gt;/dev/null&quot;)==0)print&quot;yes&quot;;else print&quot;no&quot;&#125;&#x27;</span>yes</code></pre><p><strong>6 ）打印结果写到文件</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;&#123;print $2&gt;&quot;a.txt&quot;&#125;&#x27;</span><span class="hljs-comment"># cat a.txt</span>48049/tcp48128/tcp48128/udp48129/tcp48129/udp</code></pre><p><strong>7 ）管道连接 shell 命令</strong></p><pre><code class="hljs bash">将结果通过 grep 命令过滤：<span class="hljs-comment"># tail - n5 /etc/services |awk &#x27;&#123;print $2|&quot;grep tcp&quot;&#125;&#x27;</span>48556/tcp48619/tcp49000/tcp</code></pre><h3 id="7-3-9-printf-语句"><a href="#7-3-9-printf-语句" class="headerlink" title="7.3.9 printf 语句"></a>7.3.9 printf 语句</h3><p>格式化输出，默认打印字符串不换行。</p><p>格式：printf [format] arguments</p><table><thead><tr><th>Format</th><th>描述</th></tr></thead><tbody><tr><td>%s</td><td>一个字符串</td></tr><tr><td>%d，%i</td><td>一个小数</td></tr><tr><td>%f</td><td>一个浮点数</td></tr><tr><td>%.ns</td><td>输出字符串，n 是输出几个字符</td></tr><tr><td>%m.nf</td><td>输出浮点数，m 是输出整数位数，n 是输出的小数位数</td></tr><tr><td>%x</td><td>不带正负号的十六进制，使用 a 至 f 表示 10 到 15</td></tr><tr><td>%X</td><td>不带正负号的十六进制，使用 A 至 F 表示 10 至 15</td></tr><tr><td>%%</td><td>输出单个 %</td></tr><tr><td>%-5s</td><td>左对齐，对参数每个字段左对齐, 宽度为 5</td></tr><tr><td>%-4.2f</td><td>左对齐，宽度为 4 ，保留两位小数</td></tr><tr><td>%5s</td><td>右对齐，不加横线表示右对齐</td></tr></tbody></table><p><strong>示例：</strong></p><pre><code class="hljs bash">将换行符换成逗号：<span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0!=5)printf&quot;%s,&quot;,$0;else print $0&#125;&#x27;</span>1,2,3,4,5小括号中的 5 是最后一个数字。输出一个字符：<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%.1s\n&quot;,&quot;abc&quot;&#125;&#x27;</span>a保留一个小数点：<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%.2f\n&quot;,10/3&#125;&#x27;</span>3.33格式化输出：<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;user:%s\tpass:%d\n&quot;,&quot;abc&quot;,123&#125;&#x27;</span>user:abc pass:123左对齐宽度 10 ：<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%-10s %-10s %-10s\n&quot;,&quot;ID&quot;,&quot;Name&quot;,&quot;Passwd&quot;&#125;&#x27;</span>ID Name Passwd右对齐宽度 10 ：<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%10s %10s %10s\n&quot;,&quot;ID&quot;,&quot;Name&quot;,&quot;Passwd&quot;&#125;&#x27;</span>ID Name Passwd打印表格：<span class="hljs-comment"># vi test.awk</span>BEGIN&#123;<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;+--------------------+--------------------+&quot;</span>;<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;|%-20s|%-20s|\n&quot;</span>,<span class="hljs-string">&quot;Name&quot;</span>,<span class="hljs-string">&quot;Number&quot;</span>;<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;+--------------------+--------------------+&quot;</span>;&#125;<span class="hljs-comment"># awk -f test.awk</span>+--------------------+--------------------+|Name |Number |+--------------------+--------------------+格式化输出：<span class="hljs-comment"># awk -F: &#x27;BEGIN&#123;printf&quot;UserName\t\tShell\n-----------------------------\n&quot;&#125;&#123;printf&quot;%-20s %-20s\n&quot;,$1,$7&#125;END&#123;print&quot;END...\n&quot;&#125;&#x27; /etc/passwd</span>打印十六进制：<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%x %X&quot;,123,123&#125;&#x27;</span>7b 7B</code></pre><h3 id="7-3-10-自定义函数"><a href="#7-3-10-自定义函数" class="headerlink" title="7.3.10 自定义函数"></a>7.3.10 自定义函数</h3><p>格式：function name(parameter list) { statements }</p><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;function myfunc(a,b)&#123;return a+b&#125;BEGIN&#123;print myfunc(1,2)&#125;&#x27;</span>3</code></pre><h3 id="7-3-11-需求案例"><a href="#7-3-11-需求案例" class="headerlink" title="7.3.11 需求案例"></a>7.3.11 需求案例</h3><p><strong>1 ）分析 Nginx 日志</strong></p><p>日志格式：</p><p>‘$remote_addr - $remote_user [$time_local]”$request”$status $body_bytes_sent”$http_referer””$http_user_agent” “$http_x_forwarded_for”‘</p><pre><code class="hljs bash">统计访问 IP 次数：<span class="hljs-comment"># awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a)print v,a[v]&#125;&#x27; access.log</span>统计访问访问大于 100 次的 IP：<span class="hljs-comment"># awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a)&#123;if(a[v]&gt;100)print v,a[v]&#125;&#125;&#x27; access.log</span>统计访问 IP 次数并排序取前 10 ：<span class="hljs-comment"># awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a)print v,a[v] |&quot;sort -k2 -nr |head -10&quot;&#125;&#x27; access.log</span>统计时间段访问最多的 IP：<span class="hljs-comment"># awk &#x27;$4&gt;=&quot;[02/Jan/2017:00:02:00&quot;&amp;&amp; $4&lt;=&quot;[02/Jan/2017:00:03:00&quot;&#123;a[$1]++&#125;END&#123;for(v ina)print v,a[v]&#125;&#x27; access.log</span>统计上一分钟访问量：<span class="hljs-comment"># date=$(date -d &#x27;-1 minute&#x27; +%d/%d/%Y:%H:%M)</span><span class="hljs-comment"># awk - vdate=$date &#x27;$4~date&#123;c++&#125;END&#123;print c&#125;&#x27; access.log</span>统计访问最多的 10 个页面：<span class="hljs-comment"># awk &#x27;&#123;a[$7]++&#125;END&#123;for(v in a)print v,a[v] |&quot;sort -k1 -nr|head -n10&quot;&#125;&#x27; access.log</span>统计每个 URL 数量和返回内容总大小：<span class="hljs-comment"># awk &#x27;&#123;a[$7]++;size[$7]+=$10&#125;END&#123;for(v in a)print a[v],v,size[v]&#125;&#x27; access.log</span>统计每个 IP 访问状态码数量：<span class="hljs-comment"># awk &#x27;&#123;a[$1&quot; &quot;$9]++&#125;END&#123;for(v in a)print v,a[v]&#125;&#x27; access.log</span>统计访问 IP 是 404 状态次数：<span class="hljs-comment"># awk &#x27;&#123;if($9~/404/)a[$1&quot; &quot;$9]++&#125;END&#123;for(i in a)print v,a[v]&#125;&#x27; access.log</span></code></pre><p><strong>2 ）两个文件对比</strong></p><p>找出 b 文件在 a 文件相同记录：</p><pre><code class="hljs bash"><span class="hljs-comment"># seq 1 5 &gt; a</span><span class="hljs-comment"># seq 3 7 &gt; b</span>方法 1 ：<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0];next&#125;&#123;if($0 in a)print $0&#125;&#x27; a b</span>345<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0];next&#125;&#123;if($0 in a)print FILENAME,$0&#125;&#x27; a b</span>b 3b 4b 5<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]&#125;NR&gt;FNR&#123;if($0 in a)print $0&#125;&#x27; a b</span>345<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]=1;next&#125;(a[$0]==1)&#x27; a b # a[$0] 是通过 b 文件每行获取值，如果是 1 说明有</span><span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]=1;next&#125;&#123;if(a[$0]==1)print&#125;&#x27; a b</span>345方法 2 ：<span class="hljs-comment"># awk &#x27;FILENAME==&quot;a&quot;&#123;a[$0]&#125;FILENAME==&quot;b&quot;&#123;if($0 in a)print $0&#125;&#x27; a b</span>345方法 3 ：<span class="hljs-comment"># awk &#x27;ARGIND==1&#123;a[$0]=1&#125;ARGIND==2 &amp;&amp; a[$0]==1&#x27; a b</span>345</code></pre><p>找出 b 文件在 a 文件不同记录：</p><pre><code class="hljs bash">方法 1 ：<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0];next&#125;!($0 in a)&#x27; a b</span>67<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]=1;next&#125;(a[$0]!=1)&#x27; a b</span><span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]=1;next&#125;&#123;if(a[$0]!=1)print&#125;&#x27; a b</span>67方法 2 ：<span class="hljs-comment"># awk &#x27;FILENAME==&quot;a&quot;&#123;a[$0]=1&#125;FILENAME==&quot;b&quot;&amp;&amp; a[$0]!=1&#x27; a b</span>方法 3 ：<span class="hljs-comment"># awk &#x27;ARGIND==1&#123;a[$0]=1&#125;ARGIND==2 &amp;&amp; a[$0]!=1&#x27; a b</span></code></pre><p><strong>3 ）合并两个文件</strong></p><p>将 a 文件合并到 b 文件：</p><pre><code class="hljs bash"><span class="hljs-comment"># cat a</span>zhangsan 20lisi 23wangwu 29<span class="hljs-comment"># cat b</span>zhangsan manlisi womanwangwu man<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$1]=$0;next&#125;&#123;print a[$1],$2&#125;&#x27; a b</span>zhangsan 20 manlisi 23 womanwangwu 29 man<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$1]=$0&#125;NR&gt;FNR&#123;print a[$1],$2&#125;&#x27; a b</span>zhangsan 20 manlisi 23 womanwangwu 29 man</code></pre><p>将 a 文件相同 IP 的服务名合并：</p><pre><code class="hljs bash"><span class="hljs-comment"># cat a</span>192.168.1.1: httpd192.168.1.1: tomcat192.168.1.2: httpd192.168.1.2: postfix192.168.1.3: mysqld192.168.1.4: httpd<span class="hljs-comment"># awk &#x27;BEGIN&#123;FS=&quot;:&quot;;OFS=&quot;:&quot;&#125;&#123;a[$1]=a[$1] $2&#125;END&#123;for(v in a)print v,a[v]&#125;&#x27; a</span>192.168.1.4: httpd192.168.1.1: httpd tomcat192.168.1.2: httpd postfix192.168.1.3: mysqld</code></pre><p>说明：数组 a 存储是 $1=a[$1] $2，第一个 a[$1] 是以第一个字段为下标，值是 a[$1] $2，也就是 $1=a[$1] $2，值的 a[$1] 是用第一个字段为下标获取对应的值，但第一次数组 a 还没有元素，那么 a[$1] 是空值，此时数组存储是 192.168.1.1=httpd，再遇到 192.168.1.1 时，a[$1] 通过第一字段下标获得上次数组的 httpd，把当前处理的行第二个字段放到上一次同下标的值后面，作为下标 192.168.1.1 的新值。此时数组存储是 192.168.1.1=httpd tomcat。每次遇到相同的下标（第一个字段）就会获取上次这个下标对应的值与当前字段并作为此下标的新值。</p><p><strong>4 ）将第一列合并到一行</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># cat file</span>1 2 34 5 67 8 9<span class="hljs-comment"># awk &#x27;&#123;for(i=1;i&lt;=NF;i++)a[i]=a[i]$i&quot; &quot;&#125;END&#123;for(v in a)print a[v]&#125;&#x27; file</span>1 4 72 5 83 6 9</code></pre><p>说明：<br>for 循环是遍历每行的字段，NF 等于 3 ，循环 3 次。</p><p>读取第一行时：<br>第一个字段：a[1]=a[1] 1 “ “ 值 a[ 1 ] 还未定义数组，下标也获取不到对应的值，所以为空，因此 a[ 1 ]= 1 。</p><p>第二个字段：a[2]=a[2] 2 “ “ 值 a[ 2 ] 数组 a 已经定义，但没有 2 这个下标，也获取不到对应的值，为空，因此 a[ 2 ]=2 。</p><p>第三个字段：a[3]=a[3] 3 “ “ 值 a[ 2 ] 与上面一样，为空, a[3]= 3 。</p><p>读取第二行时：</p><p>第一个字段：a[1]=a[ 1 ] 4 “ “ 值 a[ 2 ] 获取数组 a 的 2 为下标对应的值，上面已经有这个下标了，对应的值是 1 ，因此 a[ 1 ]=1 4</p><p>第二个字段：a[2]=a[2] 5 “ “ 同上，a[ 2 ]=2 5</p><p>第三个字段：a[3]=a[3] 6 “ “ 同上，a[ 2 ]= 3 6</p><p>读取第三行时处理方式同上，数组最后还是三个下标，分别是 1=1 4 7，2=2 5 8， 3 =3 6 9。最后 for 循环输出所有下标值。</p><p><strong>5 ）字符串拆分，统计出现的次数</strong></p><p>字符串拆分：</p><pre><code class="hljs bash">方法 1 ：<span class="hljs-comment"># echo &quot;hello world&quot; |awk -F &#x27;&#x27;&#x27;&#123;print $1&#125;&#x27;</span>h<span class="hljs-comment"># echo &quot;hello&quot; |awk -F &#x27;&#x27;&#x27;&#123;for(i=1;i&lt;=NF;i++)print $i&#125;&#x27;</span>hello方法 2 ：<span class="hljs-comment"># echo &quot;hello&quot; |awk &#x27;&#123;split($0,a,&quot;&#x27;&#x27;&quot;);for(v in a)print a[v]&#125;&#x27;</span>lohel</code></pre><p>统计字符串中每个字母出现的次数：</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a.b.c,c.d.e&quot; |awk -F &#x27;[.,]&#x27; &#x27;&#123;for(i=1;i&lt;=NF;i++)a[$i]++&#125;END&#123;for(v in a)printv,a[v]&#125;&#x27;</span>a 1b 1c 2d 1e 1</code></pre><p><strong>6 ）统计平均成绩</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># cat file</span>job 80dave 84tom 75dave 73job 72tom 83dave 88<span class="hljs-comment"># awk &#x27;&#123;a[$1]+=$2;b[$1]++&#125;END&#123;for(i in a)print i,a[i]/b[i]&#125;&#x27; file</span>job 76dave 81.6667tom 79</code></pre><p><strong>7 ）费用统计</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># cat file</span>zhangsan 8000 1zhangsan 5000 1lisi 1000 1lisi 2000 1wangwu 1500 1zhaoliu 6000 1zhaoliu 2000 1zhaoliu 3000 1<span class="hljs-comment"># awk &#x27;&#123;name[$1]++;cost[$1]+=$2;number[$1]+=$3&#125;END&#123;for(v in name)printv,cost[v],number[v]&#125;&#x27; file</span>zhangsan 5000 1lisi 3000 2wangwu 1500 1zhaoliu 11000 3</code></pre><p><strong>8 ）获取数字字段最大值</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># cat file</span>a b 1c d 2e f 3g h 3i j 2获取第三字段最大值：<span class="hljs-comment"># awk &#x27;BEGIN&#123;max=0&#125;&#123;if($3&gt;max)max=$3&#125;END&#123;print max&#125;&#x27; file</span>3打印第三字段最大行：<span class="hljs-comment"># awk &#x27;BEGIN&#123;max=0&#125;&#123;a[$0]=$3;if($3&gt;max)max=$3&#125;END&#123;for(v in a)print v,a[v],max&#125;&#x27; a</span>g h 3 3 3e f 3 3 3c d 2 2 3a b 1 1 3i j 2 2 3<span class="hljs-comment"># awk &#x27;BEGIN&#123;max=0&#125;&#123;a[$0]=$3;if($3&gt;max)max=$3&#125;END&#123;for(v in a)if(a[v]==max)print v&#125;&#x27; a</span>g h 3e f 3</code></pre><p><strong>9 ）去除第一行和最后一行</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;NR&gt;2&#123;print s&#125;&#123;s=$0&#125;&#x27;</span>234</code></pre><p>读取第一行，NR= 1 ，不执行 print s，s= 1</p><p>读取第二行，NR= 2 ，不执行 print s，s= 2 （大于为真）</p><p>读取第三行，NR= 3 ，执行 print s，此时 s 是上一次 p 赋值内容 2 ，s=3</p><p>最后一行，执行 print s，打印倒数第二行，s = 最后一行</p><p>获取 Nginx 负载均衡配置端 IP 和端口：</p><pre><code class="hljs bash"><span class="hljs-comment"># cat nginx.conf</span>upstream example-servers1 &#123;server 127.0.0.1:80 weight=1 max_fails=2 fail_timeout=30s;<span class="hljs-comment">##### &#125;</span>upstream example-servers2 &#123;server 127.0.0.1:80 weight=1 max_fails=2 fail_timeout=30s;server 127.0.0.1:82 backup;&#125;<span class="hljs-comment"># awk &#x27;/example-servers1/,/&#125;/&#123;if(NR&gt;2)&#123;print s&#125;&#123;s=$2&#125;&#125;&#x27; nginx.conf</span>127.0.0.1:80<span class="hljs-comment"># awk &#x27;/example-servers1/,/&#125;/&#123;if(i&gt;1)print s;s=$2;i++&#125;&#x27; nginx.conf</span><span class="hljs-comment"># awk &#x27;/example-servers1/,/&#125;/&#123;if(i&gt;1)&#123;print s&#125;&#123;s=$2;i++&#125;&#125;&#x27; nginx.conf</span>127.0.0.1:80</code></pre><p>读取第一行，i 初始值为 0 ，0&gt;1 为假，不执行 print s，x=example-servers1，i= 1</p><p>读取第二行，i= 1 ，1&gt;1 为假，不执行 print s，s=127.0.0.1:80,i=2</p><p>读取第三行，i=2，2&gt;1 为真，执行 print s，此时 s 是上一次 s 赋值内容 127.0.0.1:80，i= 3</p><p>最后一行，执行 print s，打印倒数第二行，s = 最后一行。</p><p>这种方式与上面一样，只是用 i++ 作为计数器。</p><p><strong>10 ）知道上述方式，就可以实现这种需求了，打印匹配行的上一行</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;print s&#125;&#123;s=$0&#125;&#x27;</span>2</code></pre><p>其他参考资料：<a href="http://www.gnu.org/software/gawk/manual/gawk.html">http://www.gnu.org/software/gawk/manual/gawk.html</a></p><h1 id="八、-Shell-标准输入、输出和错误"><a href="#八、-Shell-标准输入、输出和错误" class="headerlink" title="八、 Shell 标准输入、输出和错误"></a>八、 Shell 标准输入、输出和错误</h1><p>文件描述符（fd）：文件描述符是一个非负整数，在打开现存文件或新建文件时，内核会返回一个文件描述符，读写文件也需要使用文件描述符来访问文件。</p><p>内核为每个进程维护该进程打开的文件记录表。文件描述符只适于 Unix、Linux 操作系统。</p><h2 id="8-1-标准输入、输出和错误"><a href="#8-1-标准输入、输出和错误" class="headerlink" title="8.1 标准输入、输出和错误"></a>8.1 标准输入、输出和错误</h2><table><thead><tr><th>文件描述符</th><th>描述</th><th>映射关系</th></tr></thead><tbody><tr><td>0</td><td>标准输入，键盘</td><td>/dev/stdin -&gt; /proc/self/fd/0</td></tr><tr><td>1</td><td>标准输出，屏幕</td><td>/dev/stdout -&gt; /proc/self/fd/1</td></tr><tr><td>2</td><td>标准错误，屏幕</td><td>/dev/stderr -&gt; /proc/self/fd/2</td></tr></tbody></table><h2 id="8-2-重定向符号"><a href="#8-2-重定向符号" class="headerlink" title="8.2 重定向符号"></a>8.2 重定向符号</h2><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>&gt;</td><td>符号左边输出作为右边输入（标准输出）</td></tr><tr><td>&gt;&gt;</td><td>符号左边输出追加右边输入</td></tr><tr><td>&lt;</td><td>符号右边输出作为左边输入（标准输入）</td></tr><tr><td>&lt;&lt;</td><td>符号右边输出追加左边输入</td></tr><tr><td>&amp;</td><td>重定向绑定符号</td></tr></tbody></table><p>输入和输出可以被重定向符号解释到 shell。</p><p>shell 命令是从左到右依次执行命令。</p><p>下面 n 字母是文件描述符。</p><h2 id="8-3-重定向输出"><a href="#8-3-重定向输出" class="headerlink" title="8.3 重定向输出"></a>8.3 重定向输出</h2><p><strong>1 ）覆盖输出</strong></p><p>一般格式：[n]&gt;word</p><p>如果 n 没有指定，默认是 1</p><p><strong>示例：</strong></p><pre><code class="hljs bash">打印结果写到文件：<span class="hljs-comment"># echo &quot;test&quot; &gt; a.txt</span>当没有安装 bc 计算器时，错误输出结果写到文件：<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc 2 &gt; error.log</span></code></pre><p><strong>2 ）追加重定向输出</strong></p><p>一般格式：[n]&gt;&gt;word</p><p>如果 n 没有指定，默认是 1</p><p><strong>示例：</strong></p><pre><code class="hljs bash">打印结果追加到文件：<span class="hljs-comment"># echo &quot;test&quot; &gt;&gt; a.txt</span>当没有安装 bc 计算器时，错误输出结果追加文件：<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc 2 &gt; error.log</span></code></pre><h2 id="8-4-重定向输入"><a href="#8-4-重定向输入" class="headerlink" title="8.4 重定向输入"></a>8.4 重定向输入</h2><p>一般格式：[n]&lt;word</p><p>如果 n 没有指定，默认是 0</p><p><strong>示例：</strong></p><pre><code class="hljs bash">a.txt 内容作为 grep 输入：<span class="hljs-comment"># grep &quot;test&quot; --color &lt; a.txt</span></code></pre><h2 id="8-5-重定向标准输出和标准错误"><a href="#8-5-重定向标准输出和标准错误" class="headerlink" title="8.5 重定向标准输出和标准错误"></a>8.5 重定向标准输出和标准错误</h2><p><strong>1 ）覆盖重定向标准输出和标准错误</strong></p><p>&amp;&gt;word 和 &gt;&amp;word 等价于 &gt;word 2&gt;&amp;1</p><p>&amp; 将标准输出和标准输入绑定到一起，重定向 word 文件。</p><p><strong>示例：</strong></p><pre><code class="hljs bash">当不确定执行对错时都覆盖到文件：<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc &amp;&gt; error.log</span>当不确定执行对错时都覆盖到文件：<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc &gt; error.log 2&gt;&amp;1</span></code></pre><p><strong>2 ）追加重定向标准输出和标准错误</strong></p><p>&amp;&gt;&gt;word 等价于 &gt;&gt;word 2&gt;&amp;1</p><p><strong>示例：</strong></p><pre><code class="hljs bash">当不确定执行对错时都追加文件：<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc &amp;&gt;&gt; error.log</span></code></pre><p>将标准输出和标准输入追加重定向到 delimiter：</p><pre><code class="hljs bash">&lt;&lt; delimiterhere-documentdelimiter</code></pre><p>从当前 shell 读取输入源，直到遇到一行只包含 delimiter 终止，内容作为标准输入。</p><p>将 eof 标准输入作为 cat 标准输出再写到 a.txt：</p><pre><code class="hljs bash"><span class="hljs-comment"># cat &lt;&lt; eof</span>123abceof123abc<span class="hljs-comment"># cat &gt; a.txt &lt;&lt; eof</span>&gt; 123&gt; abc&gt; eof</code></pre><h2 id="8-6-重定向到空设备"><a href="#8-6-重定向到空设备" class="headerlink" title="8.6 重定向到空设备"></a>8.6 重定向到空设备</h2><p><code>/dev/null</code> 是一个空设备，向它写入的数组都会丢弃，但返回状态是成功的。与其对应的还有一个 <code>/dev/zero</code> 设备，提供无限的 0 数据流。</p><p>在写 Shell 脚本时我们经常会用到 <code>/dev/null</code> 设备，将 stdout、stderr 输出给它，也就是我们不想要这些输出的数据。</p><p>通过重定向到 <code>/dev/null</code> 忽略输出，比如我们没有安装 bc 计算器，正常会抛出没有发现命令：</p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;1 + 1&quot; |bc &gt;/dev/null 2&gt;&amp;1</span></code></pre><p>这就让标准和错误输出到了空设备。</p><p><strong>忽略标准输出：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;test&quot; &gt;/dev/null</span></code></pre><p><strong>忽略错误输出：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;1 + 1&quot; |bc 2&gt;/dev/null</span></code></pre><h2 id="8-7-read-命令"><a href="#8-7-read-命令" class="headerlink" title="8.7 read 命令"></a>8.7 read 命令</h2><p>read 命令从标准输入读取，并把输入的内容复制给变量。</p><p>命令格式： read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]</p><ul><li>-e: 在一个交互 shell 中使用 readline 获取行</li><li>-r: 不允许反斜杠转义任何字符</li><li>-s: 隐藏输入</li><li>-a array: 保存为数组，元素以空格分隔</li><li>-d delimiter: 持续读取直到遇到 delimiter 第一个字符退出</li><li>-n nchars: 读取 nchars 个字符返回，而不是等到换行符</li><li>-p prompt: 提示信息</li><li>-t timeout: 等待超时时间，秒</li><li>-u fd: 指定文件描述符号码作为输入，默认是 0</li><li>name: 变量名</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">获取用户输入保存到变量：<span class="hljs-comment"># read -p &quot;Please input your name:&quot; VAR</span>Please input your name: lizhenliang<span class="hljs-comment"># echo $VAR</span>lizhenliang用户输入保存为数组：<span class="hljs-comment"># read -p &quot;Please input your name:&quot; -a ARRAY</span>Please input your name: a b c<span class="hljs-comment"># echo $&#123;ARRAY[*]&#125;</span>a b c遇到 e 字符返回：<span class="hljs-comment"># read -d e VAR</span>123456e<span class="hljs-comment"># echo $VAR</span>123 456从文件作为 <span class="hljs-built_in">read</span> 标准输入：<span class="hljs-comment"># cat a.txt</span>adfasfd<span class="hljs-comment"># read VAR &lt; a.txt</span><span class="hljs-comment"># echo $VAR</span>adfasfd<span class="hljs-keyword">while</span> 循环读取每一行作为 <span class="hljs-built_in">read</span> 的标准输入：<span class="hljs-comment"># cat a.txt |while read LINE; do echo $LINE; done</span>123abc分别变量赋值：<span class="hljs-comment"># read a b c</span>1 2 3<span class="hljs-comment"># echo $a</span>1<span class="hljs-comment"># echo $b</span>2<span class="hljs-comment"># echo $c</span>3<span class="hljs-comment"># echo 1 2 3 | while read a b c;do echo &quot;$a $b $c&quot;; done</span>1 2 3</code></pre><h1 id="九、-Shell-信号发送与捕捉"><a href="#九、-Shell-信号发送与捕捉" class="headerlink" title="九、 Shell 信号发送与捕捉"></a>九、 Shell 信号发送与捕捉</h1><h2 id="9-1-Linux-信号类型"><a href="#9-1-Linux-信号类型" class="headerlink" title="9.1 Linux 信号类型"></a>9.1 Linux 信号类型</h2><p>信号（Signal）：信号是在软件层次上对中断机制的一种模拟，通过给一个进程发送信号，执行相应的处理函数。</p><p>进程可以通过三种方式来响应一个信号：</p><ul><li>1 ）忽略信号，即对信号不做任何处理，其中有两个信号不能忽略：SIGKILL 及 SIGSTOP。</li><li>2 ）捕捉信号。</li><li>3 ）执行缺省操作，Linux 对每种信号都规定了默认操作。</li></ul><p>Linux 究竟采用上述三种方式的哪一个来响应信号呢？取决于传递给响应的 API 函数。</p><p>Linux 支持的信号有：</p><table><thead><tr><th>编号</th><th>信号名称</th><th>缺省动作</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>终止</td><td>终止进程，挂起</td></tr><tr><td>2</td><td>SIGINT</td><td>终止</td><td>键盘输入中断命令，一般是 CTRL+C</td></tr><tr><td>3</td><td>SIGQUIT</td><td>CoreDump</td><td>键盘输入退出命令，一般是 CTRL+\</td></tr><tr><td>4</td><td>SIGILL</td><td>CoreDump</td><td>非法指令</td></tr><tr><td>5</td><td>SIGTRAP</td><td>CoreDump</td><td>trap 指令发出，一般调试用</td></tr><tr><td>6</td><td>SIGABRT</td><td>CoreDump</td><td>abort(3) 发出的终止信号</td></tr><tr><td>7</td><td>SIGBUS</td><td>CoreDump</td><td>非法地址</td></tr><tr><td>8</td><td>SIGFPE</td><td>CoreDump</td><td>浮点数异常</td></tr><tr><td>9</td><td>SIGKILL</td><td>终止</td><td>立即停止进程，不能捕获，不能忽略</td></tr><tr><td>10</td><td>SIGUSR1</td><td>终止</td><td>用户自定义信号 ^1 ，像 Nginx 就支持 USR1 信号，用于重载配 <br> 置，重新打开日志</td></tr><tr><td>11</td><td>SIGSEGV</td><td>CoreDump</td><td>无效内存引用</td></tr><tr><td>12</td><td>SIGUSR2</td><td>终止</td><td>用户自定义信号 2</td></tr><tr><td>13</td><td>SIGPIPE</td><td>终止</td><td>管道不能访问</td></tr><tr><td>14</td><td>SIGALRM</td><td>终止</td><td>时钟信号，alrm(2) 发出的终止信号</td></tr><tr><td>15</td><td>SIGTERM</td><td>终止</td><td>终止信号，进程会先关闭正在运行的任务或打开的文件再终 <br> 止，有时候有的进程在运行任务会忽略此信号。不能捕捉</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>终止</td><td>处理器栈错误</td></tr><tr><td>17</td><td>SIGCHLD</td><td>可忽略</td><td>子进程结束时，父进程收到的信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>可忽略</td><td>让终止的进程继续执行</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止</td><td>停止进程，不能忽略，不能捕获</td></tr><tr><td>20</td><td>SIGSTP</td><td>停止</td><td>停止进程，一般是 CTRL+Z</td></tr><tr><td>21</td><td>SIGTTIN</td><td>停止</td><td>后台进程从终端读数据</td></tr><tr><td>22</td><td>SIGTTOU</td><td>停止</td><td>后台进程从终端写数据</td></tr><tr><td>23</td><td>SIGURG</td><td>可忽略</td><td>紧急数组是否到达 socket</td></tr><tr><td>24</td><td>SIGXCPU</td><td>CoreDump</td><td>超出 CPU 占用资源限制</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>CoreDump</td><td>超出文件大小资源限制</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>终止</td><td>虚拟时钟信号，类似于 SIGALRM，但计算的是进程占用的时间</td></tr><tr><td>27</td><td>SIGPROF</td><td>终止</td><td>类似与 SIGALRM，但计算的是进程占用 CPU 的时间</td></tr><tr><td>28</td><td>SIGWINCH</td><td>可忽略</td><td>窗口大小改变发出的信号</td></tr><tr><td>29</td><td>SIGIO</td><td>终止</td><td>文件描述符准备就绪，可以输入 / 输出操作了</td></tr><tr><td>30</td><td>SIGPWR</td><td>终止</td><td>电源失败</td></tr><tr><td>31</td><td>SIGSYS</td><td>CoreDump</td><td>非法系统调用</td></tr></tbody></table><p><strong>CoreDump（核心转储）</strong>：当程序运行过程中异常退出时，内核把当前程序在内存状况存储在一个 core 文件中，以便调试。执行命令 <code>ulimit -c</code> 如果是 0 则没有开启，也不会生成 core dump 文件，可通过 <code>ulimit -c unlimited</code> 命令临时开启 core dump 功能，只对当前终端环境有效，如果想永久生效，可修改 <code>/etc/security/limites.conf</code> 文件，添加一行 “* soft core unlimited” 默认生成的 core 文件保存在可执行文件所在的目录下，文件名为 core。如果想修改 core 文件保存路径，可通过修改内核参数：<code>echo &quot;/tmp/corefile-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern</code> 则文件名格式为 core- 命名名 -pid- 时间戳</p><p>Linux 支持两种信号：</p><p>一种是标准信号，编号 1 - 31 ，称为非可靠信号（非实时），不支持队列，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次，如果第一个信号没有处理完，第二个信号将会丢弃。</p><p>另一种是扩展信号，编号 32 - 64 ，称为可靠信号（实时），支持队列，发多少次进程就可以收到多少次。</p><p>信号类型比较多，我们只要了解下，记住几个常用信号就行了，红色标记的我觉得需要记下。</p><p>发送信号一般有两种情况：</p><p>一种是内核检测到系统事件，比如键盘输入 CTRL+C 会发送 SIGINT 信号。</p><p>另一种是通过系统调用 kill 命令来向一个进程发送信号。</p><h2 id="9-2-kill-命令"><a href="#9-2-kill-命令" class="headerlink" title="9.2 kill 命令"></a>9.2 kill 命令</h2><p>kill 命令发送信号给进程。</p><p>命令格式：kill [-s sigspec | -n signum | -sigspec] pid | jobspec … kill -l [sigspec]</p><ul><li>-s # 信号名称</li><li>-n # 信号编号</li><li>-l # 打印编号 1 - 31 信号名称</li></ul><p>示例：</p><pre><code class="hljs bash">给一个进程发送终止信号：<span class="hljs-built_in">kill</span> - s SIGTERM pid或<span class="hljs-built_in">kill</span> - n 15 pid或<span class="hljs-built_in">kill</span> - 15 pid或<span class="hljs-built_in">kill</span> - TREM pid</code></pre><h2 id="9-3-trap-命令"><a href="#9-3-trap-命令" class="headerlink" title="9.3 trap 命令"></a>9.3 trap 命令</h2><p>trap 命令定义 shell 脚本在运行时根据接收的信号做相应的处理。</p><p>命令格式：trap [-lp] [[arg] signal_spec …]</p><ul><li>-l # 打印编号 1 - 64 编号信号名称</li><li>arg # 捕获信号后执行的命令或者函数</li><li>signal_spec # 信号名或编号</li></ul><p>一般捕捉信号后，做以下几个动作：</p><ul><li>1 ）清除临时文件</li><li>2 ）忽略该信号</li><li>3 ）询问用户是否终止脚本执行</li></ul><p><strong>示例 1 ：按 CTRL+C 不退出循环</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;&quot;</span> 2 <span class="hljs-comment"># 不指定 arg 就不做任何操作，后面也可以写多个信号，以空格分隔</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>sleep 1<span class="hljs-keyword">done</span><span class="hljs-comment"># bash a.sh</span>123^C456^C78910</code></pre><p><strong>示例 2 ：循环打印数字，按 CTRL+C 退出，并打印退出提示</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;echo&#x27;exit...&#x27;;exit&quot;</span> 2<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>sleep 1<span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh</span>123^Cexit...</code></pre><p><strong>示例 3 ：让用户选择是否终止循环</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;func&quot;</span> 2<span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;  <span class="hljs-built_in">read</span> - p <span class="hljs-string">&quot;Terminate the process? (Y/N):&quot;</span> input  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$input</span> == <span class="hljs-string">&quot;Y&quot;</span>]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">exit</span>  <span class="hljs-keyword">fi</span>&#125;<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>  sleep 1<span class="hljs-keyword">done</span><span class="hljs-comment"># bash a.sh</span>123^CTerminate the process? (Y/N): Y<span class="hljs-comment"># bash a.sh</span>123^CTerminate the process? (Y/N): N456...</code></pre><h1 id="十、-Shell-编程时常用的系统文件"><a href="#十、-Shell-编程时常用的系统文件" class="headerlink" title="十、 Shell 编程时常用的系统文件"></a>十、 Shell 编程时常用的系统文件</h1><h2 id="10-1-Linux-系统目录结构"><a href="#10-1-Linux-系统目录结构" class="headerlink" title="10.1 Linux 系统目录结构"></a>10.1 Linux 系统目录结构</h2><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>/</td><td>根目录，所有文件的第一级目录</td></tr><tr><td>/home</td><td>普通用户家目录</td></tr><tr><td>/root</td><td>超级用户家目录</td></tr><tr><td>/usr</td><td>用户命令、应用程序等目录</td></tr><tr><td>/var</td><td>应用数据、日志等目录</td></tr><tr><td>/lib</td><td>库文件和内核模块目录</td></tr><tr><td>/etc</td><td>系统和软件配置文件</td></tr><tr><td>/bin</td><td>可执行程序目录</td></tr><tr><td>/boot</td><td>内核加载所需的文件，grub 引导</td></tr><tr><td>/dev</td><td>设备文件目录，比如磁盘驱动</td></tr><tr><td>/tmp</td><td>临时文件目录</td></tr><tr><td>/opt</td><td>第三方软件安装目录</td></tr></tbody></table><h2 id="10-2-环境变量文件"><a href="#10-2-环境变量文件" class="headerlink" title="10.2 环境变量文件"></a>10.2 环境变量文件</h2><h4 id="系统级"><a href="#系统级" class="headerlink" title="系统级"></a>系统级</h4><p>系统级变量文件对所有用户生效。</p><ul><li><code>/etc/profile</code> # 系统范围内的环境变量和启动文件。不建议把要做的事情写在这里面，最好创建一个自定义的，放在 <code>/etc/profile.d</code> 下</li><li><code>/etc/bashrc</code> # 系统范围内的函数和别名</li></ul><h4 id="用户级"><a href="#用户级" class="headerlink" title="用户级"></a>用户级</h4><p>用户级变量文件对自己生效，都在自己家目录下。</p><ul><li><code>~/.bashrc</code> # 用户指定别名和函数</li><li><code>~/.bash_logout</code> # 用户退出执行</li><li><code>~/.bash_profile</code> # 用户指定变量和启动程序</li><li><code>~/.bash_history</code> # 用户执行命令历史文件</li></ul><h4 id="开启启动脚本顺序："><a href="#开启启动脚本顺序：" class="headerlink" title="开启启动脚本顺序："></a>开启启动脚本顺序：</h4><p><code>/etc/profile -&gt; /etc/profile.d/*.sh -&gt; ~/.bash_profile -&gt; ~/.bashrc -&gt;/etc/bashrc</code></p><p>因此，我们可以把写的脚本放到以上文件里执行。</p><h3 id="10-3-系统配置文件"><a href="#10-3-系统配置文件" class="headerlink" title="10.3 系统配置文件"></a>10.3 系统配置文件</h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>/etc/issue</td><td>系统版本</td></tr><tr><td>/etc/hosts</td><td>主机名与 IP 对应关系</td></tr><tr><td>/etc/resolv.conf</td><td>DNS 服务器地址</td></tr><tr><td>/etc/hostname</td><td>主机名</td></tr><tr><td>/etc/sysctl.conf</td><td>系统参数配置文件</td></tr><tr><td>/etc/sudoers</td><td>sudo 权限配置</td></tr><tr><td>/etc/init.d</td><td>服务启动脚本</td></tr><tr><td>/etc/sysconfig/network-scripts</td><td>网卡信息配置目录</td></tr><tr><td>/etc/rc.d/rc.local</td><td>系统 init 初始化完后执行，不建议将启动服务写在这里面，<br> 应创建自己的 systemd 或 udev</td></tr><tr><td>/etc/fstab</td><td>硬盘自动挂载配置</td></tr><tr><td>/etc/inittab</td><td>系统启动运行级别</td></tr><tr><td>/etc/crontab</td><td>系统级任务计划</td></tr><tr><td>/var/spool/cron</td><td>用户级任务计划，此目录下以用户名命名对应每个用户的任务计划</td></tr><tr><td>/etc/cron.d</td><td>描述计算机任务计划</td></tr><tr><td>/etc/hosts.allow</td><td>TCP 包访问列表</td></tr><tr><td>/etc/hosts.deny</td><td>TCP 包拒绝列表</td></tr><tr><td>/usr/share/doc</td><td>各软件的文档</td></tr><tr><td>/etc/sshd_config</td><td>SSH 服务配置文件</td></tr><tr><td>/var/log</td><td>系统和应用程序日志目录</td></tr><tr><td>/var/spool/mail</td><td>邮件目录</td></tr></tbody></table><p>crontab 任务计划说明：</p><pre><code class="hljs bash"><span class="hljs-comment"># Example of job definition:</span><span class="hljs-comment"># .---------------- minute (0 - 59)</span><span class="hljs-comment"># | .------------- hour (0 - 23)</span><span class="hljs-comment"># | | .---------- day of month (1 - 31)</span><span class="hljs-comment"># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...</span><span class="hljs-comment"># | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR</span>sun,mon,tue,wed,thu,fri,sat<span class="hljs-comment"># | | | | |</span><span class="hljs-comment"># * * * * * user-name command to be executed</span></code></pre><h2 id="10-4-dev-目录"><a href="#10-4-dev-目录" class="headerlink" title="10.4 /dev 目录"></a>10.4 /dev 目录</h2><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>/dev</td><td>目录下存放的是一些设备文件。</td></tr><tr><td>/dev/hd[a-t]</td><td>IDE 设备</td></tr><tr><td>/dev/sd[a-z]</td><td>SCSI 设备</td></tr><tr><td>/dev/dm-[-9]</td><td>LVM 逻辑磁盘</td></tr><tr><td>/dev/null</td><td>黑洞</td></tr><tr><td>/dev/zero</td><td>无限 0 数据流</td></tr></tbody></table><h2 id="10-5-proc-目录"><a href="#10-5-proc-目录" class="headerlink" title="10.5 /proc 目录"></a>10.5 /proc 目录</h2><p><code>/proc</code> 是一个虚拟目录，在 Linux 系统启动后生成的，数据存储在内存中，存放内核运行时的参数、网络信息、进程状态等等。</p><h3 id="10-5-1-proc"><a href="#10-5-1-proc" class="headerlink" title="10.5.1 /proc"></a>10.5.1 /proc</h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>/proc/[0-9]+</td><td>此目录下数字命名的目录是运行进程信息，目录名为 PID</td></tr><tr><td>/proc/meminfo</td><td>物理内存、交换空间等信息，free</td></tr><tr><td>/proc/loadavg</td><td>系统负载</td></tr><tr><td>/proc/uptime</td><td>系统运行时间 <br> 计算系统启动时间：<br>date -d “$(awk -F.’{print $1}’/proc/uptime) second ago”<br>+”%Y-%m-%d %H:%M:%S” 或 who -b</td></tr><tr><td>/proc/cpuinfo</td><td>CPU 信息</td></tr><tr><td>/proc/modules</td><td>系统已加载的模块或驱动，lsmod</td></tr><tr><td>/proc/mounts</td><td>文件系统挂载信息，mount</td></tr><tr><td>/proc/swaps</td><td>swap 分区信息</td></tr><tr><td>/proc/partitions</td><td>系统分区信息</td></tr><tr><td>/proc/version</td><td>内核版本</td></tr><tr><td>/proc/stat</td><td>CPU 利用率，磁盘，内存页</td></tr><tr><td>/proc/devices</td><td>可用的设备列表</td></tr></tbody></table><h3 id="10-5-2-proc-net"><a href="#10-5-2-proc-net" class="headerlink" title="10.5.2 /proc/net"></a>10.5.2 /proc/net</h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>/proc/net</td><td>目录存放的是一些网络协议信息。</td></tr><tr><td>/proc/net/tcp</td><td>TCP 状态连接信息，netstat</td></tr><tr><td>/proc/net/udp</td><td>UDP 状态连接信息</td></tr><tr><td>/proc/net/arp</td><td>arp 信息表</td></tr><tr><td>/proc/net/dev</td><td>网卡流量</td></tr><tr><td>/proc/net/snmp</td><td>网络传输协议的收发包信息</td></tr><tr><td>/proc/net/sockstat</td><td>socket 使用情况，比如已使用，正在使用</td></tr><tr><td>/proc/net/netstat</td><td>网络统计数据，netstat -s</td></tr><tr><td>/proc/net/route</td><td>路由表</td></tr></tbody></table><h3 id="10-5-3-proc-sys"><a href="#10-5-3-proc-sys" class="headerlink" title="10.5.3 /proc/sys"></a>10.5.3 /proc/sys</h3><p>这个目录下的文件可被读写，存了大多数内核参数，可以修改改变内核行为。所以修改这些文件要特别小心，修改错误可能导致内核不稳定。</p><p>有四个主要的目录：</p><ul><li>fs # 文件系统各方面信息，包括配额、文件句柄、inode 和目录项。</li><li>kernel # 内核行为的信息</li><li>net # 网络配置信息，包括以太网、ipx、ipv4 和 ipv6。</li><li>vm # Linux 内核的虚拟内存子系统，通常称为交换空间。</li></ul><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>/proc/sys/fs/file-max</td><td>内核分配所有进程最大打开文件句柄数量，可 <br> 适当增加此值</td></tr><tr><td>/proc/sys/fs/file-nr</td><td>只读，第一个值已分配的文件句柄数量，第二 <br> 个值分配没有使用文件句柄数量，第三个值文 &lt; br &gt; 件句柄最大数量。lsof</td></tr><tr><td>/proc/sys/kernel/ctrl-alt-del</td><td>组合键重启计算机，只为 0 同步缓冲区到磁盘，<br>1 为不同步</td></tr><tr><td>/proc/sys/kernel/domainname</td><td>配置系统域名</td></tr><tr><td>/proc/sys/kernel/exec-shield</td><td>配置内核执行保护功能，防止某类型缓冲区溢 <br> 出攻击。 0 为禁用， 1 开启</td></tr><tr><td>/proc/sys/kernel/hostname</td><td>配置系统主机名</td></tr><tr><td>/proc/sys/kernel/osrelease</td><td>内核版本号</td></tr><tr><td>/proc/sys/kernel/ostype</td><td>操作系统类型</td></tr><tr><td>/proc/sys/kernel/shmall</td><td>设置共享内存的总量，以字节为单位</td></tr><tr><td>/proc/sys/kernel/shmmax</td><td>设置最大共享内存段</td></tr><tr><td>/proc/sys/kernel/shmmni</td><td>设置共享内存段最大数量</td></tr><tr><td>/proc/sys/kernel/threads-max</td><td>设置最大允许线程数量</td></tr><tr><td>/proc/sys/kernel/pid_max</td><td>设置最大允许创建的 pid 数量</td></tr><tr><td>/proc/sys/kernel/version</td><td>显示最后一次编译内核时间</td></tr><tr><td>/proc/sys/kernel/random/uuid</td><td>生成 uuid</td></tr><tr><td>/proc/sys/kernel/core_pattern</td><td>控制生成 core dump 文件位置和保存格式</td></tr><tr><td>/proc/sys/net/core/netdev_max_backlog</td><td>设置数据包队列允许最大数量</td></tr><tr><td>/proc/sys/net/core/optmem_max</td><td>设置 socket 允许最大缓冲区大小</td></tr><tr><td>/proc/sys/net/core/somaxconn</td><td>每个端口最大监听队列长度</td></tr><tr><td>/proc/sys/net/core/rmem_default</td><td>设置 socket 接收默认缓冲区大小，单位字节</td></tr><tr><td>/proc/sys/net/core/rmem_max</td><td>设置 socket 接收最大缓冲区大小</td></tr><tr><td>/proc/sys/net/core/wmem_default</td><td>设置 socket 发送默认缓冲区大小</td></tr><tr><td>/proc/sys/net/core/wmem_max</td><td>设置 socket 发送最大缓冲区大小</td></tr><tr><td>/proc/sys/net/ipv4/icmp_echo_ignore_all<br> 和 icmp_echo_ignore_broadcasts</td><td>设置是否忽略 icmp 响应包和广播包， 0 为不忽 &lt; br &gt; 略， 1 为忽略</td></tr><tr><td>/proc/sys/net/ipv4/ip_default_ttl</td><td>设置默认生存时间</td></tr><tr><td>/proc/sys/net/ipv4/ip_forward</td><td>允许系统接口转发数据包，默认 0 为关闭，1 为 <br> 开启</td></tr><tr><td>/proc/sys/net/ipv4/ip_local_port_range</td><td>指定使用本地 TCP 或 UDP 端口范围，第一个值 <br> 最低，第二个值最高</td></tr><tr><td>/proc/sys/net/ipv4/tcp_syn_retries</td><td>限制重新发送 syn 尝试建立连接次数</td></tr><tr><td>/proc/sys/net/ipv4/tcp_synack_retries</td><td>syn ack 确认包尝试次数</td></tr><tr><td>/proc/sys/net/ipv4/tcp_syncookies</td><td>是否启用 syn cookie， 0 为关闭，默认 1 为开 <br> 启</td></tr><tr><td>/proc/sys/net/ipv4/tcp_max_tw_buckets</td><td>系统保持 TIME_WAIT 最大数量</td></tr><tr><td>/proc/sys/net/ipv4/tcp_tw_recycle</td><td>是否启用 TIME_WAIT 快速收回，默认 0 为关闭，<br>1 为开启</td></tr><tr><td>/proc/sys/net/ipv4/tcp_tw_reuse</td><td>是否启用 TIME_WAIT 复用，默认 0 为关闭， 1<br> 为开启</td></tr><tr><td>/proc/sys/net/ipv4/tcp_keepalive_time</td><td>TCP 连接保持时间（默认 ^2 小时），当连接活动，<br> 定时器会重新复位。</td></tr><tr><td>/proc/sys/vm/swappiness</td><td>内核按此值百分比来使用 swap，值越小越不考 <br> 虑使用物理内存， 0 为尽可能不使用 swap</td></tr><tr><td>/proc/sys/vm/overcommit_memory</td><td>控制内存分配，默认 0 为内核先评估可用内存，<br> 如果足够允许申请，否则拒绝， 1 为允许分配 &lt; br &gt; 所有物理内存， 2 为允许分配超过物理内存和 &lt; br &gt; 交换空间总和的内存</td></tr><tr><td>/proc/sys/vm/overcommit_ratio</td><td>指定物理内存比率，当 overcommit_memory=2<br> 时，用户空间进程可使用的内存不超过物理内 &lt; br &gt; 存 * overcommit_ratio+swap</td></tr></tbody></table><p><strong>参考资料：</strong><br><a href="https://access.redhat.com/documentation/en-">https://access.redhat.com/documentation/en-</a><br>US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s2-proc-dir-sys.html</p><h1 id="十一、-Shell-常用命令与工具"><a href="#十一、-Shell-常用命令与工具" class="headerlink" title="十一、 Shell 常用命令与工具"></a>十一、 Shell 常用命令与工具</h1><p>本章节学习一些在编写 Shell 时的常用命令或工具及使用技巧。有人说 Shell 脚本是命令堆积的一个文件，按顺序去执行。还有人说想学好 Shell 脚本，要把 Linux 上各种常见的命令或工具掌握了，这些说法都没错。由于 Shell 语言本身在语法结构上比较简单，是面向过程编程，想实现复杂的功能有点强人所难！而且 Shell 本身又工作在 Linux 内核之上，在用户态调用 Linux 命令会很方面，所以大多数情况下我们都是依靠这些命令来完成脚本中的某些功能，比如文本处理、获取系统状态等等，然后通过 Shell 语法结构组织代码逻辑。不管是学 Linux 系统好还是写 Shell 脚本也好，有些命令都是必须要会的，以下是根据个人经验总结的一些常用的命令。</p><p>怎么更好的学习命令呢？</p><p>当然查看官方帮助文档了，可以通过 man cmd、cmd –help、help cmd、info cmd 等方式查看命令的使用。</p><h2 id="11-1-ls"><a href="#11-1-ls" class="headerlink" title="11.1 ls"></a>11.1 ls</h2><p>功能：列出目录内容</p><p><strong>常用选项：</strong></p><ul><li>-a 显示所有文件，包括隐藏的</li><li>-l 长格式列出信息</li><li>-i 显示文件 inode 号</li><li>-t 按修改时间排序</li><li>-r 按修改时间倒序排序</li><li>-h 打印易读大小单位</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">按修改时间排序：<span class="hljs-comment"># ls - t</span>按修改时间倒序排序：<span class="hljs-comment"># ls - rt</span>长格式列出：<span class="hljs-comment"># ls - lh</span>查看文件 inode：<span class="hljs-comment"># ls - i file</span></code></pre><h2 id="11-2-echo"><a href="#11-2-echo" class="headerlink" title="11.2 echo"></a>11.2 echo</h2><p>功能：打印一行</p><p><strong>常用选项：</strong></p><ul><li>-n 不加换行符</li><li>-e 解释转义符</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">解释换行符：<span class="hljs-comment"># echo - e &quot;1\n2\n3&quot;</span>123</code></pre><h2 id="11-3-printf"><a href="#11-3-printf" class="headerlink" title="11.3 printf"></a>11.3 printf</h2><p>功能：格式化打印数据。默认打印字符串不换行。</p><p><strong>格式</strong>：printf format [arguments]</p><table><thead><tr><th>Format</th><th>描述</th></tr></thead><tbody><tr><td>%s</td><td>一个字符串</td></tr><tr><td>%d，%i</td><td>一个小数</td></tr><tr><td>%f</td><td>一个浮点数</td></tr><tr><td>%.ns</td><td>输出字符串，n 是输出几个字符</td></tr><tr><td>%m.nf</td><td>输出浮点数，m 是输出整数位数，n 是输出的小数位数</td></tr><tr><td>%x</td><td>不带正负号的十六进制，使用 a 至 f 表示 10 到 15</td></tr><tr><td>%X</td><td>不带正负号的十六进制，使用 A 至 F 表示 10 至 15</td></tr><tr><td>%%</td><td>输出单个 %</td></tr><tr><td>%-5s</td><td>左对齐，对参数每个字段左对齐, 宽度为 5</td></tr><tr><td>%-4.2f</td><td>左对齐，宽度为 4 ，保留两位小数</td></tr><tr><td>%5s</td><td>右对齐，不加横线表示右对齐</td></tr></tbody></table><p>一些常用的空白符：</p><ul><li>\n 换行</li><li>\r 回车</li><li>\t 水平制表符</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">输出一个字符：<span class="hljs-comment"># printf &quot;%.1s&quot; abc</span>a保留一个小数点：<span class="hljs-comment"># printf &quot;%.1f&quot; 1.333</span>1.3输出换行：<span class="hljs-comment"># printf &quot;%.1f\n&quot; 1.333</span>1.3格式化输出：<span class="hljs-comment"># printf &quot;user: %s\tpass: %d\n&quot; abc 123</span>user: abc pass: 1左对齐宽度 10 ：<span class="hljs-comment"># printf &quot;%-10s %-10s %-10s\n&quot; ID Name Number</span>ID Name Number右对齐宽度 10 ：<span class="hljs-comment"># printf &quot;%10s %10s %10s\n&quot; ID Name Number</span>ID Name Number每段对齐：<span class="hljs-comment"># printf &quot;%10s\n&quot; ID Name Number</span>IDNameNumber<span class="hljs-comment"># printf &quot;%-10s\n&quot; ID Name Number</span>IDNameNumber</code></pre><h2 id="11-4-cat"><a href="#11-4-cat" class="headerlink" title="11.4 cat"></a>11.4 cat</h2><p>功能：连接文件和标准输出打印</p><p><strong>常用选项：</strong></p><ul><li>-b 显示非空行行号</li><li>-n 显示所有行行号</li><li>-T 显示 tab，用 ^I 表示</li><li>-E 显示以 $ 结尾</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">连接两个文件：<span class="hljs-comment"># cat a b</span><span class="hljs-comment"># cat &lt;&lt; EOF</span>&gt; 123&gt; abc&gt; EOF123abc将 eof 标准输入作为 cat 标准输出再写到 a.txt：<span class="hljs-comment"># cat &gt; a.txt &lt;&lt; eof</span>&gt; 123&gt; abc&gt; eof</code></pre><h2 id="11-5-tac"><a href="#11-5-tac" class="headerlink" title="11.5 tac"></a>11.5 tac</h2><p>功能：连接文件和倒序打印文件</p><p><strong>示例：</strong></p><pre><code class="hljs bash">倒序打印每一行：<span class="hljs-comment"># tac a.txt</span></code></pre><h2 id="11-6-rev"><a href="#11-6-rev" class="headerlink" title="11.6 rev"></a>11.6 rev</h2><p>功能：反向打印每一行</p><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;123&quot; |rev</span>321</code></pre><h2 id="11-7-wc"><a href="#11-7-wc" class="headerlink" title="11.7 wc"></a>11.7 wc</h2><p>功能：统计文件行数、字节、字符数</p><p><strong>常用选项：</strong></p><ul><li>-c 打印文件字节数，一个英文字母 1 字节，一个汉字占 2 - 4 字节（根据编码）</li><li>-m 打印文件字符数，一个汉字占 2 个字符</li><li>-l 打印多少行</li><li>-L 打印最长行的长度，也可以统计字符串长度</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">统计文件多少行：<span class="hljs-comment"># wc - l file</span>统计字符串长度：<span class="hljs-comment"># echo &quot;hello&quot; |wc - L</span>5</code></pre><h2 id="11-8-cp"><a href="#11-8-cp" class="headerlink" title="11.8 cp"></a>11.8 cp</h2><p>功能：复制文件或目录</p><p><strong>常用选项：</strong></p><ul><li>-a 归档</li><li>-b 目标文件存在创建备份，备份文件是文件名跟~</li><li>-f 强制复制文件或目录</li><li>-r 递归复制目录</li><li>-p 保留原有文件或目录属性</li><li>-i 覆盖文件之前先询问用户</li><li>-u 当源文件比目的文件修改时间新时才复制</li><li>-v 显示复制信息</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">复制目录：<span class="hljs-comment"># cp - rf test /opt</span></code></pre><h2 id="11-9-mkdir"><a href="#11-9-mkdir" class="headerlink" title="11.9 mkdir"></a>11.9 mkdir</h2><p>功能：创建目录</p><p><strong>常用选项：</strong></p><ul><li>-p 递归创建目录</li><li>-v 显示创建过程</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">创建多级目录：<span class="hljs-comment"># mkdir /opt/test/abc</span>创建多个目录：<span class="hljs-comment"># mkdir &#123;install,tmp&#125;</span>创建连续目录：<span class="hljs-comment"># mkdir &#123;a..c&#125;</span></code></pre><h2 id="11-10-mv"><a href="#11-10-mv" class="headerlink" title="11.10 mv"></a>11.10 mv</h2><p>功能：移动文件或重命名</p><p><strong>常用选项：</strong></p><ul><li>-b 目标文件存在创建备份，备份文件是 “文件名后跟~”</li><li>-u 当源文件比目的文件修改时间新时才移动</li><li>-v 显示移动信息</li></ul><p>示例：</p><pre><code class="hljs bash">移动文件：<span class="hljs-comment"># mv a.txt /opt</span>重命名文件：<span class="hljs-comment"># mv a.txt b.txt</span></code></pre><h2 id="11-11-rename"><a href="#11-11-rename" class="headerlink" title="11.11 rename"></a>11.11 rename</h2><p>功能：重命名文件，支持通配符</p><p><strong>示例：</strong></p><pre><code class="hljs bash">批量命名文件将 foo1-foo9 替换为 foo01-foo09：<span class="hljs-comment"># rename foo foo0 foo?</span>将以. htm 后缀的文件替换为. html：<span class="hljs-comment"># rename .htm .html *.htm</span></code></pre><h2 id="11-12-dirname"><a href="#11-12-dirname" class="headerlink" title="11.12 dirname"></a>11.12 dirname</h2><p>功能：去除路径的最后一个名字</p><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># dirname /usr/bin/</span>/usr<span class="hljs-comment"># dirname dir1/str dir2/str</span>dir1dir2<span class="hljs-comment"># dirname stdio.h</span></code></pre><h2 id="11-13-basename"><a href="#11-13-basename" class="headerlink" title="11.13 basename"></a>11.13 basename</h2><p>功能：打印路径的最后一个名字</p><p><strong>常用选项：</strong></p><ul><li>-a 支持多个参数</li><li>-s 删除后面的后缀</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># basename /usr/bin/sort</span>sort<span class="hljs-comment"># basename include/stdio.h .h</span>stdio<span class="hljs-comment"># basename -s .h include/stdio.h</span>stdio<span class="hljs-comment"># basename -a any/str1 any/str2</span>str1str2</code></pre><h2 id="11-14-du"><a href="#11-14-du" class="headerlink" title="11.14 du"></a>11.14 du</h2><p>功能：估算文件磁盘空间使用</p><p><strong>常用选项：</strong></p><ul><li>-h 易读格式显示（K，M，G）</li><li>-b 单位 bytes 显示</li><li>-k 单位 KB 显示</li><li>-m 单位 MB 显示</li><li>-s 只显示总大小</li><li>–max-depth=&lt;目录层数&gt;，超过层数的目录忽略</li><li>–exclude=file 排除文件或目录</li><li>–time 显示大小和创建时间</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">查看目录大小：<span class="hljs-comment"># du -sh /opt</span>排除目录某个文件：<span class="hljs-comment"># du -sh --exclude=test /opt</span></code></pre><h2 id="11-15-cut"><a href="#11-15-cut" class="headerlink" title="11.15 cut"></a>11.15 cut</h2><p>功能：选取文件的每一行数据</p><p><strong>常用选项：</strong></p><ul><li>-b 选中第几个字符</li><li>-c 选中多少个字符</li><li>-d 指定分隔符分字段，默认是空格</li><li>-f 显示选中字段</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">打印 b 字符：<span class="hljs-comment"># echo &quot;abc&quot; |cut - b &quot;2&quot;</span>b截取 abc 字符：<span class="hljs-comment"># echo &quot;abcdef&quot; |cut - c 1 - 3</span>abc以冒号分隔，显示第二个字段：<span class="hljs-comment"># echo &quot;a:b:c&quot; |cut - d: - f2</span>b</code></pre><h2 id="11-16-tr"><a href="#11-16-tr" class="headerlink" title="11.16 tr"></a>11.16 tr</h2><p>功能：替换或删除字符</p><p><strong>格式：</strong>Usage: tr [OPTION]… SET1 [SET2]</p><p><strong>常用选项：</strong></p><ul><li>-c 替换 SET1 没有 SET2 的字符</li><li>-d 删除 SET1 中字符</li><li>-s 压缩 SET1 中重复的字符</li><li>-t 将 SET1 用 SET2 转换，默认</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">替换 SET1 没有 SET2 的字符：<span class="hljs-comment"># echo &quot;aaabbbccc&quot; | tr -c c 1</span>111111ccc去重字符：<span class="hljs-comment"># echo &quot;aaacccddd&quot; | tr -s &#x27;[a-z]&#x27;</span>acd删除字符：<span class="hljs-comment"># echo &quot;aaabbbccc&quot; | tr -d bbb</span>aaaccc删除换行符：<span class="hljs-comment"># echo -e &quot;a\nb\nc&quot; | tr -d &#x27;\n&#x27;</span>abc替换字符：<span class="hljs-comment"># echo &quot;aaabbbccc&quot; | tr &#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;</span>AAABBBCCC</code></pre><h2 id="11-17-stat"><a href="#11-17-stat" class="headerlink" title="11.17 stat"></a>11.17 stat</h2><p>功能：显示文件或文件的系统状态</p><p><strong>常用选项：</strong></p><ul><li>-Z 显示 selinux 安全上下文</li><li>-f 显示文件系统状态</li><li>-c 指定格式输出内容</li><li>-t 以简洁的形式打印</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">显示文件信息：<span class="hljs-comment"># stat file</span>只显示文件修改时间：<span class="hljs-comment"># stat -c %y file</span></code></pre><h2 id="11-18-seq"><a href="#11-18-seq" class="headerlink" title="11.18 seq"></a>11.18 seq</h2><p>功能：打印序列化数字</p><p><strong>常用选项：</strong></p><ul><li>f 使用 printf 样式格式</li><li>s 指定换行符，默认是 \ n</li><li>w 等宽，用 0 填充</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">数字序列：<span class="hljs-comment"># seq 3</span>123带 0 的数字序列：<span class="hljs-comment"># seq - w 03</span>010203范围数字序列：<span class="hljs-comment"># seq 2 5</span>2345步长序列：<span class="hljs-comment"># seq 1 2 5 # 2 是步长</span>135以冒号分隔序列：<span class="hljs-comment"># seq -s &quot;+&quot; 5</span>1+2+3+4+5等宽并在数字前面加字符串：<span class="hljs-comment"># seq -f &quot;str%02g&quot; 3 # %g 是默认数字位数， 02 是数字不足 2 位时用 0 填充。</span>str01str02str03</code></pre><h2 id="11-19-shuf"><a href="#11-19-shuf" class="headerlink" title="11.19 shuf"></a>11.19 shuf</h2><p>功能：生成随机序列</p><p><strong>常用选项：</strong></p><ul><li>-i 输出数字范围</li><li>-o 结果写入文件</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">输出范围随机数：<span class="hljs-comment"># seq 5 |shuf</span>21543<span class="hljs-comment"># shuf -i 5-10</span>8107965</code></pre><h2 id="11-20-sort"><a href="#11-20-sort" class="headerlink" title="11.20 sort"></a>11.20 sort</h2><p>功能：排序文本，默认对整列有效</p><p><strong>常用选项：</strong></p><ul><li>-f 忽略字母大小写</li><li>-M 根据月份比较，比如 JAN、DEC</li><li>-h 根据易读的单位大小比较，比如 2K、1G</li><li>-g 按照常规数值排序</li><li>-n 根据字符串数值比较</li><li>-r 倒序排序</li><li>-k 位置 1, 位置 2 根据关键字排序，在从第位置 1 开始，位置 2 结束</li><li>t 指定分隔符</li><li>u 去重重复行</li><li>o 将结果写入文件</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">随机数字排序：<span class="hljs-comment"># seq 5 |shuf |sort</span>随机字母排序：<span class="hljs-comment"># printf &quot;%c\n&quot; &#123;a..f&#125; |shuf |sort</span>倒序排序：<span class="hljs-comment"># seq 5 |shuf |sort - r</span>分隔后的字段排序：<span class="hljs-comment"># cat /etc/passwd |sort -t : -k 3 -n</span>去重重复行：<span class="hljs-comment"># echo -e &quot;1\n1\n2\n3\n3&quot; |sort -u</span>大小单位排序：<span class="hljs-comment"># du -h |sort -k 1 -h -r</span>分隔后第一个字段的第二个字符排序：<span class="hljs-comment"># echo -e &quot;fa:1\neb:2\ncc:3&quot; |sort -t : -k 1.2</span>tab 作为分隔符：<span class="hljs-comment"># sort -t $&quot;\t&quot;</span>file 文件内容：zhangsan 6 100lisi 8 80wangwu 7 90zhaoliu 9 70对 file 文件的第二列正序排序，再次基础再对第三列倒序排序（多列排序）：<span class="hljs-comment"># sort -k 2,2 -n -k 3,3 -nr file</span><span class="hljs-comment"># sort -k 2 -n -k 3 -nr file</span>zhaoliu 9 70lisi 8 80wangwu 7 90zhangsan 6 100对两个文件同时排序：<span class="hljs-comment"># sort file1 file2</span></code></pre><h2 id="11-21-uniq"><a href="#11-21-uniq" class="headerlink" title="11.21 uniq"></a>11.21 uniq</h2><p>功能：去除重复行, 只会统计相邻的</p><p><strong>常用选项：</strong></p><ul><li>-c 打印出现的次数</li><li>-d 只打印重复行</li><li>-u 只打印不重复行</li><li>-D 只打印重复行，并且把所有重复行打印出来</li><li>-f N 比较时跳过前 N 列</li><li>-i 忽略大小写</li><li>-s N 比较时跳过前 N 个字符</li><li>-w N 对每行第 N 个字符以后内容不做比较</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">测试文本如下：<span class="hljs-comment"># cat file</span>abccdexyzcdexyzabd去重复行：<span class="hljs-comment"># sort file |uniq</span>abcabdcdexyz打印每行重复次数：<span class="hljs-comment"># sort file |uniq -c</span>1 abc1 abd2 cde2 xyz打印不重复行：<span class="hljs-comment"># sort file |uniq -u</span>abcabd打印重复行：<span class="hljs-comment"># sort file |uniq -d</span>cdexyz打印重复行并统计出现次数：<span class="hljs-comment"># sort file |uniq -d -c</span>2 cde2 xyz根据前几个字符去重：<span class="hljs-comment"># sort file |uniq -w 2</span>abccdexyz</code></pre><h2 id="11-22-tee"><a href="#11-22-tee" class="headerlink" title="11.22 tee"></a>11.22 tee</h2><p>功能：从标准输入读取写到标准输出和文件</p><p><strong>常用选项：</strong></p><ul><li>-a 追加到文件</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">打印并追加到文件：<span class="hljs-comment"># echo 123 |tee -a a.log</span></code></pre><h2 id="11-23-join"><a href="#11-23-join" class="headerlink" title="11.23 join"></a>11.23 join</h2><p>功能：连接两个文件</p><p><strong>常用选项：</strong></p><ul><li>-i 忽略大小写</li><li>-o 按照指定文件栏位显示</li><li>-t 使用字符作为输入和输出字段分隔符</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># cat file1</span>1 a2 b3 c<span class="hljs-comment"># cat file2</span>1 x2 y3 z将两个文件相同字段合并一列：<span class="hljs-comment"># join file1 file2</span>1 a x2 b y3 c z打印 file1 第二列和 file2 第二列：<span class="hljs-comment"># join -o 1.2 2.2 file1 file2</span>a xb yc z<span class="hljs-comment"># join -t &#x27;:&#x27; -o 1.1 2.1 /etc/passwd /etc/shadow</span>user1:user1</code></pre><h2 id="11-24-paste"><a href="#11-24-paste" class="headerlink" title="11.24 paste"></a>11.24 paste</h2><p>功能：合并文件</p><p><strong>常用选项：</strong></p><ul><li>-d 指定分隔符，默认是 tab 键分隔</li><li>-s 将文件内容平行合并，默认 tab 键分隔</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># seq 1 3 &gt; file1</span><span class="hljs-comment"># seq 4 6 &gt; file2</span>两个文件合并：<span class="hljs-comment"># paste file1 file2</span>1 42 53 6两个文件合并，+ 号分隔：<span class="hljs-comment"># paste -d &quot;+&quot; file1 file2</span>1+42+53+6文件内容平行显示：<span class="hljs-comment"># paste -s file1 file2</span>1 2 34 5 6</code></pre><h2 id="11-25-head"><a href="#11-25-head" class="headerlink" title="11.25 head"></a>11.25 head</h2><p>功能：输出文件的前几行</p><p><strong>常用选项：</strong></p><ul><li>-c 打印前多少 K，M</li><li>-n 打印前多少行</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">打印文件前 50 行：<span class="hljs-comment"># head -n 50 file</span></code></pre><h2 id="11-26-tail"><a href="#11-26-tail" class="headerlink" title="11.26 tail"></a>11.26 tail</h2><p>功能：输出文件的后几行</p><p><strong>常用选项：</strong></p><ul><li>-c 打印后多少 K，M</li><li>-f 实时读文件，随着文件输出附加输出</li><li>-n 输出最后几行</li><li>–pid 与 - f 一起使用，表示 pid 死掉后结束</li><li>-s 与 - f 一起使用，表示休眠多少秒输出</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">打印文件后 50 行：<span class="hljs-comment"># tail -n 50 file</span>实时输出新增行：<span class="hljs-comment"># tail -f file</span></code></pre><h2 id="11-27-find"><a href="#11-27-find" class="headerlink" title="11.27 find"></a>11.27 find</h2><p>功能：目录层次结构中搜索文件</p><p>格式：find path -option actions</p><p><strong>常用选项：</strong></p><ul><li>-name 文件名，支持 (‘*’, ‘?’)</li><li>-type 文件类型，d 目录，f 常规文件等</li><li>-perm 符合权限的文件，比如 755</li><li>-atime -/+n 在 n 天以内 / 过去 n 天被访问过</li><li>-ctime -/+n 在 n 天以内 / 过去 n 天被修改过</li><li>-amin -/+n 在 n 天以内 / 过去 n 分钟被访问过</li><li>-cmin -/+n 在 n 天以内 / 过去 n 分钟被修改过</li><li>-size -/+n 文件大小小于 / 大于，b、k、M、G</li><li>-maxdepth levels 目录层次显示的最大深度</li><li>-regex pattern 文件名匹配正则表达式模式</li><li>-inum 通过 inode 编号查找文件</li></ul><p><strong>动作：</strong></p><ul><li>-detele 删除文件</li><li>-exec command {} ; 执行命令，花括号代表当前文件</li><li>-ls 列出当前文件，ls -dils 格式</li><li>-print 完整的文件名并添加一个回车换行符</li><li>-print0 打印完整的文件名并不添加一个回车换行符</li><li>-printf format 打印格式</li></ul><p><strong>其他字符：</strong><br>！ 取反</p><ul><li>-or/-o 逻辑或</li><li>-and 逻辑和</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">查找文件名：<span class="hljs-comment"># find / -name &quot;*http*&quot;</span>查找文件名并且文件类型：<span class="hljs-comment"># find /tmp -name core -type f -print</span>查找文件名并且文件类型删除：<span class="hljs-comment"># find /tmp -name core -type f -delete</span>查找当前目录常规文件并查看文件类型：<span class="hljs-comment"># find. -type f -exec file &#x27;&#123;&#125;&#x27; \;</span>查找文件权限是 664 ：<span class="hljs-comment"># find. -perm 664</span>查找大于 1024k 的文件：<span class="hljs-comment"># find. -size -1024k</span>查找 3 天内修改的文件：<span class="hljs-comment"># find /bin -ctime -3</span>查找 3 分钟前修改的文件：<span class="hljs-comment"># find /bin -cmin +3</span>排除多个类型的文件：<span class="hljs-comment"># find.! -name &quot;*.sql&quot;! -name &quot;*.txt&quot;</span>或条件查找多个类型的文件：<span class="hljs-comment"># find. -name &#x27;*.sh&#x27; -o -name &#x27;*.bak&#x27;</span><span class="hljs-comment"># find. -regex &quot;.*\.sh\|.*\.bak&quot;</span><span class="hljs-comment"># find. -regex &quot;.*\.\(sh\|bak\)&quot;</span>并且条件查找文件：<span class="hljs-comment"># find. -name &quot;*.sql&quot; -a -size +1024k</span>只显示第一级目录：<span class="hljs-comment"># find /etc -type d -maxdepth 1</span>通过 inode 编号删除文件：<span class="hljs-comment"># rm `find. -inum 671915`</span><span class="hljs-comment"># find. -inum 8651577 -exec rm -i &#123;&#125; \;</span></code></pre><h2 id="11-28-xargs"><a href="#11-28-xargs" class="headerlink" title="11.28 xargs"></a>11.28 xargs</h2><p>功能：从标准输入执行命令</p><p><strong>常用选项：</strong></p><ul><li>-a file 从指定文件读取数据作为标准输入</li><li>-0 处理包含空格的文件名, print0</li><li>-d delimiter 分隔符，默认是空格分隔显示</li><li>-i 标准输入的结果以 {} 代替</li><li>-I 标准输入的结果以指定的名字代替</li><li>-t 显示执行命令</li><li>-p 交互式提示是否执行命令</li><li>-n 最大命令行参数</li><li>–show-limits 查看系统命令行长度限制</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">删除 / tmp 下名字是 core 的文件：<span class="hljs-comment"># find /tmp -name core -type f -print | xargs /bin/rm -f</span><span class="hljs-comment"># find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f</span>列转行（去除换行符 ）：<span class="hljs-comment"># cut -d: -f1 &lt; /etc/passwd | sort | xargs echo</span>行转列：<span class="hljs-comment"># echo &quot;1 2 3 4 5&quot; |xargs -n1</span>最长两列显示：<span class="hljs-comment"># echo &quot;1 2 3 4 5&quot; |xargs -n2</span>创建未来十天时间：<span class="hljs-comment"># seq 1 10 |xargs -i date -d &quot;&#123;&#125; days&quot; +%Y-%m-%d</span>复制多个目录：<span class="hljs-comment"># echo dir1 dir2 |xargs -n1 cp a.txt</span>清空所有日志：<span class="hljs-comment"># find ./ -name &quot;*.log&quot; |xargs -i tee &#123;&#125; # echo &quot;&quot;&gt; &#123;&#125; 这样不行，&gt; 把命令中断了</span>rm 在删除大量的文件时，会提示参数过长，那么可以使用 xargs 删除：<span class="hljs-comment"># ls |xargs rm –rf</span>或分配删除 rm [a-n]* -rf <span class="hljs-comment"># getconf ARG_MAX 获取系统最大参数限制</span></code></pre><h2 id="11-29-nl"><a href="#11-29-nl" class="headerlink" title="11.29 nl"></a>11.29 nl</h2><p>功能：打印文件行号</p><p><strong>常用选项：</strong></p><ul><li>-b &lt;a|t&gt; 指定行号显示方式，a 表示所有行都打印行号，b 表示空行不显示行号，默认是 a</li><li>-n &lt;ln|rn|rz&gt; 行号显示方法，ln 左对齐，rn 右对齐，rz 右边显示，左边空白用 0 填充。</li><li>-w 行号栏位在左边占用的宽度</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">打印行号，空行不显示：<span class="hljs-comment"># nl a.txt</span>左对齐打印行号：<span class="hljs-comment"># nl -n ln a.txt</span>行号右移动五个空格：<span class="hljs-comment"># nl -w 5 a.txt</span></code></pre><h2 id="11-30-date"><a href="#11-30-date" class="headerlink" title="11.30 date"></a>11.30 date</h2><p>功能：打印或设置系统日期和时间</p><p><strong>常用选项：</strong></p><ul><li>-d string 显示指定字符串所描述的时间，而非当前时间</li><li>-f datefile 从日期文件中按行读入时间描述</li><li>-I 输出 ISO 8601 格式的日期和时间</li><li>-r 显示文件的最后修改时间</li><li>-R 输出 RFC 2822 格式的日期和时间</li><li>-s string 设置时间所描述的字符串</li><li>-u 打印或设置 UTC 时间</li></ul><p><strong>控制输出格式：</strong></p><ul><li>%% 一个文字的 %</li><li>%a 当前 locale 的星期名缩写 (例如： 日，代表星期日)</li><li>%A 当前 locale 的星期名全称 (如：星期日)</li><li>%b 当前 locale 的月名缩写 (如：一，代表一月)</li><li>%B 当前 locale 的月名全称 (如：一月)</li><li>%c 当前 locale 的日期和时间 (如： 2005 年 3 月 3 日 星期四 23:05:25)</li><li>%C 世纪；比如 %Y，通常为省略当前年份的后两位数字 (例如：20)</li><li>%d 按月计的日期 (例如：01)</li><li>%D 按月计的日期；等于 %m/%d/%y</li><li>%e 按月计的日期，添加空格，等于 %_d</li><li>%F 完整日期格式，等价于 %Y-%m-%d</li><li>%g ISO- 8601 格式年份的最后两位 (参见 %G)</li><li>%G ISO- 8601 格式年份 (参见 %V)，一般只和 %V 结合使用</li><li>%h 等于 %b</li><li>%H 小时 (00-23)</li><li>%I 小时 (00-12)</li><li>%j 按年计的日期 (001-366)</li><li>%k 时 (0-23)</li><li>%l 时 (1-12)</li><li>%m 月份 (01-12)</li><li>%M 分 (00-59)</li><li>%n 换行</li><li>%N 纳秒 (000000000-999999999)</li><li>%p 当前 locale 下的 “上午” 或者 “下午”，未知时输出为空</li><li>%P 与 %p 类似，但是输出小写字母</li><li>%r 当前 locale 下的 12 小时时钟时间 (如：11:11:04 下午)</li><li>%R 24 小时时间的时和分，等价于 %H:%M</li><li>%s 自 UTC 时间 1970 - 01 - 01 00:00:00 以来所经过的秒数</li><li>%S 秒 (00-60)</li><li>%t 输出制表符 Tab</li><li>%T 时间，等于 %H:%M:%S</li><li>%u 星期， 1 代表星期一</li><li>%U 一年中的第几周，以周日为每星期第一天 (00-53)</li><li>%V ISO- 8601 格式规范下的一年中第几周，以周一为每星期第一天 (01-53)</li><li>%w 一星期中的第几日 (0-6)， 0 代表周一</li><li>%W 一年中的第几周，以周一为每星期第一天 (00-53)</li><li>%x 当前 locale 下的日期描述 (如：12/31/99)</li><li>%X 当前 locale 下的时间描述 (如：23:13:48)</li><li>%y 年份最后两位数位 (00-99)</li><li>%Y 年份</li></ul><pre><code class="hljs bash">设置系统日期和时间：<span class="hljs-comment"># date -s &quot;2016-12-15 00:00:00&quot;</span>查看当前系统时间戳：<span class="hljs-comment"># date +%s</span>查看当前系统时间：<span class="hljs-comment"># date +&#x27;%F %T&#x27;</span>把日期和时间转换成时间戳：<span class="hljs-comment"># date -d &quot;2016-12 -15 18:00:00&quot; +%s</span>把时间戳转成时间：<span class="hljs-comment"># date -d &#x27;@1481842800&#x27; &#x27;+%F %T&#x27;</span>时间加减：显示前 30 秒：date -d <span class="hljs-string">&#x27;- 30 second&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>显示前一分钟：date -d <span class="hljs-string">&#x27;- 1 minute&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>显示前一个时间：date -d <span class="hljs-string">&#x27;- 1 hour&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>显示前一个天：date -d <span class="hljs-string">&#x27;- 1 day&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>显示上一周：date -d <span class="hljs-string">&#x27;- 1 week&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>显示上一个月日期：date -d <span class="hljs-string">&#x27;- 1 month&#x27;</span> +%F显示上一年日期：date -d <span class="hljs-string">&#x27;- 1 year&#x27;</span> +%F或显示前一天日期：date -d yesterday +%F显示后一天日期：date -d tomorrow +%F时间比较：NOW_DATE=$(date +%s)AGO_DATE=$(date -d <span class="hljs-string">&quot;2016-12-15 18:00:00&quot;</span> +%s)[<span class="hljs-variable">$NOW_DATE</span> -gt <span class="hljs-variable">$AGO_DATE</span>] &amp;&amp; <span class="hljs-built_in">echo</span> yes || <span class="hljs-built_in">echo</span> no</code></pre><h2 id="11-31-wget"><a href="#11-31-wget" class="headerlink" title="11.31 wget"></a>11.31 wget</h2><p>功能：非交互式网络下载，类似于 HTTP 客户端</p><p><strong>常用选项：</strong></p><ul><li>-b, –background 后台运行<br>日志记录和输入文件：</li><li>-o, –output-file=FILE 日志写到文件</li><li>-a, –append-output=FILE 日志追加到文件</li><li>-d, –debug 打印 debug 信息，会包含头信息</li><li>-q, –quiet 退出，不输出</li><li>-i, –input-file=FILE 从文件中读取 URL 下载</li></ul><p><strong>下载选项：</strong></p><ul><li>-t, –tries=NUMBER 设置链接重试次数</li><li>-O, –output-document=FILE 写入内容到文件</li><li>-nc, –no-clobber 跳过下载现有的文件</li><li>-c, –continue 断点续传</li><li>–progress=TYPE 设置进度条（dot 和 bar）</li><li>-S, –server-response 打印服务器响应头信息</li><li>–spider 不下载任何内容</li><li>-T, –timeout=SECONDS 设置相应超时时间（还有 –dns-timeout、–connect-timeout 和</li><li>–read-timeout）</li><li>-w, –wait=SECONDS 两次重试间隔等待时间</li><li>–bind-address=ADDRESS 设置绑定地址</li><li>–limit-rate=RATE 限制下载速度</li><li>–user=USER 设置 ftp 和 http 用户名</li><li>–password=PASS 设置 ftp 和 http 密码</li></ul><p><strong>目录：</strong></p><ul><li>-P, –directory-prefix=PREFIX 保存文件目录<br>HTTP 选项：</li><li>–http-user=USER 设置 http 用户名</li><li>–http-password=PASS 设置 http 密码</li><li>–proxy-user=USER 设置代理用户名</li><li>–proxy-password=PASS 设置代理密码</li><li>–referer=URL 设置 Referer</li><li>–save-headers 保存头到文件</li><li>–default-page=NAME 改变默认页面名字，默认 index.html</li><li>-U,–user-agent=AGENT 设置客户端信息</li><li>–no-http-keep-alive 禁用 HTTP keep-alive（长连接）</li><li>–load-cookies=FILE 从文件加载 cookies</li><li>–save-cookies=FILE 保存 cookies 到文件</li><li>–post-data=STRING 使用 POST 方法，发送数据</li></ul><p><strong>FTP 选项：</strong></p><ul><li>–ftp-user=USER 设置 ftp 用户名</li><li>–ftp-password=PASS 设置 ftp 密码</li><li>–no-passive-ftp 禁用被动传输模式</li></ul><p><strong>递归下载：</strong></p><ul><li>-r, –recursive 指定递归下载</li><li>-l, –level=NUMBER 最大递归深度</li><li>-A, –accept=LIST 逗号分隔下载的扩展列表</li><li>-R, –reject=LIST 逗号分隔不被下载的扩展列表</li><li>-D, –domains=LIST 逗号分隔被下载域的列表</li><li>–exclude-domains=LIST 排除不被下载域的列表</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">下载单个文件到当前目录：<span class="hljs-comment"># wget http://nginx.org/download/nginx-1.11.7.tar.gz</span>放到后台下载：<span class="hljs-comment"># wget -b http://nginx.org/download/nginx-1.11.7.tar.gz</span>对于网络不稳定的用户使用 - c 和 --tries 参数，保证下载完成，并下载到指定目录：<span class="hljs-comment"># wget -t 3 -c http://nginx.org/download/nginx-1.11.7.tar.gz -P down</span>不下载任何内容，判断 URL 是否可以访问：<span class="hljs-comment"># wget --spider http://nginx.org/download/nginx-1.11.7.tar.gz</span>下载内容写到文件：<span class="hljs-comment"># wget http://www.baidu.com/index.html -O index.html</span>从文件中读取 URL 下载：<span class="hljs-comment"># wget -i url.list</span>下载 ftp 文件：<span class="hljs-comment"># wget --ftp-user=admin --ftp-password=admin ftp://192.168.1.10/ISO/CentOS-6.5-i386-minimal.iso</span>伪装客户端，指定 user-agent 和 referer 下载：<span class="hljs-comment"># wget -U &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/44.0.2403.157 Safari/537.36&quot; --referer &quot;http://nginx.org/en/download.html&quot;http://nginx.org/download/nginx-1.11.7.tar.gz</span>查看 HTTP 头信息：<span class="hljs-comment"># wget -S http://nginx.org/download/nginx-1.11.7.tar.gz</span><span class="hljs-comment"># wget --debug http://nginx.org/download/nginx-1.11.7.tar.gz</span></code></pre><h2 id="11-32-curl"><a href="#11-32-curl" class="headerlink" title="11.32 curl"></a>11.32 curl</h2><p>功能：发送数据到 URL，类似于 HTTP 客户端</p><p><strong>常用选项：</strong></p><ul><li>-k, –insecure 允许 HTTPS 连接网站</li><li>-C, –continue-at 断点续传</li><li>-b, –cookie STRING/FILE 从文件中读取 cookie</li><li>-c, –cookie-jar 把 cookie 保存到文件</li><li>-d, –data 使用 POST 方式发送数据</li><li>–data-urlencode POST 的数据 URL 编码</li><li>-F, –form 指定 POST 数据的表单</li><li>-D, –dump-header 保存头信息到文件</li><li>–ftp-pasv 指定 FTP 连接模式 PASV/EPSV</li><li>-P, –ftp-port 指定 FTP 端口</li><li>-L, –location 遵循 URL 重定向，默认不处理</li><li>-l, –list-only 指列出 FTP 目录名</li><li>-H, –header 自定义头信息发送给服务器</li><li>-I, –head 查看 HTTP 头信息</li><li>-o, –output FILE 输出到文件</li><li>-#, –progress-bar 显示 bar 进度条</li><li>-x, –proxy [PROTOCOL://]HOST[:PORT] 使用代理</li><li>-U, –proxy-user USER[:PASSWORD] 代理用户名和密码</li><li>-e, –referer 指定引用地址 referer</li><li>-O, –remote-name 使用远程服务器上名字写到本地</li><li>–connect-timeout 连接超时时间，单位秒</li><li>–retry NUM 连接重试次数</li><li>–retry-delay 两次重试间隔等待时间</li><li>-s, –silent 静默模式，不输出任何内容</li><li>-Y, –speed-limit 限制下载速率</li><li>-u, –user USER[:PASSWORD] 指定 http 和 ftp 用户名和密码</li><li>-T, –upload-file 上传文件</li><li>-A, –user-agent 指定客户端信息</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">下载页面：<span class="hljs-comment"># curl -o badu.html http://www.baidu.com</span>不输出下载信息：<span class="hljs-comment"># curl -s -o baidu.html http://www.baidu.com</span>伪装客户端，指定 user-agent 和 referer 下载：<span class="hljs-comment"># curl -A &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/44.0.2403.157 Safari/537.36&quot; - e &quot;baike.baidu.com&quot; http://127.0.0.1</span>模拟用户登录，并保存 cookies 到文件：<span class="hljs-comment"># curl -c ./cookies.txt -F NAME=user -F PWD=123 http://www.example.com/login.html</span>使用 cookie 访问：<span class="hljs-comment"># curl -b cookies.txt http://www.baidu.com</span>访问 HTTP 认证页面：<span class="hljs-comment"># curl -u user:pass http://www.example.com</span>FTP 上传文件：<span class="hljs-comment"># curl -T filename ftp://user:pass@ip/a.txt</span><span class="hljs-comment"># curl ftp://ip -u user:pass-T filename</span>FTP 下载文件：<span class="hljs-comment"># curl -O ftp://user:pass@ip/a.txt</span><span class="hljs-comment"># curl ftp://ip/filename -u user:pass -o filename</span>FTP 下载多个文件：<span class="hljs-comment"># curl ftp://ip/img/[1,3,5].jpg</span>查看 HTTP 头信息：<span class="hljs-comment"># curl -I http://www.baidu.com</span></code></pre><h2 id="11-33-scp"><a href="#11-33-scp" class="headerlink" title="11.33 scp"></a>11.33 scp</h2><p>功能：基于 SSH 的安全远程服务器文件拷贝</p><p><strong>常用选项：</strong></p><ul><li>-i 指定私钥文件</li><li>-l 限制速率，单位 Kb/s，1024Kb=1Mb</li><li>-P 指定远程主机 SSH 端口</li><li>-p 保存修改时间、访问时间和权限</li><li>-r 递归拷贝目录</li><li>-o SSH 选项，有以下几个比较常用的：</li><li>ConnectionAttempts=NUM 连接失败后重试次数</li><li>ConnectTimeout=SEC 连接超时时间</li><li>StrictHostKeyChecking=no 自动拉去主机 key 文件</li><li>PasswordAuthentication=no 禁止密码认证</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">本地目录推送到远程主机：<span class="hljs-comment"># scp -P 22 - r src_dir root@192.168.1.10:/dst_dir</span>远程主机目录拉取到本地：<span class="hljs-comment"># scp -P 22 - r root@192.168.1.10:dst_dir src_dir</span>同步文件方式一样，不用加 - r 参数</code></pre><h2 id="11-34-rsync"><a href="#11-34-rsync" class="headerlink" title="11.34 rsync"></a>11.34 rsync</h2><p>功能：远程或本地文件同步工具</p><p><strong>常用选项：</strong></p><ul><li>-v 显示复制信息</li><li>-q 不输出错误信息</li><li>-c 跳过基础效验，不判断修改时间和大小</li><li>-a 归档模式，等效 - rlptgoD，保留权限、属组等</li><li>-r 递归目录</li><li>-l 拷贝软连接</li><li>-z 压缩传输数据</li><li>-e 指定远程 shell，比如 ssh、rsh</li><li>–progress 进度条，等同 - P</li><li>–bwlimit=KB/s 限制速率， 0 为没有限制</li><li>–delete 删除那些 DST 中 SRC 没有的文件</li><li>–exclude=PATTERN 排除匹配的文件或目录</li><li>–exclude-from=FILE 从文件中读取要排除的文件或目录</li><li>–password-file=FILE 从文件读取远程主机密码</li><li>–port=PORT 监听端口</li></ul><p><strong>示例：</strong></p><pre><code class="hljs baash">本地复制目录：# rsync -avz abc &#x2F;opt本地目录推送到远程主机：# rsync -avz SRC root@192.168.1.120:DST远程主机目录拉取到本地：# rsync -avz root@192.168.1.10:SRC DST保持远程主机目录与本地一样：# rsync -avz --delete SRC root@192.168.1.120:DST排除某个目录：# rsync -avz --exclude&#x3D;no_dir SRC root@192.168.1.120:DST指定 SSH 端口：# rsync -avz &#x2F;etc&#x2F;hosts -e &quot;ssh - p22&quot; root@192.168.1.120:&#x2F;opt</code></pre><h2 id="11-35-nohup"><a href="#11-35-nohup" class="headerlink" title="11.35 nohup"></a>11.35 nohup</h2><p>功能：运行程序，忽略挂起信号</p><p><strong>示例：</strong></p><pre><code class="hljs bash">后台运行程序，终端关闭不影响：<span class="hljs-comment"># nohup bash test.sh &amp;&gt;test.log &amp;</span></code></pre><h2 id="11-36-iconv"><a href="#11-36-iconv" class="headerlink" title="11.36 iconv"></a>11.36 iconv</h2><p>功能：将文件内容字符集转成其他字符集</p><p><strong>常用选项：</strong></p><ul><li>-l 列出所有已知的字符集</li><li>-f 原始文本编码</li><li>-t 输出编码</li><li>-o 输出到文件</li><li>-s 关闭警告</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">将文件内容转换 UTF8：<span class="hljs-comment"># iconv -f gbk -t utf8 old.txt -o new.txt</span>将 csv 文件转换 GBK：<span class="hljs-comment"># iconv -f utf8 -t gbk old.txt -o new.txt</span>解决邮件乱码：<span class="hljs-comment"># echo $(echo &quot;content&quot; | iconv -f utf8 -t gbk) | mail -s &quot;$(echo&quot;title&quot;| iconv -f utf8 -t gbk)&quot; example@mail.com</span></code></pre><h2 id="11-37-uname"><a href="#11-37-uname" class="headerlink" title="11.37 uname"></a>11.37 uname</h2><p>功能：输出系统信息</p><p><strong>常用选项：</strong></p><ul><li>-a 输出以下所有信息</li><li>-s 输出内核名称</li><li>-n 输出主机名</li><li>-r 输出内核发行版</li><li>-v 输出内核版本</li><li>-m 输出主机的硬件架构名称</li><li>-p 输出处理器类型或 “unknown”</li><li>-i 输出硬件平台或 “unknown</li><li>-o 输出操作系统名称</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">输出所有系统信息：<span class="hljs-comment"># uname -a</span>输出主机名：<span class="hljs-comment"># uname -a</span>输出内核版本：<span class="hljs-comment"># uname -r</span>输出操作系统：<span class="hljs-comment"># uname -o</span></code></pre><h2 id="11-38-sshpass"><a href="#11-38-sshpass" class="headerlink" title="11.38 sshpass"></a>11.38 sshpass</h2><p>功能：非交互 SSH 登录（需要安装）</p><p><strong>常用选项：</strong></p><ul><li>-f 从文件中获取密码</li><li>-d 用文件描述符数字获取密码</li><li>-p 指定 SSH 密码</li><li>-e 密码作为环境变量传递，变量名是 SSHPASS</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">免交互 SSH 登录：<span class="hljs-comment"># sshpass -p 123456 ssh root@192.168.1.10</span>免交互传输文件：<span class="hljs-comment"># sshpass -p 123456 scp a.txt 192.168.1.10:/root</span>密码传入系统变量：<span class="hljs-comment"># SSHPASS=123456 rsync -avz /etc/hosts -e &quot;sshpass -e ssh&quot; root@192.168.1.221:/opt</span></code></pre><h2 id="11-39-tar"><a href="#11-39-tar" class="headerlink" title="11.39 tar"></a>11.39 tar</h2><p>功能：归档目录或文件</p><p><strong>常用选项：</strong></p><ul><li>-c 创建新归档</li><li>-d 比较归档和文件系统的差异</li><li>-r 追加文件到归档</li><li>-t 存档的内容列表</li><li>-x 提取归档所有文件</li><li>-C 改变解压目录</li><li>-f 使用归档文件或设备归档</li><li>-j bzip2 压缩</li><li>-z gzip 压缩</li><li>-v 输出处理过程</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">创建归档文件来自 foo 和 bar：<span class="hljs-comment"># tar -cf archive.tar foo bar</span>提取归档的所有文件：<span class="hljs-comment"># tar -xf archive.tar</span>列出所有归档文件内容：<span class="hljs-comment"># tar -tvf archive.tar</span>创建归档并 gzip 压缩：<span class="hljs-comment"># tar -zcvf archive.tar.gz log</span>提取归档文件并 gzip 解压：<span class="hljs-comment"># tar -zxvf log.tar.gz</span>创建归档并 bzip2 压缩：<span class="hljs-comment"># tar -jcvf log.tar.bz log</span>提取归档并解压到指定目录：<span class="hljs-comment"># tar -zxvf log.tar.gz -C /opt</span></code></pre><h2 id="11-40-logger"><a href="#11-40-logger" class="headerlink" title="11.40 logger"></a>11.40 logger</h2><p>功能：系统日志的 shell 命令行接口</p><p><strong>常用选项：</strong></p><ul><li>-i 每行记录进程 ID</li><li>-f 指定输出日志到文件</li><li>-p 设置记录的优先级</li><li>-t 添加标签</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># logger -i -t &quot;my_test&quot; -p local3.notice &quot;test_info&quot;</span></code></pre><h2 id="11-41-netstat"><a href="#11-41-netstat" class="headerlink" title="11.41 netstat"></a>11.41 netstat</h2><p>功能：打印网络连接、路由表、接口统计信息、伪装连接和多播成员</p><p><strong>常用选项：</strong></p><ul><li>-r 显示路由表</li><li>-i 显示接口表</li><li>-n 不解析名字</li><li>-p 显示程序名 PID/Program</li><li>-l 显示监听的 socket</li><li>-a 显示所有 socket</li><li>-o 显示计时器</li><li>-Z 显示上下文</li><li>-t 只显示 tcp 连接</li><li>-u 只显示 udp 连接</li><li>-s 显示每个协议统计信息</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">显示所有监听：<span class="hljs-comment"># netstat -anltu</span>显示所有 TCP 连接：<span class="hljs-comment"># netstat -antp</span>显示所有 UDP 连接：<span class="hljs-comment"># netstat -anup</span>显示路由表：<span class="hljs-comment"># netstat -r</span></code></pre><h2 id="11-42-ss"><a href="#11-42-ss" class="headerlink" title="11.42 ss"></a>11.42 ss</h2><p>功能：比 netstat 更强大的 socket 查看工具</p><p>格式：ss [options] [ FILTER ]</p><p><strong>常用选项：</strong></p><ul><li>-n 不解析名字</li><li>-a 显示所有 socket</li><li>-l 显示所有监听的 socket</li><li>-o 显示计时器</li><li>-e 显示 socket 详细信息</li><li>-m 显示 socket 内存使用</li><li>-p 显示进程使用的 socket</li><li>-i 显示内部 TCP 信息</li><li>-s 显示 socket 使用汇总</li><li>-4 只显示 IPV4 的 socket</li><li>-0 显示包 socket</li><li>-t 只显示 TCP socket</li><li>-u 只显示 UDP socket</li><li>-d 只显示 DCCP socket</li><li>-w 只显示 RAW socket</li><li>-x 只显示 Unix 域 socket</li><li>-f FAMILY 只显示 socket 族类型（ unix, inet, inet6, link, netlink）</li><li>-A 查询 socket {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]</li><li>-D 将原始的 TCP socket 转储到文件</li><li>-F 从文件中读取过滤信息</li></ul><p><strong>过滤：</strong></p><ul><li>-o state 显示 TCP 连接状态信息</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">显示所有 TCP 连接：<span class="hljs-comment"># ss -t -a</span>显示所有 UDP 连接：<span class="hljs-comment"># ss -u –a</span>显示 socket 使用汇总：<span class="hljs-comment"># ss -s</span>显示所有建立的连接：<span class="hljs-comment"># ss -o state established</span>显示所有的 TIME-WAIT 状态：<span class="hljs-comment"># ss -o state TIME-WAIT</span>搜索所有本地进程连接到 X Server：<span class="hljs-comment"># ss -x src /tmp/.X11-unix/*</span></code></pre><h2 id="11-43-lsof"><a href="#11-43-lsof" class="headerlink" title="11.43 lsof"></a>11.43 lsof</h2><p>功能：列出打开的文件</p><p><strong>常用选项：</strong></p><ul><li>-i [i] 监听的网络地址，如果没有指定，默认列出所有。<br>[i] 来自 [46][protocol][@hostname|hostaddr][:service|port]</li><li>-U 列出 Unix 域 socket 文件</li><li>-p 指定 PID</li><li>-u 指定用户名或 UID 所有打开的文件</li><li>+D 递归搜索</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">列出所有打开的文件：<span class="hljs-comment"># lsof</span>查看哪个进程占用文件：<span class="hljs-comment"># lsof /etc/passwd</span>列出所有打开的监听地址和 unix 域 socket 文件：<span class="hljs-comment"># lsof -i -U</span>列出 80 端口监听的进程：<span class="hljs-comment"># lsof -i:80</span>列出端口 1 - 1024 之间的所有进程：<span class="hljs-comment"># lsof -i:1-1024</span>列出所有 TCP 网络连接：<span class="hljs-comment"># lsof -i tcp</span>列出所有 UDP 网络连接：<span class="hljs-comment"># lsof -i udp</span>根据文件描述符列出打开的文件：<span class="hljs-comment"># lsof -d 1</span>列出某个目录被打开的文件：<span class="hljs-comment"># lsof +D /var/log</span>列出进程 ID 打开的文件：<span class="hljs-comment"># lsof -p 5373</span>打开所有登录用户名 abc 或 user id 1234 ，或 PID 123 或 PID 456 ：<span class="hljs-comment"># lsof -p 123,456 -u 123,abc</span>列出 COMMAND 列中包含字符串 sshd：<span class="hljs-comment"># lsof -c sshd</span></code></pre><h2 id="11-44-ps"><a href="#11-44-ps" class="headerlink" title="11.44 ps"></a>11.44 ps</h2><p>功能：报告当前进程的快照</p><p><strong>常用选项：</strong></p><ul><li>-a 显示所有进程</li><li>-u 选择有效的用户 ID 或名称</li><li>-x 显示无控制终端的进程</li><li>-e 显示所有进程</li><li>-f 全格式</li><li>-r 只显示运行的进程</li><li>-T 这个终端的所有进程</li><li>-p 指定进程 ID</li><li>–sort 对某列排序</li><li>-m 线程</li><li>-L 格式化代码列表</li><li>-o 用户自定义格式</li></ul><pre><code class="hljs bash">CODE NORMAL HEADER%C pcpu      %CPU%G group     GROUP%P ppid      PPID%U user      USER%a args      COMMAND%c comm      COMMAND%g rgroup    RGROUP%n nice      NI%p pid       PID%r pgid      PGID%t etime     ELAPSED%u ruser     RUSER%x time      TIME%y tty       TTY%z vsz       VSZ</code></pre><p><strong>示例：</strong></p><pre><code class="hljs bash">打印系统上所有进程标准语法：<span class="hljs-comment"># ps -ef</span>打印系统上所有进程 BSD 语法：<span class="hljs-comment"># ps aux</span>打印进程树：<span class="hljs-comment"># ps axjf 或 ps -ejH</span>查看进程启动的线程：<span class="hljs-comment"># ps -Lfp PID</span>查看当前用户的进程数：<span class="hljs-comment"># ps uxm 或 ps -U root -u root u</span>自定义格式显示并对 CPU 排序：<span class="hljs-comment"># ps -eo user,pid,pcpu,pmem,nice,lstart,time,args --sort=-pcpu</span>或 ps -eo <span class="hljs-string">&quot;%U %p %C %n %x %a&quot;</span></code></pre><p>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p><ul><li>USER 进程所有者</li><li>PID 进程 ID</li><li>%CPU 占用 CPU 时间</li><li>%MEM 物理内存</li><li>VSZ 虚拟内存大小（kb）</li><li>RSS 驻留集内存页数量（kb）</li><li>TTY 终端</li><li>STAT 进程状态；R 运行，S 休眠，D 不可中断，T 停止，Z 僵尸，N 表示普通优先级更低的优先级</li><li>START 进程启动时间</li><li>TIME 使用 CPU 总时间</li><li>COMMAND 命令名称和参数</li></ul><h2 id="11-45-top"><a href="#11-45-top" class="headerlink" title="11.45 top"></a>11.45 top</h2><p>功能：动态显示活动的进程和系统资源利用率</p><p><strong>常用选项：</strong></p><ul><li>-d 信息刷新时间间隔</li><li>-p 只监控指定的进程 PID</li><li>-i 只显示正在使用 CPU 的进程</li><li>-H 显示线程</li><li>-u 只查看指定用户名的进程</li><li>-b 将输出编排成易处理格式，适合输出到文件处理</li><li>-n 指定最大循环刷新数</li></ul><p><strong>交互命令：</strong></p><ul><li>f 添加或删除显示的指标</li><li>c 显示完整命令</li><li>P 按 CPU 使用百分比排序</li><li>M 按驻留内存大小排序</li><li>T 按进程使用 CPU 时间排序</li><li>1 显示每个 CPU 核心使用率</li><li>k 终止一个进程</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">刷新一次并输出到文件：<span class="hljs-comment"># top -b -n 1 &gt; top.log</span>只显示指定进程的线程：<span class="hljs-comment"># top -Hp 123</span>top - 09:31:08 up 16:49,  0 users,  load average: 0.03, 0.19, 0.22Threads:   0 total,   0 running,   0 sleeping,   0 stopped,   0 zombie%Cpu(s): 12.6 us,  1.0 sy,  0.0 ni, 86.2 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 stKiB Mem :  8008940 total,  7000600 free,   419132 used,   589208 buff/cacheKiB Swap:  2097148 total,  2097148 free,        0 used.  7275176 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</code></pre><p>第一行：当前系统时间，系统运行了多长时间（ 9 天 22 小时 16 分钟），CPU 负载： 1 分钟、 5 分钟、15 分钟</p><p>第二行：系统总共 178 个进程， 3 个 CPU 正在处理， 175 在休眠等待处理， 0 个停止， 0 个僵尸进程</p><p>第三行：us 用户空间使用 CPU 时间 0.3%，sy 内核空间使用 CPU 时间 0.3%，ni 系统调整进程优先级使用 CPU 时间 0.0%，id 空闲 CPU 时间 99.3%，wa 等待 I/O 响应 CPU 时间 0.0%，hi 硬中断，si 软中断。</p><p>第四行和第五行：物理内存与交换分区使用率</p><p>第六行：</p><ul><li>PID 进程 ID</li><li>USER 进程所有者</li><li>PR 进程优先级</li><li>NI 负值表示高优先级，正值表示低优先级</li><li>VIRT 进程启动后使用虚拟内存总量（KB）， VIRT=SWAP+RES</li><li>RES 实际物理内存使用大小（KB），RES=CODE+DATA</li><li>SHR 共享内存大小（KB）, 可能与其他进程共享的内存；计算进程使用物理内存大小：RES-SHR</li><li>S 进程状态；R 运行，S 休眠，D 不可中断，T 停止，Z 僵尸</li><li>%CPU 上次更新到现在的 CPU 时间占用百分比</li><li>%MEM 使用物理内存百分比</li><li>TIME+ 使用 CPU 总时间</li><li>COMMAND 命令名称和参数</li></ul><h2 id="11-46-free"><a href="#11-46-free" class="headerlink" title="11.46 free"></a>11.46 free</h2><p>功能：查看内存使用率</p><p><strong>常用选项：</strong></p><ul><li>-b bytes 显示</li><li>-k KB 显示</li><li>-m M 显示</li><li>-g G 显示</li><li>-h 易读单位显示</li><li>-s 每几秒重复打印</li><li>-c 重复打印几次退出</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">查看物理内存：<span class="hljs-comment"># free -m</span>易读单位显示：<span class="hljs-comment"># free -h</span></code></pre><h2 id="11-47-df"><a href="#11-47-df" class="headerlink" title="11.47 df"></a>11.47 df</h2><p>功能：查看文件系统的磁盘空间使用情况</p><p><strong>常用选项：</strong></p><ul><li>-a 包含虚拟文件系统</li><li>-h 可易读单位显示</li><li>-i 显示 inode 信息而非块使用量</li><li>-k 1K 块的数量</li><li>-t 只显示指定文件系统为指定类型的信息</li><li>-T 显示文件系统类型</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">查看所有文件系统：<span class="hljs-comment"># df -ah</span>输出指定文件系统：<span class="hljs-comment"># df -t xfs</span></code></pre><h2 id="11-48-vmstat"><a href="#11-48-vmstat" class="headerlink" title="11.48 vmstat"></a>11.48 vmstat</h2><p>功能：报告虚拟内存、swap、io、上下文和 CPU 统计信息。</p><p>分析了这些文件：</p><ul><li>/proc/meminfo</li><li>/proc/stat</li><li>/proc/*/stat</li></ul><p><strong>常用选项：</strong></p><ul><li>-a 打印活跃和不活跃的内存页</li><li>-d 打印硬盘统计信息</li><li>-D 打印硬盘表</li><li>-p 打印硬盘分区统计信息</li><li>-s 打印虚拟内存表</li><li>-m 打印内存分配（slab）信息</li><li>-t 添加时间戳到输出</li><li>-S 显示单位，默认 k、KB、m、M，大写是 * 1024</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">每秒刷新一次，统计五次：<span class="hljs-comment"># vmstat - t 1 5</span>[root@blog ~]<span class="hljs-comment"># vmstat -t 1 5</span>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- -----timestamp----- r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="hljs-keyword">in</span>   cs us sy id wa st                 CST 1  0      0 6984504   2108 586796    0    0     3    10  142  106  6  1 93  0  0 2020-09-29 09:28:49 0  0      0 6984504   2108 586828    0    0     0     0  149  174  0  0 100  0  0 2020-09-29 09:28:50 0  0      0 6984504   2108 586828    0    0     0    69  121  154  1  0 100  0  0 2020-09-29 09:28:51 0  0      0 6984504   2108 586828    0    0     0     0  128  155  0  0 100  0  0 2020-09-29 09:28:52 1  0      0 6984504   2108 586828    0    0     0     0  113  146  0  0 100  0  0 2020-09-29 09:28:53</code></pre><ul><li>r：CPU 正在运行的进程数</li><li>b：在等待 I/O 的进程数</li><li>swpd：已经使用的交换内存（kb）</li><li>free：空闲的物理内存（kb）</li><li>buff：已经使用的缓冲区内存（kb）；一般对设备数据缓存，写入到磁盘的数据。</li><li>cache：已经使用的缓冲区内存（kb）；一般对文件数据缓存，从磁盘读取的数据。</li><li>si：从磁盘交换到内存的交换页数量（kb/s）</li><li>so：从内存交换到磁盘的交换页数据（kb/s）</li><li>bi：块设备接收的块数量（kb/s）</li><li>bo：块设备发送的块数量（kb/s）</li><li>in：每秒 CPU 中断次数</li><li>cs：每秒 CPU 上下文切换次数</li><li>us：用户进程使用 CPU 时间（%）</li><li>sy：系统进程使用 CPU 时间（%）</li><li>id：CPU 空闲时间（%）</li><li>wa：等待 I/O 响应所消耗的 CPU 时间（%）</li><li>st：从虚拟设备中获得的时间（%）</li></ul><h2 id="11-49-iostat"><a href="#11-49-iostat" class="headerlink" title="11.49 iostat"></a>11.49 iostat</h2><p>功能：报告 CPU 利用率和磁盘 I/O</p><p>用法: iostat [选项] [ &lt; 时间间隔 &gt; [ &lt; 次数 &gt; ] ]</p><p><strong>常用选项：</strong></p><ul><li>-c 显示 CPU 使用率</li><li>-d 只显示磁盘使用率</li><li>-k 单位 KB/s 代替 Block/s</li><li>-m 单位 MB/s 代替 Block/s</li><li>-N 显示所有映射设备名字</li><li>-t 打印报告时间</li><li>-x 显示扩展统计信息</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">显示 CPU 使用率：<span class="hljs-comment"># iostat -c 1 3</span>显示 I/O 磁盘统计信息：<span class="hljs-comment"># iostat -d -x -k 1 3 # 间隔 1 秒，输出 3 次</span></code></pre><h2 id="11-50-sar"><a href="#11-50-sar" class="headerlink" title="11.50 sar"></a>11.50 sar</h2><p>功能：查看系统资源综合方面利用率</p><p><strong>常用选项：</strong></p><ul><li>-u, CPU</li><li>-r, memory</li><li>-b, disk</li><li>-n DEV, NIC traffic</li><li>-q, systemload</li><li>-b, TPS（Transaction Per Second，每秒事务处理量）</li><li>-o, output to file</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># sar -u 2 3 #每两秒执行一次，采集三次</span><span class="hljs-comment"># sar -u 2 3 -o cpu.out</span><span class="hljs-comment"># sar -f cpu.out #读取文件</span></code></pre><h2 id="11-51-dstat"><a href="#11-51-dstat" class="headerlink" title="11.51 dstat"></a>11.51 dstat</h2><p>功能：查看系统资源综合方面利用率（需要安装）</p><p><strong>常用选项：</strong></p><ul><li>-c cpu 统计</li><li>-d 磁盘统计</li><li>-m 内存统计</li><li>-n 网络统计</li><li>-s swap 统计</li><li>-l 负载统计</li><li>–tcp tcp 状态统计</li><li>–udp udp 状态统计</li><li>–socket socket 数量统计</li><li>-t 输出时间</li><li>–output 写入 csv 文件</li></ul><p><strong>插件：</strong></p><ul><li>–list 支持的插件</li><li>–top-bio-adv 详细显示 I/O 进程写入 block 量，包括 pid、r、w 和 cpu</li><li>–top-io-adv 进程写入磁盘总量</li><li>–top-cpu 占用 CPU 进程</li><li>–top-cpu-adv 查看最高 CPU 进程</li><li>–top-mem 内存进程</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">查看 CPU 利用率：<span class="hljs-comment"># dstat -c</span>查看 TCP 连接状态：<span class="hljs-comment"># dstat --tcp</span></code></pre><h2 id="11-52-ip"><a href="#11-52-ip" class="headerlink" title="11.52 ip"></a>11.52 ip</h2><p>功能：查看 / 操作路由表、设备、路由策略和隧道</p><p>格式：ip [OPTIONS] OBJECT { COMMAND | help }</p><p><strong>常用选项：</strong></p><ul><li>-b, -batch <FILENAME> 从文件或标准输入读取命令并调用他们，第一次失败将终止</li><li>-force 批量模式有错误不终止，如果有错误则状态返回非 0</li><li>-s, -statistics 输出更多的统计信息</li><li>-l, -loops <COUNT> 指定最大的循环数</li></ul><p><strong>操作对象（OBEJECT）：</strong></p><ul><li>address   网络设备地址</li><li>12tp    以太网 IP 隧道</li><li>link  配置网络设备</li><li>maddress  多播地址</li><li>monitor   动态监控网络连接</li><li>mroute  多播路由缓存条目</li><li>mrule   角色在多播路由策略数据库</li><li>neighbour   管理 ARP 或 NDISC 缓存条目</li><li>netns   管理网络命名空间</li><li>ntable 管理 neighbour 缓存操作</li><li>route 路由表</li><li>rule 角色在路由策略数据库</li><li>tpc_metrics/tcpmetrics 管理 TCP 指标</li><li>tunnel IP 隧道</li><li>tuntap 管理 TUN/TAP 设备</li><li>xfrm 管理 IPSec 策略</li></ul><p>可通过 ip OBEJECT help 再查看对象的操作方法。</p><p><strong>示例：</strong></p><pre><code class="hljs bash">查看网络设备地址：<span class="hljs-comment"># ip addr</span>查看网卡统计信息：<span class="hljs-comment"># ip -s link</span>查看单个网卡统计信息：<span class="hljs-comment"># ip -s link ls eth0</span>查看 ARP 缓存表：<span class="hljs-comment"># ip neighbour</span>查看路由表：<span class="hljs-comment"># ip route</span>查看路由策略：<span class="hljs-comment"># ip rule</span>网卡设置 / 删除 IP：<span class="hljs-comment"># ip addr add/del 192.168.1.201/24 dev eth0</span>添加 / 删除默认路由：<span class="hljs-comment"># ip route add default via 192.168.1.1 dev eth0</span><span class="hljs-comment"># ip route del 192.168.1.0/24 via 192.168.1.1</span>添加静态路由：<span class="hljs-comment"># ip route add 172.17.2.0/24 via 192.168. 2. 1 dev eth0</span>开启 / 关闭网卡：<span class="hljs-comment"># ip link set dev eth0 up/down</span>设置最大传输单元：<span class="hljs-comment"># ip link set dev eth0 mtu 1500</span>设置 MAC 地址：<span class="hljs-comment"># ip link set dev eth0 address 00:0c:29:52:73:8e</span></code></pre><h2 id="11-53-nc"><a href="#11-53-nc" class="headerlink" title="11.53 nc"></a>11.53 nc</h2><p>功能：TCP 和 UDP 连接和监听</p><p>常用选项：</p><ul><li>-i interval 指定间隔时间发送和接受行文本</li><li>-l 监听模式，管理传入的连接</li><li>-n 不解析域名</li><li>-p 指定本地源端口</li><li>-s 指定本地源 IP 地址</li><li>-u 使用 udp 协议，默认是 tcp</li><li>-v 执行过程输出</li><li>-w timeout 连接超时时间</li><li>-x proxy_address[:port] 请求连接主机使用代理地址和端口</li><li>-z 指定扫描监听端口，不发送任何数据</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">端口扫描：<span class="hljs-comment"># nc -z 192.168.1.10 1-65535</span>TCP 协议连接到目标端口：<span class="hljs-comment"># nc -p 31337 -w 5 192.168.1.10 22</span>UDP 协议连接到目的端口：<span class="hljs-comment"># nc -u 192.168.1.10 53</span>指定本地 IP 连接：<span class="hljs-comment"># nc -s 192.168.1.9 192.168.1.10 22</span>探测端口是否开启：<span class="hljs-comment"># nc -z -w 2 192.168.1.10 22</span>创建监听 Unix 域 Socket：<span class="hljs-comment"># nc -lU /var/tmp/ncsocket</span>通过 HTTP 代理连接主机：<span class="hljs-comment"># nc -x10.2.3.4:8080 -Xconnect 10.0.0.10 22</span>监听端口捕获输出到文件：<span class="hljs-comment"># nc -l 1234 &gt; filename.out</span>从文件读入到指定端口：<span class="hljs-comment"># nc host.example.com 1234 &lt; filename.in</span>收发信息：<span class="hljs-comment"># nc -l 1234</span><span class="hljs-comment"># nc 127.0.0.1 1234</span>执行 memcahced 命令：<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;stats\n&quot;</span> |nc 127.0.0.1 11211发送邮件：<span class="hljs-comment"># nc [-C] localhost 25 &lt;&lt; EOF</span>HELO host.example.comMAIL FROM: &lt;user@host.example.com&gt;RCPT TO: &lt;user2@host.example.com&gt;DATABody of email.QUITEOF<span class="hljs-comment"># echo -n &quot;GET / HTTP/1.0\r\n\r\n&quot; | nc host.example.com 80</span></code></pre><h2 id="11-54-time"><a href="#11-54-time" class="headerlink" title="11.54 time"></a>11.54 time</h2><p>功能：执行脚本时间</p><p><strong>示例：</strong></p><pre><code class="hljs bash">查看执行 ls 所需的时间：<span class="hljs-comment"># time ls</span></code></pre><h2 id="11-55-eval"><a href="#11-55-eval" class="headerlink" title="11.55 eval"></a>11.55 eval</h2><p>功能：执行参数作为 shell 命令</p><p><strong>示例：</strong></p><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$@</span>; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">eval</span> <span class="hljs-variable">$i</span><span class="hljs-keyword">done</span><span class="hljs-built_in">echo</span> ---<span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$b</span><span class="hljs-comment"># bash test.sh a=1 b=2</span>---12</code></pre><h2 id="11-56-ssh"><a href="#11-56-ssh" class="headerlink" title="11.56 ssh"></a>11.56 ssh</h2><p>功能：SSH 客户端</p><p><strong>常用选项：</strong></p><ul><li>-p 指定远程主机端口</li><li>-i 指定认证文件</li><li>-L [bind_address:]port:host:hostport</li><li>-R [bind_address:]port:host:hostport]</li><li>-D [bind_address:]port</li><li>-o SSH 选项，有以下几个比较常用的：</li><li>ConnectionAttempts=NUM 连接失败后重试次数</li><li>ConnectTimeout=SEC 连接超时时间</li><li>StrictHostKeyChecking=no 自动拉去主机 key 文件</li><li>PasswordAuthentication=no 禁止密码认证</li></ul><p><strong>示例：</strong></p><pre><code class="hljs bash">登录到远程主机：<span class="hljs-comment"># ssh user@192.168.1.120</span>远程主机执行命令：<span class="hljs-comment"># ssh user@192.168.1.120 &#x27;ifconfig&#x27;</span>本地文件内容写到远程主机文件：<span class="hljs-comment"># ssh user@192.168.1.120 &#x27;cat &gt;&gt; file&#x27; &lt; /etc/passwd</span></code></pre><p>SSH 还提供了一个非常有用的功能，就是端口转发，能帮你解决一些无法建立的连接。</p><p>1 ）本地端口转发</p><p>应用场景 1 ：A 不能访问 C，B 能访问 A 和 C，实现通过 B 能让 A 访问 C</p><p>在主机 A 执行：</p><pre><code class="hljs bash"><span class="hljs-comment"># ssh -L 2222: 主机 C:22 主机 B # ssh - L [绑定地址:] 本地端口: 主机 C:C 端口 主机 B</span>将 SSH 绑定本地端口 2222 ，本地 2222 端口数据转发主机 B，主机 B 的所有数据转发到主机 C 的 22 端口；这样一来，只要在主机 A ssh - p 2222 localhost，就等于连上了主机 C 的 22 端口。应用场景 2 ：一台 Squid 代理服务器，限制了本机可以清理缓存，但是我想从远程服务器清理在远程服务器执行：<span class="hljs-comment"># ssh -L 31280 :localhost:3128 SquidHost</span>在远程服务器上执行清理命令到本机 31280 端口， 31280 收到的数据加密转发到 SquidHost 的 SSH Server 上，SSH Client 解密收到的数据并转发到监听的 3128 端口上，最后将 Squid 返回的数据原路返回。</code></pre><p>2 ）远程端口转发</p><p>应用场景 1 ：A 不能访问 C，B 能访问 A 和 C，但 A 不能访问 B，比如 A 在外网，B 在内网</p><p>在主机 B 执行：</p><pre><code class="hljs bash"><span class="hljs-comment"># ssh -R 2222: 主机 C:22 主机 A</span>将 SSH 绑定本机 2222 端口，与主机 A 建立 SSH 通道，当主机 A 访问本地 2222 端口，就等于访问主机B 的 2222 端口，主机 B 的 2222 端口把数据转发到主机 C 的 22 端口。应用常见 2 ：公司有一台内网服务器，还有一台云主机不能 SSH 直接连接这台公司内网服务器，但内网服务器可以 SSH 连接云主机在公司内网服务器执行：<span class="hljs-comment"># ssh -R 2222 :localhost:22 云主机</span>将云主机上的 2222 端口数据转发到内网服务器 SSH Client 上，SSH Client 解密收到的数据并转发到监听的 22 端口上，最后再将返回的数据原路返回。</code></pre><p>3 ）动态端口转发（不限定端口，全权代理）</p><p>应用场景：翻墙访问国外网站</p><p>如果是 MAC 系统直接在终端执行：ssh -D 2222 国外云主机</p><p>如果是 Windows 系统可借助 putty 工具实现，在 putty 里面端口转发 -&gt; 本地端口转发属性里面添加一个本地端口，并勾选 SOCKS4/5 动态转发，连接即可。<br>将 SSH 绑定本机 8080 端口，SSH 就会创建一个 SOCKS 代理服务，直接在浏览器上设置代理本机 127.0.0.1 的 8080 端口即可，当浏览器访问国外网站时，本地代理把请求转发到国外云主机的 SSH Server，SSH 解密并转发给指定的网站。</p><p>注意：再 Linux 终端执行 ssh 绑定命令后，默认会进入一个新的 shell，只要这个 shell 不退出，此<br>端口转发就一直有效。如果要想放到后台执行就加 - Nf 两个选项，-N 是不执行命令，-f 后台执行，<br>这样就转入后台运行，就可以在本地 shell 执行操作了，如果想关闭后台就 kill 这个进程。</p><p>参考资料：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/">https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></p><h2 id="11-57-iptables"><a href="#11-57-iptables" class="headerlink" title="11.57 iptables"></a>11.57 iptables</h2><p>常见几种类型防火墙？</p><p>包过滤防火墙：包过滤是 IP 层实现，包过滤根据数据包的源 IP、目的 IP、协议类型（TCP/UDP/ICMP）、源端口、目的端口等包头信息及数据包传输方向灯信息来判断是否允许数据包通过。</p><p>应用层防火墙：也称为应用层代理防火墙，基于应用层协议的信息流检测，可以拦截某应用程序的所有封包，提取包内容进行分析。有效防止 SQL 注入或者 XSS（跨站脚本攻击）之类的恶意代码。</p><p>状态检测防火墙：结合包过滤和应用层防火墙优点，基于连接状态检测机制，将属于同一连接的所有包作为一个整体的数据流看待，构成连接状态表（通信信息，应用程序信息等），通过规则表与状态表共同配合，对表中的各个连接状态判断。</p><p>iptables 是 Linux 下的配置防火墙的工具，用于配置 Linux 内核集成的 IP 信息包过滤系统，使增<br>删改查信息包过滤表中的规则更加简单。</p><p>iptables 分为四表五链，表是链的容器，链是规则的容器，规则指定动作。</p><p><strong>四表：</strong></p><ul><li>filter 用于包过滤</li><li>nat 网络地址转发</li><li>mangle 对特定数据包修改</li><li>raw 不做数据包链接跟踪</li></ul><p><strong>五链：</strong></p><ul><li>INPUT 本机数据包入口</li><li>OUTPUT 本机数据包出口</li><li>FORWARD 经过本机转发的数据包</li><li>PREROUTING 防火墙之前，修改目的地址（DNAT）</li><li>POSTROUTING 防火墙之后，修改源地址（SNAT）</li></ul><p><strong>表中的链：</strong></p><table><thead><tr><th>表</th><th>链</th></tr></thead><tbody><tr><td>filter</td><td>INPUT、OUTPUT 和 FORWARD</td></tr><tr><td>nat</td><td>PREROUTING、POSTROUTING 和 OUTPUT</td></tr><tr><td>mangle</td><td>PREROUTING、POSTROUTING、INPUT、OUTPUT 和 FORWARD</td></tr><tr><td>raw</td><td>PREROUTING 和 OUTPUT</td></tr></tbody></table><p>命令格式：iptables [-t table] 命令 [chain] 匹配条件 动作</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>- A，append</td><td>追加一条规则</td></tr><tr><td>- I，insert</td><td>插入一条规则，默认链头，后跟编号，指定第几条</td></tr><tr><td>- D，delete</td><td>删除一条规则</td></tr><tr><td>- F，flush</td><td>清空规则</td></tr><tr><td>- L，list</td><td>列出规则</td></tr><tr><td>- P，policy</td><td>设置链缺省规则</td></tr><tr><td>- m，module</td><td>模块，比如 state、multiport</td></tr></tbody></table><table><thead><tr><th>匹配条件</th><th>描述</th></tr></thead><tbody><tr><td>- i</td><td>入口网卡</td></tr><tr><td>- o</td><td>出口网卡</td></tr><tr><td>- s</td><td>源地址</td></tr><tr><td>- d</td><td>目的地址</td></tr><tr><td>- p</td><td>协议类型</td></tr><tr><td>–sport</td><td>源端口</td></tr><tr><td>–dport</td><td>目的端口</td></tr></tbody></table><table><thead><tr><th>动作</th><th>描述</th></tr></thead><tbody><tr><td>ACCEPT</td><td>允许数据包通过</td></tr><tr><td>DROP</td><td>丢弃数据包不做处理</td></tr><tr><td>REJECT</td><td>拒绝数据包，并返回报错信息</td></tr><tr><td>SNAT</td><td>一般用于 nat 表的 POSTROUTING 链，进行源地址转换</td></tr><tr><td>DNAT</td><td>一般用于 nat 表的 PREROUTING 链，进行目的地址转换</td></tr><tr><td>MASQUERADE</td><td>动态源地址转换，动态 IP 时使用</td></tr></tbody></table><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>state</td><td>包状态，有四个：NEW、RELATED、ESTABLISHED 和 INVALID</td></tr><tr><td>mac</td><td>源 MAC 地址</td></tr><tr><td>limit</td><td>包速率限制</td></tr><tr><td>multiport</td><td>多端口，以逗号分隔</td></tr><tr><td>iprange</td><td>端口范围，以逗号分隔</td></tr></tbody></table><p><strong>示例：常用的规则配置方法</strong></p><pre><code class="hljs bash">iptables -F <span class="hljs-comment"># 清空表规则，默认 filter 表</span>iptables -t nat - F <span class="hljs-comment"># 清空 nat 表</span>iptables -A INPUT -p tcp --dport 22 -j ACCEPT <span class="hljs-comment"># 允许 TCP 的 22 端口访问</span>iptables -I INPUT -p udp --dport 53 -j ACCEPT <span class="hljs-comment"># 允许 UDP 的 53 端口访问，插入在第一条</span>iptables -A INPUT -p tcp --dport 22:25 -j ACCEPT <span class="hljs-comment"># 允许端口范围访问</span>iptables -D INPUT -p tcp --dport 22:25 -j ACCEPT <span class="hljs-comment"># 删除这条规则</span><span class="hljs-comment"># 允许多个 TCP 端口访问</span>iptables -A INPUT -p tcp -m multiport --dports 22,80,8080 -j ACCEPTiptables -A INPUT -s 192.168.1.0/24 -j ACCEPT <span class="hljs-comment"># 允许 192.168.1.0 段 IP 访问</span>iptables -A INPUT -s 192.168.1.10 -j DROP <span class="hljs-comment"># 对 1.10 数据包丢弃</span>iptables -A INPUT -i eth0 -p icmp -j DROP <span class="hljs-comment"># eth0 网卡 ICMP 数据包丢弃，也就是禁 ping</span><span class="hljs-comment"># 允许来自 lo 接口，如果没有这条规则，将不能通过 127.0.0.1 访问本地服务</span>iptables -A INPUT -i lo -j ACCEPT<span class="hljs-comment"># 限制并发连接数，超过 30 个拒绝</span>iptables -I INPUT -p tcp --syn --dport 80 -m connlimit --connlimit-above 30 -j REJECT<span class="hljs-comment"># 限制每个 IP 每秒并发连接数最大 3 个</span>iptables -I INPUT -p tcp --syn -m <span class="hljs-built_in">limit</span> --<span class="hljs-built_in">limit</span> 1/s --limit-burst 3 -j ACCEPTiptables -A FORWARD -p tcp --syn -m <span class="hljs-built_in">limit</span> --<span class="hljs-built_in">limit</span> 1/s -j ACCEPT<span class="hljs-comment"># iptables 服务器作为网关时，内网访问公网</span>iptables –t nat -A POSTROUTING -s [内网 IP 或网段] -j SNAT --to [公网 IP]<span class="hljs-comment"># 访问 iptables 公网 IP 端口，转发到内网服务器端口</span>iptables –t nat -A PREROUTING -d [对外 IP] -p tcp --dport [对外端口] -j DNAT --to [内网 IP: 内网端口]<span class="hljs-comment"># 本地 80 端口转发到本地 8080 端口</span>iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080<span class="hljs-comment"># 允许已建立及该链接相关联的数据包通过</span>iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT<span class="hljs-comment"># ASDL 拨号上网</span>iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o pppo -j MASQUERADE<span class="hljs-comment"># 设置 INPUT 链缺省操作丢弃所有数据包，只要不符合规则的数据包都丢弃。注意要在最后设置，</span>以免把自己关在外面！iptables -P INPUT DROP</code></pre><h1 id="十二、-Shell-脚本编写实战"><a href="#十二、-Shell-脚本编写实战" class="headerlink" title="十二、 Shell 脚本编写实战"></a>十二、 Shell 脚本编写实战</h1><p><strong>注意事项</strong></p><ul><li>1 ）开头加解释器：#!/bin/bash</li><li>2 ）语法缩进，使用四个空格；多加注释说明。</li><li>3 ）命名建议规则：变量名大写、局部变量小写，函数名小写，名字体现出实际作用。</li><li>4 ）默认变量是全局的，在函数中变量 local 指定为局部变量，避免污染其他作用域。</li><li>5 ）有两个命令能帮助我调试脚本：set -e 遇到执行非 0 时退出脚本，set -x 打印执行过程。</li><li>6 ）写脚本一定先测试再到生产上。</li></ul><h2 id="12-1-获取随机字符串或数字"><a href="#12-1-获取随机字符串或数字" class="headerlink" title="12.1 获取随机字符串或数字"></a>12.1 获取随机字符串或数字</h2><p>获取随机 8 位字符串：</p><pre><code class="hljs bash">方法 1 ：<span class="hljs-comment"># echo $RANDOM |md5sum |cut -c 1-8</span>471b94f2方法 2 ：<span class="hljs-comment"># openssl rand -base64 4</span>vg3BEg==方法 3 ：<span class="hljs-comment"># cat /proc/sys/kernel/random/uuid |cut -c 1-8</span>ed9e032c</code></pre><p>获取随机 8 位数字：</p><pre><code class="hljs bash">方法 1 ：<span class="hljs-comment"># echo $RANDOM |cksum |cut -c 1-8</span>23648321方法 2 ：<span class="hljs-comment"># openssl rand -base64 4 |cksum |cut -c 1-8</span>38571131方法 3 ：<span class="hljs-comment"># date +%N |cut -c 1-8</span>69024815</code></pre><p>cksum：打印 CRC 效验和统计字节</p><h2 id="12-2-定义一个颜色输出字符串函数"><a href="#12-2-定义一个颜色输出字符串函数" class="headerlink" title="12.2 定义一个颜色输出字符串函数"></a>12.2 定义一个颜色输出字符串函数</h2><pre><code class="hljs bash">方法 1 ：<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_color</span></span>() &#123;  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$1</span> == <span class="hljs-string">&quot;green&quot;</span>]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>  <span class="hljs-keyword">elif</span> [<span class="hljs-variable">$1</span> == <span class="hljs-string">&quot;red&quot;</span>]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>  <span class="hljs-keyword">fi</span>&#125;方法 2 ：<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_color</span></span>() &#123;  <span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>    green)      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>    ;;    red)      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>    ;;    *)      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Example: echo_color red string&quot;</span>  <span class="hljs-keyword">esac</span>&#125;使用方法：echo_color green <span class="hljs-string">&quot;test&quot;</span></code></pre><p><strong>function</strong> 关键字定义一个函数，可加或不加。</p><h2 id="12-3-批量创建用户"><a href="#12-3-批量创建用户" class="headerlink" title="12.3 批量创建用户"></a>12.3 批量创建用户</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>DATE=$(date +%F_%T)USER_FILE=user.txt<span class="hljs-function"><span class="hljs-title">echo_color</span></span>()&#123;  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$1</span> == <span class="hljs-string">&quot;green&quot;</span>]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>  <span class="hljs-keyword">elif</span> [<span class="hljs-variable">$1</span> == <span class="hljs-string">&quot;red&quot;</span>]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>  <span class="hljs-keyword">fi</span>&#125;<span class="hljs-comment"># 如果用户文件存在并且大小大于 0 就备份</span><span class="hljs-keyword">if</span> [-s <span class="hljs-variable">$USER_FILE</span>]; <span class="hljs-keyword">then</span>  mv <span class="hljs-variable">$USER_FILE</span> <span class="hljs-variable">$&#123;USER_FILE&#125;</span>-<span class="hljs-variable">$&#123;DATE&#125;</span>.bak  echo_color green <span class="hljs-string">&quot;<span class="hljs-variable">$USER_FILE</span> exist, rename <span class="hljs-variable">$&#123;USER_FILE&#125;</span>-<span class="hljs-variable">$&#123;DATE&#125;</span>.bak&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;User\tPassword&quot;</span> &gt;&gt; <span class="hljs-variable">$USER_FILE</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;----------------&quot;</span> &gt;&gt; <span class="hljs-variable">$USER_FILE</span><span class="hljs-keyword">for</span> USER <span class="hljs-keyword">in</span> user&#123;1..10&#125;; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> ! id <span class="hljs-variable">$USER</span> &amp;&gt;/dev/null; <span class="hljs-keyword">then</span>    PASS=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$RANDOM</span> |md5sum |cut -c 1-8)    useradd <span class="hljs-variable">$USER</span>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PASS</span> |passwd --stdin <span class="hljs-variable">$USER</span> &amp;&gt;/dev/null    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>\t<span class="hljs-variable">$PASS</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$USER_FILE</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span> User create successful.&quot;</span>  <span class="hljs-keyword">else</span>    echo_color red <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span> User already exists!&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-4-检查软件包是否安装"><a href="#12-4-检查软件包是否安装" class="headerlink" title="12.4 检查软件包是否安装"></a>12.4 检查软件包是否安装</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">if</span> rpm -q sysstat &amp;&gt;/dev/null; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sysstat is already installed.&quot;</span><span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sysstat is not installed!&quot;</span><span class="hljs-keyword">fi</span></code></pre><h2 id="12-5-检查服务状态"><a href="#12-5-检查服务状态" class="headerlink" title="12.5 检查服务状态"></a>12.5 检查服务状态</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>PORT_C=$(ss -anu |grep -c 123)PS_C=$(ps -ef |grep ntpd |grep -vc grep)<span class="hljs-keyword">if</span> [<span class="hljs-variable">$PORT_C</span> -eq 0 -o <span class="hljs-variable">$PS_C</span> -eq 0]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;内容&quot;</span> | mail - s <span class="hljs-string">&quot;主题&quot;</span> dst@example.com<span class="hljs-keyword">fi</span></code></pre><h2 id="12-6-检查主机存活状态"><a href="#12-6-检查主机存活状态" class="headerlink" title="12.6 检查主机存活状态"></a>12.6 检查主机存活状态</h2><p>方法 1 ：将错误 IP 放到数组里面判断是否 ping 失败三次</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>IP_LIST=<span class="hljs-string">&quot;192.168.18.1 192.168.1.1 192.168.18.2&quot;</span><span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$IP_LIST</span>; <span class="hljs-keyword">do</span>  NUM=1  <span class="hljs-keyword">while</span> [<span class="hljs-variable">$NUM</span> -le 3]; <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> ping -c 1 <span class="hljs-variable">$IP</span> &gt; /dev/null; <span class="hljs-keyword">then</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is successful.&quot;</span>      <span class="hljs-built_in">break</span>    <span class="hljs-keyword">else</span>    <span class="hljs-comment"># echo &quot;$IP Ping is failure $NUM&quot;</span>      FAIL_COUNT[<span class="hljs-variable">$NUM</span>]=<span class="hljs-variable">$IP</span>      <span class="hljs-built_in">let</span> NUM++    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span>  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$&#123;#FAIL_COUNT[*]&#125;</span> -eq 3 ];<span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;FAIL_COUNT[1]&#125;</span> Ping is failure!&quot;</span>    <span class="hljs-built_in">unset</span> FAIL_COUNT[*]  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><p>方法 2 ：将错误次数放到 FAIL_COUNT 变量里面判断是否 ping 失败三次</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>IP_LIST=<span class="hljs-string">&quot;192.168.18.1 192.168.1.1 192.168.18.2&quot;</span><span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$IP_LIST</span>; <span class="hljs-keyword">do</span>  FAIL_COUNT=0  <span class="hljs-keyword">for</span> ((i=1;i&lt;=3;i++)); <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> ping - c 1 <span class="hljs-variable">$IP</span> &gt;/dev/null; <span class="hljs-keyword">then</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is successful.&quot;</span>      <span class="hljs-built_in">break</span>    <span class="hljs-keyword">else</span>    <span class="hljs-comment"># echo &quot;$IP Ping is failure $i&quot;</span>      <span class="hljs-built_in">let</span> FAIL_COUNT++    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span>  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$FAIL_COUNT</span> -eq 3]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is failure!&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><p>方法 3 ：利用 for 循环将 ping 通就跳出循环继续，如果不跳出就会走到打印 ping 失败</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-function"><span class="hljs-title">ping_success_status</span></span>() &#123;  <span class="hljs-keyword">if</span> ping -c 1 <span class="hljs-variable">$IP</span> &gt;/dev/null; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is successful.&quot;</span>    <span class="hljs-built_in">continue</span>  <span class="hljs-keyword">fi</span>&#125;IP_LIST=<span class="hljs-string">&quot;192.168.18.1 192.168.1.1 192.168.18.2&quot;</span><span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$IP_LIST</span>; <span class="hljs-keyword">do</span>  ping_success_status  ping_success_status  ping_success_status  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is failure!&quot;</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-7-监控-CPU、内存和硬盘利用率"><a href="#12-7-监控-CPU、内存和硬盘利用率" class="headerlink" title="12.7 监控 CPU、内存和硬盘利用率"></a>12.7 监控 CPU、内存和硬盘利用率</h2><p><strong>1 ）CPU</strong></p><p>借助 vmstat 工具来分析 CPU 统计信息。</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>DATE=$(date +%F<span class="hljs-string">&quot; &quot;</span>%H:%M)IP=$(ifconfig eth0 |awk -F <span class="hljs-string">&#x27;[ :]+&#x27;</span> <span class="hljs-string">&#x27;/inet addr/&#123;print $4&#125;&#x27;</span>) <span class="hljs-comment"># 只支持 CentOS6</span>MAIL=<span class="hljs-string">&quot;example@mail.com&quot;</span><span class="hljs-keyword">if</span> ! <span class="hljs-built_in">which</span> vmstat &amp;&gt;/dev/null; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;vmstat command no found, Please install procps package.&quot;</span>  <span class="hljs-built_in">exit</span> 1<span class="hljs-keyword">fi</span>US=$(vmstat |awk <span class="hljs-string">&#x27;NR==3&#123;print $13&#125;&#x27;</span>)SY=$(vmstat |awk <span class="hljs-string">&#x27;NR==3&#123;print $14&#125;&#x27;</span>)IDLE=$(vmstat |awk <span class="hljs-string">&#x27;NR==3&#123;print $15&#125;&#x27;</span>)WAIT=$(vmstat |awk <span class="hljs-string">&#x27;NR==3&#123;print $16&#125;&#x27;</span>)USE=$((<span class="hljs-variable">$US</span>+<span class="hljs-variable">$SY</span>))<span class="hljs-keyword">if</span> [<span class="hljs-variable">$USE</span> -ge 50]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;</span><span class="hljs-string">  Date: <span class="hljs-variable">$DATE</span></span><span class="hljs-string">  Host: <span class="hljs-variable">$IP</span></span><span class="hljs-string">  Problem: CPU utilization <span class="hljs-variable">$USE</span></span><span class="hljs-string">  &quot;</span>| mail -s<span class="hljs-string">&quot;CPU Monitor&quot;</span> <span class="hljs-variable">$MAIL</span><span class="hljs-keyword">fi</span></code></pre><p><strong>2 ）内存</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>DATE=$(date +%F<span class="hljs-string">&quot; &quot;</span>%H:%M)IP=$(ifconfig eth0 |awk -F <span class="hljs-string">&#x27;[ :]+&#x27;</span> <span class="hljs-string">&#x27;/inet addr/&#123;print $4&#125;&#x27;</span>)MAIL=<span class="hljs-string">&quot;example@mail.com&quot;</span>TOTAL=$(free -m |awk <span class="hljs-string">&#x27;/Mem/&#123;print $2&#125;&#x27;</span>)USE=$(free -m |awk <span class="hljs-string">&#x27;/Mem/&#123;print $3-$6-$7&#125;&#x27;</span>)FREE=$((<span class="hljs-variable">$TOTAL</span>-<span class="hljs-variable">$USE</span>))<span class="hljs-comment"># 内存小于 1G 发送报警邮件</span><span class="hljs-keyword">if</span> [<span class="hljs-variable">$FREE</span> -lt 1024]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;</span><span class="hljs-string">  Date: <span class="hljs-variable">$DATE</span></span><span class="hljs-string">  Host: <span class="hljs-variable">$IP</span></span><span class="hljs-string">  Problem: Total=<span class="hljs-variable">$TOTAL</span>,Use=<span class="hljs-variable">$USE</span>,Free=<span class="hljs-variable">$FREE</span></span><span class="hljs-string">  &quot;</span>| mail -s<span class="hljs-string">&quot;Memory Monitor&quot;</span> <span class="hljs-variable">$MAIL</span><span class="hljs-keyword">fi</span></code></pre><p><strong>3 ）硬盘</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>DATE=$(date +%F<span class="hljs-string">&quot; &quot;</span>%H:%M)IP=$(ifconfig eth0 |awk -F <span class="hljs-string">&#x27;[ :]+&#x27;</span> <span class="hljs-string">&#x27;/inet addr/&#123;print $4&#125;&#x27;</span>)MAIL=<span class="hljs-string">&quot;example@mail.com&quot;</span>TOTAL=$(fdisk -l |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;BEGIN&#123;OFS=&quot;=&quot;&#125;/^Disk \/dev/&#123;printf&quot;%s=%sG,&quot;,$2,$3&#125;&#x27;</span>)PART_USE=$(df -h |awk <span class="hljs-string">&#x27;BEGIN&#123;OFS=&quot;=&quot;&#125;/^\/dev/&#123;print $1,int($5),$6&#125;&#x27;</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$PART_USE</span>; <span class="hljs-keyword">do</span>  PART=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span> |cut -d<span class="hljs-string">&quot;=&quot;</span> -f1)  USE=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span> |cut -d<span class="hljs-string">&quot;=&quot;</span> -f2)  MOUNT=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span> |cut -d<span class="hljs-string">&quot;=&quot;</span> -f3)  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$USE</span> -gt 80]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;</span><span class="hljs-string">    Date: <span class="hljs-variable">$DATE</span></span><span class="hljs-string">    Host: <span class="hljs-variable">$IP</span></span><span class="hljs-string">    Total: <span class="hljs-variable">$TOTAL</span></span><span class="hljs-string">    Problem: <span class="hljs-variable">$PART</span>=<span class="hljs-variable">$USE</span>(<span class="hljs-variable">$MOUNT</span>)</span><span class="hljs-string">    &quot;</span>| mail -s<span class="hljs-string">&quot;Disk Monitor&quot;</span> <span class="hljs-variable">$MAIL</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-8-批量主机磁盘利用率监控"><a href="#12-8-批量主机磁盘利用率监控" class="headerlink" title="12.8 批量主机磁盘利用率监控"></a>12.8 批量主机磁盘利用率监控</h2><p>前提监控端和被监控端 SSH 免交互登录或者密钥登录。</p><p>写一个配置文件保存被监控主机 SSH 连接信息，文件内容格式：IP User Port</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>HOST_INFO=host.info<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> $(awk <span class="hljs-string">&#x27;/^[^#]/&#123;print $1&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>); <span class="hljs-keyword">do</span>  USER=$(awk -v ip=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;ip==$1&#123;print $2&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)  PORT=$(awk -v ip=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;ip==$1&#123;print $3&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)  TMP_FILE=/tmp/disk.tmp  ssh -p <span class="hljs-variable">$PORT</span> <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;df -h&#x27;</span> &gt; <span class="hljs-variable">$TMP_FILE</span>  USE_RATE_LIST=$(awk <span class="hljs-string">&#x27;BEGIN&#123;OFS=&quot;=&quot;&#125;/^\/dev/&#123;print $1,int($5)&#125;&#x27;</span> <span class="hljs-variable">$TMP_FILE</span>)  <span class="hljs-keyword">for</span> USE_RATE <span class="hljs-keyword">in</span> <span class="hljs-variable">$USE_RATE_LIST</span>; <span class="hljs-keyword">do</span>    PART_NAME=<span class="hljs-variable">$&#123;USE_RATE%=*&#125;</span>    USE_RATE=<span class="hljs-variable">$&#123;USE_RATE#*=&#125;</span>    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$USE_RATE</span> - ge 80]; <span class="hljs-keyword">then</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$PART_NAME</span> Partition usage <span class="hljs-variable">$USE_RATE</span>%!&quot;</span>    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-9-检查网站可用性"><a href="#12-9-检查网站可用性" class="headerlink" title="12.9 检查网站可用性"></a>12.9 检查网站可用性</h2><p><strong>1 ）检查 URL 可用性</strong></p><pre><code class="hljs bash">方法 1 ：<span class="hljs-function"><span class="hljs-title">check_url</span></span>() &#123;HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="hljs-string">&quot;%&#123;http_code&#125;&quot;</span> <span class="hljs-variable">$1</span>)<span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -ne 200]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$1</span> Access failure!&quot;</span><span class="hljs-keyword">fi</span>&#125;方法 2 ：<span class="hljs-function"><span class="hljs-title">check_url</span></span>() &#123;<span class="hljs-keyword">if</span> ! wget -T 10 --tries=1 --spider <span class="hljs-variable">$1</span> &gt;/dev/null 2&gt;&amp;1; <span class="hljs-keyword">then</span>  <span class="hljs-comment">#-T 超时时间，--tries 尝试 1 次，--spider 爬虫模式</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$1</span> Access failure!&quot;</span><span class="hljs-keyword">fi</span>&#125;使用方法：check_url www.baidu.com</code></pre><p><strong>2 ）判断三次 URL 可用性</strong></p><p>思路与上面检查主机存活状态一样。</p><pre><code class="hljs bash">方法 1 ：利用循环技巧，如果成功就跳出当前循环，否则执行到最后一行<span class="hljs-meta">#!/bin/bash</span><span class="hljs-function"><span class="hljs-title">check_url</span></span>() &#123;  HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="hljs-string">&quot;%&#123;http_code&#125;&quot;</span> <span class="hljs-variable">$1</span>)  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -eq 200]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">continue</span>  <span class="hljs-keyword">fi</span>&#125;URL_LIST=<span class="hljs-string">&quot;www.baidu.com www.agasgf.com&quot;</span><span class="hljs-keyword">for</span> URL <span class="hljs-keyword">in</span> <span class="hljs-variable">$URL_LIST</span>; <span class="hljs-keyword">do</span>  check_url <span class="hljs-variable">$URL</span>  check_url <span class="hljs-variable">$URL</span>  check_url <span class="hljs-variable">$URL</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$URL</span> Access failure!&quot;</span><span class="hljs-keyword">done</span>方法 2 ：错误次数保存到变量<span class="hljs-meta">#!/bin/bash</span>URL_LIST=<span class="hljs-string">&quot;www.baidu.com www.agasgf.com&quot;</span><span class="hljs-keyword">for</span> URL <span class="hljs-keyword">in</span> <span class="hljs-variable">$URL_LIST</span>; <span class="hljs-keyword">do</span>  FAIL_COUNT=0  <span class="hljs-keyword">for</span> ((i=1;i&lt;=3;i++)); <span class="hljs-keyword">do</span>    HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="hljs-string">&quot;%&#123;http_code&#125;&quot;</span> <span class="hljs-variable">$URL</span>)    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -ne 200]; <span class="hljs-keyword">then</span>      <span class="hljs-built_in">let</span> FAIL_COUNT++    <span class="hljs-keyword">else</span>      <span class="hljs-built_in">break</span>    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span>  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$FAIL_COUNT</span> -eq 3]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$URL</span> Access failure!&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span>方法 3 ：错误次数保存到数组<span class="hljs-meta">#!/bin/bash</span>URL_LIST=<span class="hljs-string">&quot;www.baidu.com www.agasgf.com&quot;</span><span class="hljs-keyword">for</span> URL <span class="hljs-keyword">in</span> <span class="hljs-variable">$URL_LIST</span>; <span class="hljs-keyword">do</span>  NUM=1  <span class="hljs-keyword">while</span> [<span class="hljs-variable">$NUM</span> -le 3]; <span class="hljs-keyword">do</span>    HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="hljs-string">&quot;%&#123;http_code&#125;&quot;</span> <span class="hljs-variable">$URL</span>)    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -ne 200]; <span class="hljs-keyword">then</span>      FAIL_COUNT[<span class="hljs-variable">$NUM</span>]=<span class="hljs-variable">$IP</span> <span class="hljs-comment">#创建数组，以 $NUM 下标，$IP 元素</span>      <span class="hljs-built_in">let</span> NUM++    <span class="hljs-keyword">else</span>      <span class="hljs-built_in">break</span>    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span>  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$&#123;#FAIL_COUNT[*]&#125;</span> -eq 3 ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$URL</span> Access failure!&quot;</span>    <span class="hljs-built_in">unset</span> FAIL_COUNT[*] <span class="hljs-comment">#清空数组</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-10-检查-MySQL-主从同步状态"><a href="#12-10-检查-MySQL-主从同步状态" class="headerlink" title="12.10 检查 MySQL 主从同步状态"></a>12.10 检查 MySQL 主从同步状态</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>USER=bakPASSWD=123 456IO_SQL_STATUS=$(mysql -u<span class="hljs-variable">$USER</span> -p<span class="hljs-variable">$PASSWD</span> -e <span class="hljs-string">&#x27;show slave status\G&#x27;</span> |awk -F:<span class="hljs-string">&#x27;/Slave_.*_Running/&#123;gsub(&quot;: &quot;,&quot;:&quot;);print $0&#125;&#x27;</span>) <span class="hljs-comment">#gsub 去除冒号后面的空格</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$IO_SQL_STATUS</span>; <span class="hljs-keyword">do</span>  THREAD_STATUS_NAME=<span class="hljs-variable">$&#123;i%:*&#125;</span>  THREAD_STATUS=<span class="hljs-variable">$&#123;i#*:&#125;</span>  <span class="hljs-keyword">if</span> [<span class="hljs-string">&quot;<span class="hljs-variable">$THREAD_STATUS</span>&quot;</span> != <span class="hljs-string">&quot;Yes&quot;</span>]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: MySQL Master-Slave <span class="hljs-variable">$THREAD_STATUS_NAME</span> status is</span><span class="hljs-string">    <span class="hljs-variable">$THREAD_STATUS</span>!&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-11-屏蔽网站访问频繁的-IP"><a href="#12-11-屏蔽网站访问频繁的-IP" class="headerlink" title="12. 11 屏蔽网站访问频繁的 IP"></a>12. 11 屏蔽网站访问频繁的 IP</h2><p><strong>1 ）屏蔽每分钟访问超过 200 的 IP</strong></p><pre><code class="hljs bash">方法 1 ：以 Nginx 日志作为测试DATE=$(date +%d/%b/%Y:%H:%M)ABNORMAL_IP=$(tail -n5000 access.log |grep <span class="hljs-variable">$DATE</span> |awk <span class="hljs-string">&#x27;&#123;a[$1]++&#125;END&#123;for(i in a)if(a[i]&gt;100)print i&#125;&#x27;</span>)<span class="hljs-comment">#先 tail 防止文件过大，读取慢，数字可调整每分钟最大的访问量。awk 不能直接过滤日志，因为包含特殊字符。</span><span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$ABNORMAL_IP</span>; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> [$(iptables -vnL |grep -c <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span>&quot;</span>) -eq 0 ]; <span class="hljs-keyword">then</span>    iptables -I INPUT -s <span class="hljs-variable">$IP</span> -j DROP  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span>方法 2 ：通过建立连接数ABNORMAL_IP=$(netstat -an |awk <span class="hljs-string">&#x27;$4~/:80$/ &amp;&amp; $6~/ESTABLISHED/&#123;gsub(/:[0-9]+/,&quot;&quot;,$5);&#123;a[$5]++&#125;&#125;END&#123;for(i in a)if(a[i]&gt;100)print i&#125;&#x27;</span>)<span class="hljs-comment">#gsub 是将第五列（客户端 IP）的冒号和端口去掉</span><span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$ABNORMAL_IP</span>; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> [$(iptables -vnL |grep -c <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span>&quot;</span>) -eq 0 ]; <span class="hljs-keyword">then</span>    iptables -I INPUT -s <span class="hljs-variable">$IP</span> -j DROP  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><p><strong>2 ）屏蔽每分钟 SSH 暴力破解超过 10 次的 IP</strong></p><pre><code class="hljs bash">方法 1 ：通过 lastb 获取登录状态:DATE=$(date +<span class="hljs-string">&quot;%a %b %e %H:%M&quot;</span>) <span class="hljs-comment">#星期月天时分 %e 单数字时显示 7 ，而 %d 显示 07</span>ABNORMAL_IP=$(lastb |grep <span class="hljs-string">&quot;<span class="hljs-variable">$DATE</span>&quot;</span> |awk <span class="hljs-string">&#x27;&#123;a[$3]++&#125;END&#123;for(i in a)if(a[i]&gt;10)print i&#125;&#x27;</span>)<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$ABNORMAL_IP</span>; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> [$(iptables -vnL |grep -c <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span>&quot;</span>) -eq 0 ]; <span class="hljs-keyword">then</span>    iptables -I INPUT -s <span class="hljs-variable">$IP</span> -j DROP  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span>方法 2 ：通过日志获取登录状态DATE=$(date +<span class="hljs-string">&quot;%b %d %H&quot;</span>)ABNORMAL_IP=<span class="hljs-string">&quot;<span class="hljs-subst">$(tail -n10000 /var/log/auth.log |grep<span class="hljs-string">&quot;<span class="hljs-variable">$DATE</span>&quot;</span>|awk&#x27;/Failed/&#123;a[$(NF-3)</span>]++&#125;END&#123;for(i in a)if(a[i]&gt;5)print i&#125;&#x27;)&quot;</span><span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$ABNORMAL_IP</span>; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> [$(iptables -vnL |grep -c <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span>&quot;</span>) -eq 0 ]; <span class="hljs-keyword">then</span>    iptables -A INPUT -s <span class="hljs-variable">$IP</span> -j DROP    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(date +<span class="hljs-string">&quot;%F %T&quot;</span>)</span> - iptables -A INPUT -s <span class="hljs-variable">$IP</span> -j DROP&quot;</span> &gt;&gt;~/ssh-login-limit.log  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-12-判断输入是否为-IP"><a href="#12-12-判断输入是否为-IP" class="headerlink" title="12.12 判断输入是否为 IP"></a>12.12 判断输入是否为 IP</h2><p><strong>方法 1:</strong></p><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_ip</span></span>()&#123;  IP=<span class="hljs-variable">$1</span>  VALID_CHECK=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|awk -F. <span class="hljs-string">&#x27;$1&lt;=255&amp;&amp;$2&lt;=255&amp;&amp;$3&lt;=255&amp;&amp;$4&lt;=255&#123;print&quot;yes&quot;&#125;&#x27;</span>)  <span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|grep -E <span class="hljs-string">&quot;^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$&quot;</span>&gt;/dev/null;<span class="hljs-keyword">then</span>    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$VALID_CHECK</span> == <span class="hljs-string">&quot;yes&quot;</span>]; <span class="hljs-keyword">then</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> available.&quot;</span>    <span class="hljs-keyword">else</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> not available!&quot;</span>    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Format error!&quot;</span>  <span class="hljs-keyword">fi</span>&#125;check_ip 192.168.1.1check_ip 256.1.1.1方法 2 ：<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_ip</span></span>()&#123;IP=<span class="hljs-variable">$1</span><span class="hljs-keyword">if</span> [[<span class="hljs-variable">$IP</span> =~ ^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$ ]]; <span class="hljs-keyword">then</span>  FIELD1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|cut -d. -f1)  FIELD2=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|cut -d. -f2)  FIELD3=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|cut -d. -f3)  FIELD4=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|cut -d. -f4)  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$FIELD1</span> -le 255 -a <span class="hljs-variable">$FIELD2</span> -le 255 -a <span class="hljs-variable">$FIELD3</span> -le 255 -a <span class="hljs-variable">$FIELD4</span> -le 255]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> available.&quot;</span>  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> not available!&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Format error!&quot;</span><span class="hljs-keyword">fi</span>&#125;check_ip 192.168.1.1check_ip 256.1.1.1</code></pre><p>增加版：加个死循环，如果 IP 可用就退出，不可用提示继续输入，并使用 awk 判断</p><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_ip</span></span>()&#123;<span class="hljs-built_in">local</span> IP=<span class="hljs-variable">$1</span>VALID_CHECK=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|awk -F. <span class="hljs-string">&#x27;$1&lt;=255&amp;&amp;$2&lt;=255&amp;&amp;$3&lt;=255&amp;&amp;$4&lt;=255&#123;print&quot;yes&quot;&#125;&#x27;</span>)<span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|grep -E <span class="hljs-string">&quot;^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$&quot;</span> &gt;/dev/null;<span class="hljs-keyword">then</span>  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$VALID_CHECK</span> == <span class="hljs-string">&quot;yes&quot;</span>]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">return</span> 0  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> not available!&quot;</span>    <span class="hljs-built_in">return</span> 1  <span class="hljs-keyword">fi</span><span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Format error! Please input again.&quot;</span>  <span class="hljs-built_in">return</span> 1<span class="hljs-keyword">fi</span>&#125;<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please enter IP:&quot;</span> IP  check_ip <span class="hljs-variable">$IP</span>  [$? -eq 0] &amp;&amp; <span class="hljs-built_in">break</span> || <span class="hljs-built_in">continue</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-13-判断输入是否为数字"><a href="#12-13-判断输入是否为数字" class="headerlink" title="12.13 判断输入是否为数字"></a>12.13 判断输入是否为数字</h2><pre><code class="hljs bash">方法 1 ：<span class="hljs-keyword">if</span> [[<span class="hljs-variable">$1</span> =~ ^[0-9]+$ ]]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Is Number.&quot;</span><span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No Number.&quot;</span><span class="hljs-keyword">fi</span>方法 2 ：<span class="hljs-keyword">if</span> [<span class="hljs-variable">$1</span> -gt 0] 2&gt;/dev/null; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Is Number.&quot;</span><span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No Number.&quot;</span><span class="hljs-keyword">fi</span>方法 3 ：<span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span> |awk <span class="hljs-string">&#x27;&#123;print $0~/^[0-9]+$/?&quot;Is Number.&quot;:&quot;No Number.&quot;&#125;&#x27;</span> <span class="hljs-comment">#三目运算符</span></code></pre><h2 id="12-14-找出包含关键字的文件"><a href="#12-14-找出包含关键字的文件" class="headerlink" title="12.14 找出包含关键字的文件"></a>12.14 找出包含关键字的文件</h2><pre><code class="hljs bash">DIR=<span class="hljs-variable">$1</span>KEY=<span class="hljs-variable">$2</span><span class="hljs-keyword">for</span> FILE <span class="hljs-keyword">in</span> $(find <span class="hljs-variable">$DIR</span> -<span class="hljs-built_in">type</span> f); <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> grep <span class="hljs-variable">$KEY</span> <span class="hljs-variable">$FILE</span> &amp;&gt;/dev/null; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;--&gt; <span class="hljs-variable">$FILE</span>&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-15-监控目录，将新创建的文件名追加到日志中"><a href="#12-15-监控目录，将新创建的文件名追加到日志中" class="headerlink" title="12.15 监控目录，将新创建的文件名追加到日志中"></a>12.15 监控目录，将新创建的文件名追加到日志中</h2><p>需安装 <code>inotify-tools</code> 软件包。</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>MON_DIR=/optinotifywait -mq --format %f -e create <span class="hljs-variable">$MON_DIR</span> |\<span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> files; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$files</span> &gt;&gt; test.log<span class="hljs-keyword">done</span></code></pre><h2 id="12-16-多个网卡选择"><a href="#12-16-多个网卡选择" class="headerlink" title="12.16 多个网卡选择"></a>12.16 多个网卡选择</h2><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">local_nic</span></span>() &#123;  <span class="hljs-built_in">local</span> NUM ARRAY_LENGTH  NUM=0  <span class="hljs-keyword">for</span> NIC_NAME <span class="hljs-keyword">in</span> $(ls /sys/class/net|grep - vE <span class="hljs-string">&quot;lo|docker0&quot;</span>); <span class="hljs-keyword">do</span>    NIC_IP=$(ifconfig <span class="hljs-variable">$NIC_NAME</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/inet addr/&#123;print $4&#125;&#x27;</span>)    <span class="hljs-keyword">if</span> [-n <span class="hljs-string">&quot;<span class="hljs-variable">$NIC_IP</span>&quot;</span>]; <span class="hljs-keyword">then</span>      NIC_IP_ARRAY[<span class="hljs-variable">$NUM</span>]=<span class="hljs-string">&quot;<span class="hljs-variable">$NIC_NAME</span>:<span class="hljs-variable">$NIC_IP</span>&quot;</span> <span class="hljs-comment">#将网卡名和对应 IP 放到数组</span>      <span class="hljs-built_in">let</span> NUM++    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span>  ARRAY_LENGTH=<span class="hljs-variable">$&#123;#NIC_IP_ARRAY[*]&#125;</span>  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$ARRAY_LENGTH</span> -eq 1]; <span class="hljs-keyword">then</span> <span class="hljs-comment">#如果数组里面只有一条记录说明就一个网卡</span>    NIC=<span class="hljs-variable">$&#123;NIC_IP_ARRAY[0]%:*&#125;</span>    <span class="hljs-built_in">return</span> 0  <span class="hljs-keyword">elif</span> [<span class="hljs-variable">$ARRAY_LENGTH</span> -eq 0]; <span class="hljs-keyword">then</span> <span class="hljs-comment">#如果没有记录说明没有网卡</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No available network card!&quot;</span>    <span class="hljs-built_in">exit</span> 1  <span class="hljs-keyword">else</span>  <span class="hljs-comment">#如果有多条记录则提醒输入选择</span>    <span class="hljs-keyword">for</span> NIC <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;NIC_IP_ARRAY[*]&#125;</span>; <span class="hljs-keyword">do</span>      <span class="hljs-built_in">echo</span> <span class="hljs-variable">$NIC</span>    <span class="hljs-keyword">done</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>      <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please enter local use to network card name:&quot;</span> INPUT_NIC_NAME      COUNT=0      <span class="hljs-keyword">for</span> NIC <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;NIC_IP_ARRAY[*]&#125;</span>; <span class="hljs-keyword">do</span>        NIC_NAME=<span class="hljs-variable">$&#123;NIC%:*&#125;</span>        <span class="hljs-keyword">if</span> [<span class="hljs-variable">$NIC_NAME</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$INPUT_NIC_NAME</span>&quot;</span>]; <span class="hljs-keyword">then</span>          NIC=<span class="hljs-variable">$&#123;NIC_IP_ARRAY[$COUNT]%:*&#125;</span>          <span class="hljs-built_in">return</span> 0        <span class="hljs-keyword">else</span>          COUNT+=1        <span class="hljs-keyword">fi</span>      <span class="hljs-keyword">done</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Not match! Please input again.&quot;</span>    <span class="hljs-keyword">done</span>  <span class="hljs-keyword">fi</span>&#125;local_nic</code></pre><p>如果有只有一个网卡就不选择。</p><h2 id="12-17-查看网卡实时流量"><a href="#12-17-查看网卡实时流量" class="headerlink" title="12.17 查看网卡实时流量"></a>12.17 查看网卡实时流量</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># Description: Only CentOS6</span><span class="hljs-function"><span class="hljs-title">traffic_unit_conv</span></span>() &#123;  <span class="hljs-built_in">local</span> traffic=<span class="hljs-variable">$1</span>  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$traffic</span> -gt 1024000]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%.1f%s&quot;</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(($traffic/1024/1024)</span>)&quot;</span> <span class="hljs-string">&quot;MB/s&quot;</span>  <span class="hljs-keyword">elif</span> [<span class="hljs-variable">$traffic</span> -lt 1024000]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%.1f%s&quot;</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(($traffic/1024)</span>)&quot;</span> <span class="hljs-string">&quot;KB/s&quot;</span>  <span class="hljs-keyword">fi</span>&#125;NIC=<span class="hljs-variable">$1</span><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;In ------ Out&quot;</span><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>  OLD_IN=$(awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;$0~&quot;&#x27;</span><span class="hljs-variable">$NIC</span><span class="hljs-string">&#x27;&quot;&#123;print $3&#125;&#x27;</span> /proc/net/dev)  OLD_OUT=$(awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;$0~&quot;&#x27;</span><span class="hljs-variable">$NIC</span><span class="hljs-string">&#x27;&quot;&#123;print $11&#125;&#x27;</span> /proc/net/dev)  sleep 1  NEW_IN=$(awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;$0~&quot;&#x27;</span><span class="hljs-variable">$NIC</span><span class="hljs-string">&#x27;&quot;&#123;print $3&#125;&#x27;</span> /proc/net/dev)  NEW_OUT=$(awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;$0~&quot;&#x27;</span><span class="hljs-variable">$NIC</span><span class="hljs-string">&#x27;&quot;&#123;print $11&#125;&#x27;</span> /proc/net/dev)  IN=$((<span class="hljs-variable">$NEW_IN</span>-<span class="hljs-variable">$OLD_IN</span>))  OUT=$((<span class="hljs-variable">$NEW_OUT</span>-<span class="hljs-variable">$OLD_OUT</span>))  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(traffic_unit_conv $IN)</span> <span class="hljs-subst">$(traffic_unit_conv $OUT)</span>&quot;</span>  sleep 1<span class="hljs-keyword">done</span><span class="hljs-comment"># 也可以通过 ficonfig 命令获取收发流量</span><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>  OLD_IN=$(ifconfig <span class="hljs-variable">$NIC</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/bytes/&#123;print $4&#125;&#x27;</span>)  OLD_OUT=$(ifconfig <span class="hljs-variable">$NIC</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/bytes/&#123;print $9&#125;&#x27;</span>)  sleep 1  NEW_IN=$(ifconfig <span class="hljs-variable">$NIC</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/bytes/&#123;print $4&#125;&#x27;</span>)  NEW_OUT=$(ifconfig <span class="hljs-variable">$NIC</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/bytes/&#123;print $9&#125;&#x27;</span>)  IN=$((<span class="hljs-variable">$NEW_IN</span>-<span class="hljs-variable">$OLD_IN</span>))  OUT=$((<span class="hljs-variable">$NEW_OUT</span>-<span class="hljs-variable">$OLD_OUT</span>))  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(traffic_unit_conv $IN)</span> <span class="hljs-subst">$(traffic_unit_conv $OUT)</span>&quot;</span>  sleep 1<span class="hljs-keyword">done</span></code></pre><h2 id="12-18-MySQL-数据库备份"><a href="#12-18-MySQL-数据库备份" class="headerlink" title="12.18 MySQL 数据库备份"></a>12.18 MySQL 数据库备份</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>DATE=$(date +%F_%H-%M-%S)HOST=192.168.1.120DB=<span class="hljs-built_in">test</span>USER=bakPASS=123456MAIL=<span class="hljs-string">&quot;zhangsan@example.com lisi@example.com&quot;</span>BACKUP_DIR=/data/db_backupSQL_FILE=<span class="hljs-variable">$&#123;DB&#125;</span>_full_<span class="hljs-variable">$DATE</span>.sqlBAK_FILE=<span class="hljs-variable">$&#123;DB&#125;</span>_full_<span class="hljs-variable">$DATE</span>.zip<span class="hljs-built_in">cd</span> <span class="hljs-variable">$BACKUP_DIR</span><span class="hljs-keyword">if</span> mysqldump - h<span class="hljs-variable">$HOST</span> - u<span class="hljs-variable">$USER</span> - p<span class="hljs-variable">$PASS</span> --single-transaction --routines --triggers - B <span class="hljs-variable">$DB</span> &gt; <span class="hljs-variable">$SQL_FILE</span>; <span class="hljs-keyword">then</span>  zip <span class="hljs-variable">$BAK_FILE</span> <span class="hljs-variable">$SQL_FILE</span> &amp;&amp; rm - f <span class="hljs-variable">$SQL_FILE</span>  <span class="hljs-keyword">if</span> [! - s <span class="hljs-variable">$BAK_FILE</span>]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$DATE</span> 内容&quot;</span> | mail -s <span class="hljs-string">&quot;主题&quot;</span> <span class="hljs-variable">$MAIL</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">else</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$DATE</span> 内容&quot;</span> | mail -s <span class="hljs-string">&quot;主题&quot;</span> <span class="hljs-variable">$MAIL</span><span class="hljs-keyword">fi</span>find <span class="hljs-variable">$BACKUP_DIR</span> -name <span class="hljs-string">&#x27;*.zip&#x27;</span> -ctime +14 -<span class="hljs-built_in">exec</span> rm &#123;&#125; \;</code></pre><h2 id="12-19-Nginx-启动脚本"><a href="#12-19-Nginx-启动脚本" class="headerlink" title="12.19 Nginx 启动脚本"></a>12.19 Nginx 启动脚本</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># Description: Only support RedHat system</span>. /etc/init.d/<span class="hljs-built_in">functions</span>WORD_DIR=/data/project/nginx1.10DAEMON=<span class="hljs-variable">$WORD_DIR</span>/sbin/nginxCONF=<span class="hljs-variable">$WORD_DIR</span>/conf/nginx.confNAME=nginxPID=$(awk -F<span class="hljs-string">&#x27;[;]+&#x27;</span> <span class="hljs-string">&#x27;/^[^#]/&#123;if($0~/pid;/)print $2&#125;&#x27;</span> <span class="hljs-variable">$CONF</span>)<span class="hljs-keyword">if</span> [-z <span class="hljs-string">&quot;<span class="hljs-variable">$PID</span>&quot;</span>]; <span class="hljs-keyword">then</span>  PID=<span class="hljs-variable">$WORD_DIR</span>/logs/nginx.pid<span class="hljs-keyword">else</span>  PID=<span class="hljs-variable">$WORD_DIR</span>/<span class="hljs-variable">$PID</span><span class="hljs-keyword">fi</span><span class="hljs-function"><span class="hljs-title">stop</span></span>() &#123;  <span class="hljs-variable">$DAEMON</span> -s stop  sleep 1  [! -f <span class="hljs-variable">$PID</span>] &amp;&amp; action <span class="hljs-string">&quot;* Stopping <span class="hljs-variable">$NAME</span>&quot;</span> /bin/<span class="hljs-literal">true</span> || action <span class="hljs-string">&quot;* Stopping <span class="hljs-variable">$NAME</span>&quot;</span> /bin/<span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-title">start</span></span>() &#123;  <span class="hljs-variable">$DAEMON</span>  sleep 1  [-f <span class="hljs-variable">$PID</span>] &amp;&amp; action <span class="hljs-string">&quot;* Starting <span class="hljs-variable">$NAME</span>&quot;</span> /bin/<span class="hljs-literal">true</span> || action <span class="hljs-string">&quot;* Starting <span class="hljs-variable">$NAME</span>&quot;</span> /bin/<span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-title">reload</span></span>() &#123;  <span class="hljs-variable">$DAEMON</span> -s reload&#125;<span class="hljs-function"><span class="hljs-title">test_config</span></span>() &#123;  <span class="hljs-variable">$DAEMON</span> -t&#125;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span>  start)  <span class="hljs-keyword">if</span> [! -f <span class="hljs-variable">$PID</span>]; <span class="hljs-keyword">then</span>    start  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> is running...&quot;</span>    <span class="hljs-built_in">exit</span> 0  <span class="hljs-keyword">fi</span>  ;;  stop)  <span class="hljs-keyword">if</span> [-f <span class="hljs-variable">$PID</span>]; <span class="hljs-keyword">then</span>    stop  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> not running!&quot;</span>    <span class="hljs-built_in">exit</span> 0  <span class="hljs-keyword">fi</span>  ;;  restart)  <span class="hljs-keyword">if</span> [! -f <span class="hljs-variable">$PID</span>]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> not running!&quot;</span>    start  <span class="hljs-keyword">else</span>    stop    start  <span class="hljs-keyword">fi</span>  ;;  reload)  reload  ;;  testconfig)  test_config  ;;  status)  [-f <span class="hljs-variable">$PID</span>] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> is running...&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> not running!&quot;</span>  ;;  *)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: $ 0 &#123;start|stop|restart|reload|testconfig|status&#125;&quot;</span>  <span class="hljs-built_in">exit</span> 3  ;;<span class="hljs-keyword">esac</span></code></pre><h2 id="12-20-选择-SSH-连接主机"><a href="#12-20-选择-SSH-连接主机" class="headerlink" title="12.20 选择 SSH 连接主机"></a>12.20 选择 SSH 连接主机</h2><p>写一个配置文件保存被监控主机 SSH 连接信息，文件内容格式：主机名 IP User Port</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>PS3=<span class="hljs-string">&quot;Please input number:&quot;</span>HOST_FILE=host<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>  select NAME <span class="hljs-keyword">in</span> $(awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="hljs-variable">$HOST_FILE</span>) quit; <span class="hljs-keyword">do</span>    [<span class="hljs-variable">$&#123;NAME:=empty&#125;</span> == <span class="hljs-string">&quot;quit&quot;</span> ] &amp;&amp; <span class="hljs-built_in">exit</span> 0    IP=$(awk - v NAME=<span class="hljs-variable">$&#123;NAME&#125;</span> <span class="hljs-string">&#x27;$1==NAME&#123;print $2&#125;&#x27;</span> <span class="hljs-variable">$HOST_FILE</span>)    USER=$(awk - v NAME=<span class="hljs-variable">$&#123;NAME&#125;</span> <span class="hljs-string">&#x27;$1==NAME&#123;print $3&#125;&#x27;</span> <span class="hljs-variable">$HOST_FILE</span>)    PORT=$(awk - v NAME=<span class="hljs-variable">$&#123;NAME&#125;</span> <span class="hljs-string">&#x27;$1==NAME&#123;print $4&#125;&#x27;</span> <span class="hljs-variable">$HOST_FILE</span>)    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$IP</span>]; <span class="hljs-keyword">then</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Name: <span class="hljs-variable">$NAME</span>, IP: <span class="hljs-variable">$IP</span>&quot;</span>      ssh -o StrictHostKeyChecking=no -p <span class="hljs-variable">$PORT</span> -i id_rsa <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span> <span class="hljs-comment"># 密钥登录</span>      <span class="hljs-built_in">break</span>    <span class="hljs-keyword">else</span>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Input error, Please enter again!&quot;</span>      <span class="hljs-built_in">break</span>    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-21-FTP-下载文件"><a href="#12-21-FTP-下载文件" class="headerlink" title="12.21 FTP 下载文件"></a>12.21 FTP 下载文件</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">if</span> [<span class="hljs-variable">$#</span> -ne 1]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$0</span> filename&quot;</span><span class="hljs-keyword">fi</span>dir=$(dirname <span class="hljs-variable">$1</span>)file=$(basename <span class="hljs-variable">$1</span>)ftp -n -v &lt;&lt; EOF <span class="hljs-comment"># -n 自动登录</span>open 192.168.1.10user admin adminpassbinary <span class="hljs-comment"># 设置 ftp 传输模式为二进制，避免 MD5 值不同或. tar.gz 压缩包格式错误</span><span class="hljs-built_in">cd</span> <span class="hljs-variable">$dir</span>get <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>EOF</code></pre><h2 id="12-22-输入五个-100-数之内的字符，统计和、最小和最大"><a href="#12-22-输入五个-100-数之内的字符，统计和、最小和最大" class="headerlink" title="12.22 输入五个 100 数之内的字符，统计和、最小和最大"></a>12.22 输入五个 100 数之内的字符，统计和、最小和最大</h2><pre><code class="hljs bash">COUNT=1SUM=0MIN=0MAX=100<span class="hljs-keyword">while</span> [<span class="hljs-variable">$COUNT</span> -le 5]; <span class="hljs-keyword">do</span>  <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入 1 - 10 个整数：&quot;</span> INT  <span class="hljs-keyword">if</span> [[! <span class="hljs-variable">$INT</span> =~ ^[0-9]+$ ]]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;输入必须是整数！&quot;</span>    <span class="hljs-built_in">exit</span> 1  <span class="hljs-keyword">elif</span> [[<span class="hljs-variable">$INT</span> -gt 100]]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;输入必须是 100 以内！&quot;</span>    <span class="hljs-built_in">exit</span> 1  <span class="hljs-keyword">fi</span>SUM=$((<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$INT</span>))[<span class="hljs-variable">$MIN</span> -lt <span class="hljs-variable">$INT</span>] &amp;&amp; MIN=<span class="hljs-variable">$INT</span>[<span class="hljs-variable">$MAX</span> -gt <span class="hljs-variable">$INT</span>] &amp;&amp; MAX=<span class="hljs-variable">$INT</span><span class="hljs-built_in">let</span> COUNT++<span class="hljs-keyword">done</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;SUM: <span class="hljs-variable">$SUM</span>&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;MIN: <span class="hljs-variable">$MIN</span>&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;MAX: <span class="hljs-variable">$MAX</span>&quot;</span></code></pre><h2 id="12-23-将结果分别赋值给变量"><a href="#12-23-将结果分别赋值给变量" class="headerlink" title="12.23 将结果分别赋值给变量"></a>12.23 将结果分别赋值给变量</h2><pre><code class="hljs bash">方法 1 ：<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;4 5 6&quot;</span>); <span class="hljs-keyword">do</span>  <span class="hljs-built_in">eval</span> a<span class="hljs-variable">$i</span>=<span class="hljs-variable">$i</span><span class="hljs-keyword">done</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$a4</span> <span class="hljs-variable">$a5</span> <span class="hljs-variable">$a6</span>方法 2 ：将位置参数 192.168.18.1&#123;1,2&#125; 拆分为到每个变量num=0<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">eval</span> <span class="hljs-built_in">echo</span> $*);<span class="hljs-keyword">do</span> <span class="hljs-comment">#eval 将 &#123;1,2&#125; 分解为 1 2</span>  <span class="hljs-built_in">let</span> num+=1  <span class="hljs-built_in">eval</span> node<span class="hljs-variable">$&#123;num&#125;</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span><span class="hljs-keyword">done</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$node1</span> <span class="hljs-variable">$node2</span> <span class="hljs-variable">$node3</span><span class="hljs-comment"># bash a.sh 192.168.18.1&#123;1,2&#125;</span>192.168.18.11 192.168.18.12方法 3 ：arr=(4 5 6)INDEX1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[0]&#125;</span>)INDEX2=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[1]&#125;</span>)INDEX3=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[2]&#125;</span>)</code></pre><h2 id="12-24-批量修改文件名"><a href="#12-24-批量修改文件名" class="headerlink" title="12. 24 批量修改文件名"></a>12. 24 批量修改文件名</h2><pre><code class="hljs bash"><span class="hljs-comment"># touch article_&#123;1..3&#125;.html</span><span class="hljs-comment"># ls</span>article_1.html article_2.html article_3.html</code></pre><p>现在想把 article 改为 bbs：</p><pre><code class="hljs bash">方法 1 ：<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(ls *html); <span class="hljs-keyword">do</span>  mv <span class="hljs-variable">$file</span> bbs_<span class="hljs-variable">$&#123;file#*_&#125;</span><span class="hljs-comment"># mv $file $(echo $file |sed - r &#x27;s/.*(_.*)/bbs\1/&#x27;)</span><span class="hljs-comment"># mv $file $(echo $file |echo bbs_$(cut - d_ - f2)</span><span class="hljs-keyword">done</span>方法 2 ：<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(find. -maxdepth 1 -name <span class="hljs-string">&quot;*html&quot;</span>); <span class="hljs-keyword">do</span>  mv <span class="hljs-variable">$file</span> bbs_<span class="hljs-variable">$&#123;file#*_&#125;</span><span class="hljs-keyword">done</span>方法 3 ：<span class="hljs-comment"># rename article bbs *.html</span></code></pre><h2 id="12-25-统计当前目录中以-html-结尾的文件总大小"><a href="#12-25-统计当前目录中以-html-结尾的文件总大小" class="headerlink" title="12.25 统计当前目录中以 .html 结尾的文件总大小"></a>12.25 统计当前目录中以 .html 结尾的文件总大小</h2><pre><code class="hljs bash">方法 1 ：<span class="hljs-comment"># find. -name &quot;*.html&quot; -maxdepth 1 -exec du -b &#123;&#125; \; |awk &#x27;&#123;sum+=$1&#125;END&#123;print sum&#125;&#x27;</span>方法 2 ：<span class="hljs-keyword">for</span> size <span class="hljs-keyword">in</span> $(ls -l *.html |awk <span class="hljs-string">&#x27;&#123;print $5&#125;&#x27;</span>); <span class="hljs-keyword">do</span>  sum=$((<span class="hljs-variable">$sum</span>+<span class="hljs-variable">$size</span>))<span class="hljs-keyword">done</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$sum</span>递归统计：<span class="hljs-comment"># find. -name &quot;*.html&quot; -exec du -k &#123;&#125; \; |awk &#x27;&#123;sum+=$1&#125;END&#123;print sum&#125;&#x27;</span></code></pre><h2 id="12-26-扫描主机端口状态"><a href="#12-26-扫描主机端口状态" class="headerlink" title="12.26 扫描主机端口状态"></a>12.26 扫描主机端口状态</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>HOST=<span class="hljs-variable">$1</span>PORT=<span class="hljs-string">&quot;22 25 80 8080&quot;</span><span class="hljs-keyword">for</span> PORT <span class="hljs-keyword">in</span> <span class="hljs-variable">$PORT</span>; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> &amp;&gt;/dev/null &gt; /dev/tcp/<span class="hljs-variable">$HOST</span>/<span class="hljs-variable">$PORT</span>; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$PORT</span> open&quot;</span>  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$PORT</span> close&quot;</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-27-Expect-实现-SSH-免交互执行命令"><a href="#12-27-Expect-实现-SSH-免交互执行命令" class="headerlink" title="12.27 Expect 实现 SSH 免交互执行命令"></a>12.27 Expect 实现 SSH 免交互执行命令</h2><p>需要先安装 <code>expect</code> 工具。</p><p>expect 涉及用法说明：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set</td><td>可以设置超时，也可以设置变量</td></tr><tr><td>timeout</td><td>超时等待时间，默认 10s</td></tr><tr><td>spawn</td><td>执行一个命令</td></tr><tr><td>expect “”</td><td>匹配输出的内容</td></tr><tr><td>exp_continue</td><td>继续执行下面匹配</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>$argc</td><td>统计位置参数数量</td></tr><tr><td>[lindex $argv 0]</td><td>位置参数</td></tr><tr><td>puts</td><td>打印字符串，类似于 echo</td></tr><tr><td>expect{…}</td><td>输入多行记录</td></tr></tbody></table><p><strong>方法 1 ：EOF 标准输出作为 expect 标准输入</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>USER=rootPASS=123.comIP=192.168.1.120expect &lt;&lt; EOF<span class="hljs-built_in">set</span> timeout 30spawn ssh <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span>expect &#123;<span class="hljs-string">&quot;(yes/no)&quot;</span> &#123;send <span class="hljs-string">&quot;yes\r&quot;</span>; exp_continue&#125;<span class="hljs-string">&quot;password:&quot;</span> &#123;send <span class="hljs-string">&quot;<span class="hljs-variable">$PASS</span>\r&quot;</span>&#125;&#125;expect <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>@*&quot;</span> &#123;send <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>\r&quot;</span>&#125;expect <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>@*&quot;</span> &#123;send <span class="hljs-string">&quot;exit\r&quot;</span>&#125;expect eofEOF</code></pre><p><strong>方法 2 ：</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>USER=rootPASS=123.comIP=192.168.1.120expect -c <span class="hljs-string">&quot;</span><span class="hljs-string">  spawn ssh <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span></span><span class="hljs-string">  expect &#123;</span><span class="hljs-string">    \&quot;(yes/no)\&quot; &#123;send \&quot;yes\r\&quot;; exp_continue&#125;</span><span class="hljs-string">    \&quot;password:\&quot; &#123;send \&quot;<span class="hljs-variable">$PASS</span>\r\&quot;; exp_continue&#125;</span><span class="hljs-string">    \&quot;<span class="hljs-variable">$USER</span>@*\&quot; &#123;send \&quot;df -h\r exit\r\&quot;; exp_continue&#125;</span><span class="hljs-string">  &#125;&quot;</span></code></pre><p><strong>方法 3 ：将 expect 脚本独立出来</strong></p><p>login.exp 登录文件：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/expect</span><span class="hljs-built_in">set</span> ip [lindex <span class="hljs-variable">$argv</span> 0]<span class="hljs-built_in">set</span> user [lindex <span class="hljs-variable">$argv</span> 1]<span class="hljs-built_in">set</span> passwd [lindex <span class="hljs-variable">$argv</span> 2]<span class="hljs-built_in">set</span> cmd [lindex <span class="hljs-variable">$argv</span> 3]<span class="hljs-keyword">if</span> &#123;<span class="hljs-variable">$argc</span> != 4&#125; &#123;  puts <span class="hljs-string">&quot;Usage: expect login.exp ip user passwd&quot;</span>  <span class="hljs-built_in">exit</span> 1&#125;<span class="hljs-built_in">set</span> timeout 30spawn ssh <span class="hljs-variable">$user</span>@<span class="hljs-variable">$ip</span>expect &#123;  <span class="hljs-string">&quot;(yes/no)&quot;</span> &#123;send <span class="hljs-string">&quot;yes\r&quot;</span>; exp_continue&#125;  <span class="hljs-string">&quot;password:&quot;</span> &#123;send <span class="hljs-string">&quot;<span class="hljs-variable">$passwd</span>\r&quot;</span>&#125;&#125;expect <span class="hljs-string">&quot;<span class="hljs-variable">$user</span>@*&quot;</span> &#123;send <span class="hljs-string">&quot;<span class="hljs-variable">$cmd</span>\r&quot;</span>&#125;expect <span class="hljs-string">&quot;<span class="hljs-variable">$user</span>@*&quot;</span> &#123;send <span class="hljs-string">&quot;exit\r&quot;</span>&#125;expect eof</code></pre><p>执行命令脚本：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>HOST_INFO=user_info<span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> $(awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)<span class="hljs-keyword">do</span>  user=$(awk -v I=<span class="hljs-string">&quot;<span class="hljs-variable">$ip</span>&quot;</span> <span class="hljs-string">&#x27;I==$1&#123;print $2&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)  pass=$(awk -v I=<span class="hljs-string">&quot;<span class="hljs-variable">$ip</span>&quot;</span> <span class="hljs-string">&#x27;I==$1&#123;print $3&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)  expect login.exp <span class="hljs-variable">$ip</span> <span class="hljs-variable">$user</span> <span class="hljs-variable">$pass</span> <span class="hljs-variable">$1</span><span class="hljs-keyword">done</span></code></pre><p>SSH 连接信息文件：</p><pre><code class="hljs bash"><span class="hljs-comment"># cat user_info</span>192.168.1.120 root 123 456</code></pre><h2 id="12-28-批量修改服务器用户密码"><a href="#12-28-批量修改服务器用户密码" class="headerlink" title="12.28 批量修改服务器用户密码"></a>12.28 批量修改服务器用户密码</h2><p>旧密码 SSH 主机信息 old_info 文件：</p><pre><code class="hljs bash"><span class="hljs-comment"># ip user passwd port</span><span class="hljs-comment">#--------------------------------------</span>192.168.18.217 root 123456 22192.168.18.218 root 123456 22</code></pre><p>修改密码脚本：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>OLD_INFO=old_infoNEW_INFO=new_info<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> $(awk <span class="hljs-string">&#x27;/^[^#]/&#123;print $1&#125;&#x27;</span> <span class="hljs-variable">$OLD_INFO</span>); <span class="hljs-keyword">do</span>  USER=$(awk -v I=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;I==$1&#123;print $2&#125;&#x27;</span> <span class="hljs-variable">$OLD_INFO</span>)  PASS=$(awk -v I=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;I==$1&#123;print $3&#125;&#x27;</span> <span class="hljs-variable">$OLD_INFO</span>)  PORT=$(awk -v I=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;I==$1&#123;print $4&#125;&#x27;</span> <span class="hljs-variable">$OLD_INFO</span>)  NEW_PASS=$(mkpasswd -l 8)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> <span class="hljs-variable">$USER</span> <span class="hljs-variable">$NEW_PASS</span> <span class="hljs-variable">$PORT</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$NEW_INFO</span>  expect -c <span class="hljs-string">&quot;</span><span class="hljs-string">  spawn ssh -p<span class="hljs-variable">$PORT</span> <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span></span><span class="hljs-string">  set timeout 2</span><span class="hljs-string">  expect &#123;</span><span class="hljs-string">    \&quot;(yes/no)\&quot; &#123;send \&quot;yes\r\&quot;;exp_continue&#125;</span><span class="hljs-string">    \&quot;password:\&quot; &#123;send \&quot;<span class="hljs-variable">$PASS</span>\r\&quot;;exp_continue&#125;</span><span class="hljs-string">    \&quot;<span class="hljs-variable">$USER</span>@*\&quot; &#123;send \&quot;echo \&#x27;<span class="hljs-variable">$NEW_PASS</span>\&#x27;|passwd --stdin <span class="hljs-variable">$USER</span>\rexit\r\&quot;;exp_continue&#125;</span><span class="hljs-string">  &#125;&quot;</span><span class="hljs-keyword">done</span></code></pre><p>生成新密码 new_info 文件：</p><pre><code class="hljs bash">192.168.18.217 root n8wX3mU% 22192.168.18.218 root c87;ZnnL 22</code></pre><h2 id="12-29-打印乘法口诀"><a href="#12-29-打印乘法口诀" class="headerlink" title="12.29 打印乘法口诀"></a>12.29 打印乘法口诀</h2><pre><code class="hljs bash">方法 1 ：<span class="hljs-comment"># awk &#x27;BEGIN&#123;for(n=0;n++&lt;9;)&#123;for(i=0;i++&lt;n;)printf i&quot;x&quot;n&quot;=&quot;i*n&quot; &quot;;print&quot;&quot;&#125;&#125;&#x27;</span>方法 2 ：<span class="hljs-keyword">for</span> ((i=1;i&lt;=9;i++)); <span class="hljs-keyword">do</span>  <span class="hljs-keyword">for</span> ((j=1;j&lt;=i;j++)); <span class="hljs-keyword">do</span>    result=$((<span class="hljs-variable">$i</span>*<span class="hljs-variable">$j</span>))    <span class="hljs-built_in">echo</span> - n <span class="hljs-string">&quot;<span class="hljs-variable">$j</span>*<span class="hljs-variable">$i</span>=<span class="hljs-variable">$result</span>&quot;</span>  <span class="hljs-keyword">done</span>  <span class="hljs-built_in">echo</span><span class="hljs-keyword">done</span></code></pre><h2 id="12-30-getopts-工具完善脚本命令行参数"><a href="#12-30-getopts-工具完善脚本命令行参数" class="headerlink" title="12.30 getopts 工具完善脚本命令行参数"></a>12.30 getopts 工具完善脚本命令行参数</h2><p>getopts 是一个解析脚本选项参数的工具。</p><p>命令格式：getopts optstring name [arg]</p><p>初次使用你要注意这几点：</p><ul><li>1 ）脚本位置参数会与 optstring 中的单个字母逐个匹配，如果匹配到就赋值给 name，否则赋值 name 为问号；</li><li>2 ）optstring 中单个字母是一个选项，如果字母后面加冒号，表示该选项后面带参数，参数值并会赋值给 OPTARG 变量；</li><li>3 ）optstring 中第一个是冒号，表示屏蔽系统错误（test.sh: illegal option – h）；</li><li>4 ）允许把选项放一起，例如 - ab</li></ul><p>下面写一个打印文件指定行的简单例子，用于引导你思路，扩展你的脚本选项功能：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">while</span> <span class="hljs-built_in">getopts</span> :f:n: option; <span class="hljs-keyword">do</span>  <span class="hljs-keyword">case</span> <span class="hljs-variable">$option</span> <span class="hljs-keyword">in</span>  f)    FILE=<span class="hljs-variable">$OPTARG</span>    [! -f <span class="hljs-variable">$FILE</span>] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$FILE</span> File not exist!&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span>  ;;  n)    sed -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;OPTARG&#125;</span>p&quot;</span> <span class="hljs-variable">$FILE</span>  ;;  ?)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$0</span> -f &lt;file_path&gt; -n &lt;line_number&gt;&quot;</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-f, --file specified file&quot;</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-n, --line-number print specified line&quot;</span>    <span class="hljs-built_in">exit</span> 1  ;;  <span class="hljs-keyword">esac</span><span class="hljs-keyword">done</span><span class="hljs-comment"># bash test.sh -h</span>Usage: test.sh -f &lt;file_path&gt; -n &lt;line_number&gt;-f, --file specified file-n, --line-number <span class="hljs-built_in">print</span> specified line<span class="hljs-comment"># bash test.sh -f /etc/passwd -n 1</span>root:x:0:0:root:/root:/bin/bash</code></pre><p>思路扩展：限定脚本参数，将参数保存变量，下面调用变量继续操作。</p><blockquote><p>作者信息 李振良（阿良），微信：init 1024<br>官方网站 <a href="http://www.ctnrs.com/">http://www.ctnrs.com</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 运维基本功学习路径</title>
    <link href="/2020/09/24/linux_base/"/>
    <url>/2020/09/24/linux_base/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-安装、配置、基础命令"><a href="#一、-安装、配置、基础命令" class="headerlink" title="一、 安装、配置、基础命令"></a>一、 安装、配置、基础命令</h1><h2 id="1-1-镜像文件下载"><a href="#1-1-镜像文件下载" class="headerlink" title="1.1 镜像文件下载"></a>1.1 镜像文件下载</h2><h3 id="1-1-1-CentOS-镜像"><a href="#1-1-1-CentOS-镜像" class="headerlink" title="1.1.1 CentOS 镜像"></a>1.1.1 CentOS 镜像</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>CentOS，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。</p><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><p>下载地址：</p><ul><li><a href="https://mirrors.aliyun.com/centos/">阿里源</a></li><li><a href="http://mirrors.163.com/centos/">163源</a></li></ul><h3 id="1-1-2-Ubuntu-镜像"><a href="#1-1-2-Ubuntu-镜像" class="headerlink" title="1.1.2 Ubuntu 镜像"></a>1.1.2 Ubuntu 镜像</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Ubuntu，是一款基于 Debian Linux 的以桌面应用为主的操作系统，内容涵盖文字处理、电子邮件、软件开发工具和 Web 服务等，可供用户免费下载、使用和分享。</p><h4 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://mirrors.aliyun.com/ubuntu/">阿里源</a></li><li><a href="http://mirrors.163.com/ubuntu-releases/">163源</a></li></ul><h2 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h2><h3 id="1-2-1-分区"><a href="#1-2-1-分区" class="headerlink" title="1.2.1 分区"></a>1.2.1 分区</h3><p>关于分区详细：<a href="https://ecarry.cc/2020/06/09/Linux_part/#">关于 Linux 分区的小事</a></p><h3 id="1-2-2-强制使用-GPT-来分区"><a href="#1-2-2-强制使用-GPT-来分区" class="headerlink" title="1.2.2 强制使用 GPT 来分区"></a>1.2.2 强制使用 GPT 来分区</h3><blockquote><p>如果硬盘容量小于 2TB 的话，系统预设会使用 MBR 模式来安装。</p></blockquote><ol><li>在安装界面，如图所示，按下 <code>Tab</code> 键，在后面输入 <code>inst.gpt</code>：</li></ol><p><img src="/img/linux_base/linux_base_1.jpg"></p><ol start="2"><li>在分区界面需要添加 <code>biosboot</code> 分区，此分区供 <strong>bios</strong> 使用，必须创建，而使用 MBR 分区就无需此分区。</li></ol><p><img src="/img/linux_base/linux_base_2.jpg"></p><p>参考资料: </p><p>wiki: <a href="https://en.wikipedia.org/wiki/BIOS_boot_partition">BIOS boot partition</a></p><ol start="3"><li>其余分区按需分配</li></ol><h3 id="1-2-3-测试安装设备的稳定性"><a href="#1-2-3-测试安装设备的稳定性" class="headerlink" title="1.2.3 测试安装设备的稳定性"></a>1.2.3 测试安装设备的稳定性</h3><p>CentOS 安装镜像自带烧机功能，如图：</p><p><img src="/img/linux_base/linux_base_3.jpg"></p><p>测试界面：</p><p><img src="/img/linux_base/linux_base_4.jpg"></p><h2 id="1-3-基础命令"><a href="#1-3-基础命令" class="headerlink" title="1.3 基础命令"></a>1.3 基础命令</h2><h3 id="1-3-1-locale"><a href="#1-3-1-locale" class="headerlink" title="1.3.1 locale"></a>1.3.1 locale</h3><p>运行时地区、语言、字符集和时区</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># locale</span>LANG=en_US.UTF-8                    &lt;--- 语言，只与输出信息有关LC_CTYPE=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_NUMERIC=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_TIME=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>               &lt;--- 时区LC_COLLATE=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_MONETARY=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_MESSAGES=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_PAPER=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_NAME=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_ADDRESS=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_TELEPHONE=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_MEASUREMENT=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_IDENTIFICATION=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span>LC_ALL=                             &lt;--- 修改所有</code></pre><p>修改输出信息为中文：</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># LANG=zh_CN.UTF-8</span></code></pre><h3 id="1-3-2-date"><a href="#1-3-2-date" class="headerlink" title="1.3.2 date"></a>1.3.2 date</h3><p>时间命令</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># date</span>Thu Sep 24 21:50:28 CST 2020</code></pre><p>格式化时间：</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># date &#x27;+%Y-%m-%d %H:%M:%S&#x27;</span>2020-09-24 21:52:49</code></pre><h3 id="1-3-3-cal"><a href="#1-3-3-cal" class="headerlink" title="1.3.3 cal"></a>1.3.3 cal</h3><p>日历</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cal</span><span class="hljs-comment">#显示当月月份</span>   September 2020   Su Mo Tu We Th Fr Sa       1  2  3  4  5 6  7  8  9 10 11 1213 14 15 16 17 18 1920 21 22 23 24 25 2627 28 29 30[root@localhost ~]<span class="hljs-comment"># cal 2020</span><span class="hljs-comment">#显示2020年月份</span>                               2020                                      January               February                 March       Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa          1  2  3  4                      1    1  2  3  4  5  6  7 5  6  7  8  9 10 11    2  3  4  5  6  7  8    8  9 10 11 12 13 1412 13 14 15 16 17 18    9 10 11 12 13 14 15   15 16 17 18 19 20 2119 20 21 22 23 24 25   16 17 18 19 20 21 22   22 23 24 25 26 27 2826 27 28 29 30 31      23 24 25 26 27 28 29   29 30 31        April                   May                   June        Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa          1  2  3  4                   1  2       1  2  3  4  5  6 5  6  7  8  9 10 11    3  4  5  6  7  8  9    7  8  9 10 11 12 1312 13 14 15 16 17 18   10 11 12 13 14 15 16   14 15 16 17 18 19 2019 20 21 22 23 24 25   17 18 19 20 21 22 23   21 22 23 24 25 26 2726 27 28 29 30         24 25 26 27 28 29 30   28 29 30                       31        July                  August                September     Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa          1  2  3  4                      1          1  2  3  4  5 5  6  7  8  9 10 11    2  3  4  5  6  7  8    6  7  8  9 10 11 1212 13 14 15 16 17 18    9 10 11 12 13 14 15   13 14 15 16 17 18 1919 20 21 22 23 24 25   16 17 18 19 20 21 22   20 21 22 23 24 25 2626 27 28 29 30 31      23 24 25 26 27 28 29   27 28 29 30                       30 31       October               November               December      Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa             1  2  3    1  2  3  4  5  6  7          1  2  3  4  5 4  5  6  7  8  9 10    8  9 10 11 12 13 14    6  7  8  9 10 11 1211 12 13 14 15 16 17   15 16 17 18 19 20 21   13 14 15 16 17 18 1918 19 20 21 22 23 24   22 23 24 25 26 27 28   20 21 22 23 24 25 2625 26 27 28 29 30 31   29 30                  27 28 29 30 31[root@localhost ~]<span class="hljs-comment"># cal 10 2020</span><span class="hljs-comment">#显示2020年10月</span>    October 2020    Su Mo Tu We Th Fr Sa             1  2  3 4  5  6  7  8  9 1011 12 13 14 15 16 1718 19 20 21 22 23 2425 26 27 28 29 30 31</code></pre><h3 id="1-3-4-man"><a href="#1-3-4-man" class="headerlink" title="1.3.4 man"></a>1.3.4 man</h3><p><strong>查看某个命令介绍及使用方法</strong>，用法：</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># man date</span>DATE(1)                                                             User Commands                                                             DATE(1)NAME       date - <span class="hljs-built_in">print</span> or <span class="hljs-built_in">set</span> the system date and timeSYNOPSIS       date [OPTION]... [+FORMAT]       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]DESCRIPTION       Display the current time <span class="hljs-keyword">in</span> the given FORMAT, or <span class="hljs-built_in">set</span> the system date.       Mandatory arguments to long options are mandatory <span class="hljs-keyword">for</span> short options too.</code></pre><h3 id="1-3-5-sync"><a href="#1-3-5-sync" class="headerlink" title="1.3.5 sync"></a>1.3.5 sync</h3><p>写盘命令，将还在内存中的数据写入磁盘。</p><h1 id="二、-文件及目录管理"><a href="#二、-文件及目录管理" class="headerlink" title="二、 文件及目录管理"></a>二、 文件及目录管理</h1><h2 id="2-1-文件-目录命名规则"><a href="#2-1-文件-目录命名规则" class="headerlink" title="2.1 文件/目录命名规则"></a>2.1 文件/目录命名规则</h2><h3 id="2-1-1-文件-目录命名长度限制"><a href="#2-1-1-文件-目录命名长度限制" class="headerlink" title="2.1.1 文件/目录命名长度限制"></a>2.1.1 文件/目录命名长度限制</h3><p>在Linux底下，使用传统的 <strong>Ext2/Ext3/Ext4</strong> 文件系统以及近来被 CentOS 7 当作预设文件系统的 <strong>xfs</strong> 而言，针对文件名长度限制为：</p><ul><li>单一文件或目录的最大容许名为 <strong>255bytes</strong>，以一个 ASCII 英文占用一个 bytes 来说，则大约可达 <strong>255</strong> 个字元长度。若是以每个中文字占用 2bytes 来说， 最大档名就是大约在 <strong>128</strong> 个中文字之谱！</li></ul><h3 id="2-1-2-文件-目录-命名规则"><a href="#2-1-2-文件-目录-命名规则" class="headerlink" title="2.1.2 文件/目录 命名规则"></a>2.1.2 文件/目录 命名规则</h3><p>避免特殊符号：</p><ul><li>* ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { }</li><li>避免使用 + - 或 . 作为普通文件名的第一个字符(在Linux下以.开头的文件是属于隐藏文件)</li></ul><p>不能使用的符号：</p><ul><li>/</li></ul><p>在 linux 下，是区分大小写的，如 <strong>test.txt</strong> 和 <strong>TEST.txt</strong> 是完全两个文件。</p><h2 id="2-2-目录与路径"><a href="#2-2-目录与路径" class="headerlink" title="2.2 目录与路径"></a>2.2 目录与路径</h2><h4 id="鸟哥的目录结构图"><a href="#鸟哥的目录结构图" class="headerlink" title="鸟哥的目录结构图"></a>鸟哥的目录结构图</h4><p><img src="/img/linux_base/linux_base_5.jpg" alt="鸟哥的目录结构图"></p><h3 id="2-2-1-绝对路径"><a href="#2-2-1-绝对路径" class="headerlink" title="2.2.1 绝对路径"></a>2.2.1 绝对路径</h3><p>路径的写法『一定由根目录 / 写起』，例如： /usr/share/doc 这个目录。</p><h3 id="2-2-2-相对路径"><a href="#2-2-2-相对路径" class="headerlink" title="2.2.2 相对路径"></a>2.2.2 相对路径</h3><p>路径的写法『不是由 / 写起』，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： 『cd ../man』这就是相对路径的写法啦！相对路径意指『相对于目前工作目录的路径！』</p><h2 id="2-3-目录管理"><a href="#2-3-目录管理" class="headerlink" title="2.3 目录管理"></a>2.3 目录管理</h2><ul><li>. :表示当前目录</li><li>..：上级目录</li><li>-：前一个工作区</li><li>~：当前用户的home目录</li><li>ls：列出目录下的文件</li><li>cd：切换目录</li><li>pwd：打印当前目录</li><li>mkdir：创建空目录<br>  -p：依次创建层级目录，如 mkdir -p /1/2/3<br>  -v：显示详情</li><li>rmdir：删除空目录</li></ul><pre><code class="hljs bash"><span class="hljs-comment">#例1：在目录下创建多个目录，如在空目录 /mnt/ 下创建 /mnt/test/x/m,/mnt/test/y</span>[root@localhost ~]<span class="hljs-comment"># mkdir -pv /mnt/test/&#123;x/m,y&#125;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test/x&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test/x/m&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test/y&quot;</span><span class="hljs-comment">#例2：在目录下创建 a_b,a_c,d_b,d_C 文件</span>[root@localhost ~]<span class="hljs-comment"># mkdir -pv /mnt/test2/&#123;a,d&#125;_&#123;b,c&#125;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2/a_b&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2/a_c&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2/d_b&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2/d_c&quot;</span></code></pre><h2 id="2-4-linux-下目录详解"><a href="#2-4-linux-下目录详解" class="headerlink" title="2.4 linux 下目录详解"></a>2.4 linux 下目录详解</h2><p>rootfs：根文件系统</p><pre><code class="hljs bash">/boot：系统启动相关文件，如内核、initrd 以及 grub(bootloader)/dev：设备文件        块设备：随机访问，将数据分为块，称为数据块，如硬盘        字符设备：线性访问，按字符为单位        设备号：主设备号（major）和次设备号（minor）/etc：配置文件/lib64：库文件    静态库    动态库：.so(shared object)    /modules：内核模块文件/opt：可选目录，第三方软件存放处/proc：伪文件系统，内核映射文件/sys：伪文件系统，跟硬件设备相关的属性映射文件/tmp：临时文件/var：与系统运作过程有关，可变化文件，如存放日志文件/bin：可执行文件，用户命令/sbin：管理命令/usr：Unix Software Resource(shared,read-only),操作系统软件资源所放置的目录,所有系统默认的软件都会放置到/usr</code></pre><h2 id="2-5-文件管理"><a href="#2-5-文件管理" class="headerlink" title="2.5 文件管理"></a>2.5 文件管理</h2><h3 id="2-5-1-新建文件"><a href="#2-5-1-新建文件" class="headerlink" title="2.5.1 新建文件"></a>2.5.1 新建文件</h3><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><ul><li>touch：change file timestamps<br>  -a：修改访问时间<br>  -m：修改更改时间<br>  -t：修改到指定时间</li><li>touch:  filename 创建名为 filename 的文件</li></ul><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><ul><li>vi : filename 创建文件或者修改文件</li></ul><h3 id="2-5-2-stat"><a href="#2-5-2-stat" class="headerlink" title="2.5.2 stat"></a>2.5.2 stat</h3><ul><li>stat：显示文件或文件系统状态</li></ul><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># stat test</span>  File: ‘<span class="hljs-built_in">test</span>’  Size: 4             Blocks: 8          IO Block: 4096   regular fileDevice: fd00h/64768d  Inode: 34051578    Links: 1Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)Context: unconfined_u:object_r:admin_home_t:s0Access: 2020-08-18 23:29:02.280000000 +0800Modify: 2020-08-18 23:26:58.260000000 +0800Change: 2020-08-18 23:29:02.280000000 +0800 Birth: -</code></pre><h3 id="2-5-3-cp-复制文件"><a href="#2-5-3-cp-复制文件" class="headerlink" title="2.5.3 cp 复制文件"></a>2.5.3 cp 复制文件</h3><h3 id="2-5-4-mv-移动或者重命名"><a href="#2-5-4-mv-移动或者重命名" class="headerlink" title="2.5.4 mv 移动或者重命名"></a>2.5.4 mv 移动或者重命名</h3><h3 id="2-5-5-显示文件"><a href="#2-5-5-显示文件" class="headerlink" title="2.5.5 显示文件"></a>2.5.5 显示文件</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cat</span>选项与参数：-A  ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；-b  ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E  ：将结尾的断行字元 $ 显示出来；-n  ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；-T  ：将 [tab] 按键以 ^I 显示出来；-v  ：列出一些看不出来的特殊字符</code></pre><h4 id="tac-反向显示"><a href="#tac-反向显示" class="headerlink" title="tac 反向显示"></a>tac 反向显示</h4><p>从文件最后一行显示到第一行</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># tac /etc/issue</span>Kernel \r on an \m\S[root@localhost ~]<span class="hljs-comment"># cat /etc/issue</span>\SKernel \r on an \m</code></pre><h4 id="nl-添加行号打印"><a href="#nl-添加行号打印" class="headerlink" title="nl 添加行号打印"></a>nl 添加行号打印</h4><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># nl</span>选项与参数：-b  ：指定行号指定的方式，主要有两种：      -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；      -b t ：如果有空行，空的那一行不要列出行号(预设值)；-n  ：列出行号表示的方法，主要有三种：      -n ln ：行号在萤幕的最左方显示；      -n rn ：行号在自己栏位的最右方显示，且不加 0 ；      -n rz ：行号在自己栏位的最右方显示，且加 0 ；-w  ：行号栏位的占用的字元数。[root@localhost ~]<span class="hljs-comment"># nl /etc/issue</span>     1  \S     2  Kernel \r</code></pre><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>可以一页一页翻动文档</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># more /etc/sysconfig/network-scripts/ifdown-routes </span><span class="hljs-meta">#! /bin/bash</span><span class="hljs-comment">#</span><span class="hljs-comment"># Drops static routes which go through device $1</span>--More--(68%)   &lt;---命令行模式</code></pre><p>操作：</p><ul><li>空格键 (space)：代表向下翻一页；</li><li>Enter         ：代表向下翻『一行』；</li><li>/字串         ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f            ：立刻显示出档名以及目前显示的行数；</li><li>q             ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><pre><code class="hljs bash">less  /etc/sysconfig/network-scripts/ifdown-routes<span class="hljs-meta">#! /bin/bash</span><span class="hljs-comment">#</span><span class="hljs-comment"># Drops static routes which go through device $1</span>:     &lt;-- 指令输入处</code></pre><p>操作：</p><ul><li>空格键    ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup]  ：向上翻动一页；</li><li>/字串     ：向下搜寻『字串』的功能；</li><li>?字串     ：向上搜寻『字串』的功能；</li><li>n         ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N         ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>g         ：前进到这个资料的第一行去；</li><li>G         ：前进到这个资料的最后一行去 (注意大小写)；</li><li>q         ：离开 less 这个程式；</li><li>方向键     ：逐行显示</li></ul><h4 id="head-取出开头几行"><a href="#head-取出开头几行" class="headerlink" title="head 取出开头几行"></a>head 取出开头几行</h4><pre><code class="hljs bash"><span class="hljs-comment">#取第一行</span>[root@localhost ~]<span class="hljs-comment"># head -n 1 /etc/issue</span>\S</code></pre><h4 id="tail-取出后几行"><a href="#tail-取出后几行" class="headerlink" title="tail 取出后几行"></a>tail 取出后几行</h4><pre><code class="hljs bash"><span class="hljs-comment">#取出后两行，最后一行为空白行</span>[root@localhost ~]<span class="hljs-comment"># tail -n 2 /etc/issue</span>Kernel \r on an \m</code></pre><h2 id="2-6-命令与文件搜索"><a href="#2-6-命令与文件搜索" class="headerlink" title="2.6 命令与文件搜索"></a>2.6 命令与文件搜索</h2><h3 id="2-6-1-命令搜索"><a href="#2-6-1-命令搜索" class="headerlink" title="2.6.1 命令搜索"></a>2.6.1 命令搜索</h3><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># which ls</span><span class="hljs-built_in">alias</span> ls=<span class="hljs-string">&#x27;ls --color=auto&#x27;</span>        /usr/bin/ls</code></pre><h3 id="2-6-2-文件搜索"><a href="#2-6-2-文件搜索" class="headerlink" title="2.6.2 文件搜索"></a>2.6.2 文件搜索</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># find [PATH] [option] [action]</span>选项与参数：1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明   -mtime  n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的文件；   -mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的文件档名；   -mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的文件档名。   -newer file ：file 为一个存在的文件，列出比 file 还要新的文件档名 <span class="hljs-comment">#查找   /root/Console_setup/ 目录下 24小时修改过的文件</span>[root@localhost ~]<span class="hljs-comment"># find /root/Console_setup/ -mtime 0</span>/root/Console_setup/main_menu.sh/root/Console_setup/.git/root/Console_setup/.git/FETCH_HEAD</code></pre><ul><li>+4代表大于等于5天前的档名：ex&gt; find /var -mtime +4</li><li>-4代表小于等于4天内的文件档名：ex&gt; find /var -mtime -4</li><li>4则是代表4-5那一天的文件档名：ex&gt; find /var -mtime 4</li></ul><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># find [PATH] [option] [action]</span>选项与参数：2. 与使用者或群组名称有关的参数：   -uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在            /etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。   -gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在            /etc/group，相关的介绍我们会第四篇说明～   -user name ：name 为使用者帐号名称喔！例如 dmtsai    -group name：name 为群组名称喔，例如 users ；   -nouser    ：寻找文件的拥有者不存在 /etc/passwd 的人！   -nogroup   ：寻找文件的拥有群组不存在于 /etc/group 的文件！                当你自行安装软体时，很可能该软体的属性当中并没有文件拥有者，                这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。<span class="hljs-comment">#找出 /PATH 下属于 username 的文件</span>[root@localhost ~]<span class="hljs-comment"># find /PATH -user USERNAME</span><span class="hljs-comment">#寻找系统中不属于任何人的文件</span>[root@study ~]<span class="hljs-comment"># find / -nouser</span></code></pre><pre><code class="hljs bash">选项与参数：3. 与文件权限及名称有关的参数：   -name filename：搜寻文件名称为 filename 的文件；   -size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的文件。这个 SIZE 的规格有：                   c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB                   还要大的文件，就是『 -size +50k 』   -<span class="hljs-built_in">type</span> TYPE    ：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 (f), 装置文件 (b, c),                   目录 (d), 连结档 (l), socket (s), 及 FIFO (p) 等属性。   -perm mode  ：搜寻文件权限『刚好等于』 mode 的文件，这个 mode 为类似 chmod                 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！   -perm -mode ：搜寻文件权限『必须要全部囊括 mode 的权限』的文件，举例来说，                 我们要搜寻 -rwxr--r-- ，亦即 0744 的文件，使用 -perm -0744，                 当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，                 因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。   -perm /mode ：搜寻文件权限『包含任一 mode 的权限』的文件，举例来说，我们搜寻                 -rwxr-xr-x ，亦即 -perm /755 时，但一个文件属性为 -rw-------                 也会被列出来，因为他有 -rw.... 的属性存在！<span class="hljs-comment"># 找出名为 passwd 的文件</span>[root@localhost ~]<span class="hljs-comment"># find / -name passwd</span>/sys/fs/selinux/class/passwd/sys/fs/selinux/class/passwd/perms/passwd/etc/passwd/etc/pam.d/passwd/usr/bin/passwd<span class="hljs-comment">#找出文件名包含了 passwd 这个关键字的文件</span>[root@localhost ~]<span class="hljs-comment"># find / -name &quot;*passwd*&quot;</span><span class="hljs-comment">#找出系统中，大于 1MB 的文件</span>[root@localhost ~]<span class="hljs-comment"># find / -size +1M</span></code></pre><h2 id="2-7-文件的打包和压缩"><a href="#2-7-文件的打包和压缩" class="headerlink" title="2.7 文件的打包和压缩"></a>2.7 文件的打包和压缩</h2><h3 id="2-7-1-压缩文件"><a href="#2-7-1-压缩文件" class="headerlink" title="2.7.1 压缩文件"></a>2.7.1 压缩文件</h3><pre><code class="hljs bash">*.Z         compress 程式压缩的文件；*.zip       zip 程式压缩的文件；*.gz        gzip 程式压缩的文件；*.bz2       bzip2 程式压缩的文件；*.xz        xz 程式压缩的文件；*.tar       tar 程式打包的资料，并没有压缩过；*.tar.gz    tar 程式打包的文件，其中并且经过 gzip 的压缩*.tar.bz2   tar 程式打包的文件，其中并且经过 bzip2 的压缩*.tar.xz    tar 程式打包的文件，其中并且经过 xz 的压缩</code></pre><h3 id="2-7-2-gzip-zcat-zmore-zless-zgrep"><a href="#2-7-2-gzip-zcat-zmore-zless-zgrep" class="headerlink" title="2.7.2 gzip, zcat/zmore/zless/zgrep"></a>2.7.2 gzip, zcat/zmore/zless/zgrep</h3><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># gzip [-cdtv#] 文件名</span>[root@localhost ~]<span class="hljs-comment"># zcat 文件名.gz</span>选项与参数：-c  ：将压缩的资料输出到屏幕上，可透过资料流重导向来处理；-d  ：解压缩的参数；-t  ：可以用来检验一个压缩文件的一致性～检测压缩文件有无错误；-v  ：可以显示出原文件/压缩文件的压缩比等信息；-<span class="hljs-comment">#  ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是 -6</span><span class="hljs-comment">#压缩文件，压缩后原文件将不存在</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ls</span>test.txt[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># gzip -v test.txt </span>test.txt:         0.0% -- replaced with test.txt.gz[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ls</span>test.txt.gz<span class="hljs-comment">#解压后，压缩文件也不存在</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># gzip -d test.txt.gz </span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ls</span>test.txt<span class="hljs-comment">#使用 zcat zmore zless 读取压缩过的文本文件</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># echo &quot;Hello World&quot; &gt;&gt; test.txt </span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># cat test.txt </span>Hello World[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># gzip -v test.txt </span>test.txt:       -16.7% -- replaced with test.txt.gz[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># zcat test.txt.gz </span>Hello World[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># </span></code></pre><h3 id="2-7-3-bzip2-bzcat-bzmore-bzless-bzgrep"><a href="#2-7-3-bzip2-bzcat-bzmore-bzless-bzgrep" class="headerlink" title="2.7.3 bzip2, bzcat/bzmore/bzless/bzgrep"></a>2.7.3 bzip2, bzcat/bzmore/bzless/bzgrep</h3><p>若说 gzip 是为了取代 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了取代 gzip 并提供更佳的压缩比而来的。 bzip2 真是很不错用的东西～这玩意的压缩比竟然比 gzip 还要好～至于 bzip2 的用法几乎与 gzip 相同！看看底下的用法吧！</p><pre><code class="hljs bash">[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># bzip2 [-cdkzv#] 文件名</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># bzcat 文件名.bz2</span>选项与参数：-c  ：将压缩的过程产生的资料输出到屏幕上！-d  ：解压缩的参数-k  ：保留原始文件，而不会删除原始的文件喔！-z  ：压缩的参数 (预设值，可以不加)-v  ：可以显示出原文件/压缩文件的压缩比等信息；-<span class="hljs-comment">#  ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</span><span class="hljs-comment">#压缩文件，压缩后原文件将不存在</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># bzip2 -v test.txt </span>  test.txt:  0.214:1, 37.333 bits/byte, -366.67% saved, 12 <span class="hljs-keyword">in</span>, 56 out.[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ls</span>test.txt.bz2<span class="hljs-comment">#使用 bzcat bzmore bzless 读取压缩过的文本文件</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># bzcat test.txt.bz2 </span>Hello World<span class="hljs-comment">#解压</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># bzip2 -d test.txt.bz2 </span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ls</span>test.txt</code></pre><h3 id="2-7-4-xz-xzcat-xzmore-xzless-xzgrep"><a href="#2-7-4-xz-xzcat-xzmore-xzless-xzgrep" class="headerlink" title="2.7.4 xz, xzcat/xzmore/xzless/xzgrep"></a>2.7.4 xz, xzcat/xzmore/xzless/xzgrep</h3><p>用法跟上面差不多</p><pre><code class="hljs bash">[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># xz [-dtlkc#] 档名</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># xcat 档名.xz</span>选项与参数：-d  ：解压缩-t  ：测试压缩档的完整性，看有没有错误-l  ：列出压缩档的相关信息-k  ：保留原本的文件不删除～-c  ：同样的，就是将资料由屏幕上输出的意思-<span class="hljs-comment">#  ：同样的，也有较佳的压缩比的意思</span><span class="hljs-comment">#压缩文件，压缩后保留原文件</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment">#  xz -k test.txt </span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ls</span>test.txt  test.txt.xz</code></pre><h2 id="2-8-tar"><a href="#2-8-tar" class="headerlink" title="2.8 tar"></a>2.8 tar</h2><p> tar 可以将多个目录或档案打包成一个大档案，同时还可以透过 gzip/bzip2/xz 的支持，将该档案同时进行压缩</p> <pre><code class="hljs bash">[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># tar [-z|-j|-J] [cv] [-f 待建立的新档名] filename... &lt;==打包与压缩</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># tar [-z|-j|-J] [tv] [-f 既有的 tar档名]             &lt;==察看档名</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># tar [-z|-j|-J] [xv] [-f 既有的 tar档名] [-C 目录]   &lt;==解压缩</span>选项与参数：-c  ：建立打包档案，可搭配 -v 来察看过程中被打包的档名(filename)-t  ：察看打包档案的内容含有哪些档名，重点在察看『档名』就是了；-x  ：解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开      特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。-z  ：透过 gzip  的支援进行压缩/解压缩：此时档名最好为 *.tar.gz-j  ：透过 bzip2 的支援进行压缩/解压缩：此时档名最好为 *.tar.bz2-J  ：透过 xz    的支援进行压缩/解压缩：此时档名最好为 *.tar.xz      特别留意， -z, -j, -J 不可以同时出现在一串指令列中-v  ：在压缩/解压缩的过程中，将正在处理的档名显示出来！-f filename：-f 后面要立刻接要被处理的档名！建议 -f 单独写一个选项啰！(比较不会忘记)-C 目录    ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。其他后续练习会使用到的选项介绍：-p(小写) ：保留备份资料的原本权限与属性，常用于备份(-c)重要的设定档-P(大写) ：保留绝对路径，亦即允许备份资料中含有根目录存在之意；--exclude=FILE：在压缩的过程中，不要将 FILE 打包！</code></pre><p><strong>简单记忆：</strong></p><ul><li>压　缩：tar -jcv -f filename.tar.bz2(压缩后文件名) filename(要被压缩的文件或目录名称)</li><li>查　询：tar -jtv -f filename.tar.bz2</li><li>解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</li></ul><pre><code class="hljs bash"><span class="hljs-comment">#压缩 test.txt 文件和 test 目录</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ll</span>total 4drwxr-xr-x. 2 root root  6 Sep 25 21:25 <span class="hljs-built_in">test</span>-rw-r--r--. 1 root root 12 Sep 25 20:41 test.txt[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># tar -jcv -f test.tar.bz2 test.txt test</span>test.txt<span class="hljs-built_in">test</span>/[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ls</span><span class="hljs-built_in">test</span>  test.tar.bz2  test.txt<span class="hljs-comment">#解压，先删除原文件</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># rm -rf test test.txt</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># tar -jxv -f test.tar.bz2 </span>test.txt<span class="hljs-built_in">test</span>/[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># ls</span><span class="hljs-built_in">test</span>  test.tar.bz2  test.txt<span class="hljs-comment">#查看压缩文件内容</span>[root@blog <span class="hljs-built_in">test</span>]<span class="hljs-comment"># tar -jtv -f test.tar.bz2 </span>-rw-r--r-- root/root        46 2020-09-25 21:29 test.txtdrwxr-xr-x root/root         0 2020-09-25 21:25 <span class="hljs-built_in">test</span>/</code></pre><h1 id="三、-文件系统"><a href="#三、-文件系统" class="headerlink" title="三、 文件系统"></a>三、 文件系统</h1><h2 id="3-1-分区"><a href="#3-1-分区" class="headerlink" title="3.1 分区"></a>3.1 分区</h2><p><a href="https://ecarry.cc/2020/06/09/Linux_part/">关于 Linux 分区的小事</a></p><h2 id="3-2-文件系统选择"><a href="#3-2-文件系统选择" class="headerlink" title="3.2 文件系统选择"></a>3.2 文件系统选择</h2><p><a href="https://ecarry.cc/2020/02/11/linux_fs/">Linux 文件系统的选择</a></p><h2 id="3-3-超级块和-i-node"><a href="#3-3-超级块和-i-node" class="headerlink" title="3.3 超级块和 i-node"></a>3.3 超级块和 i-node</h2><p><a href="https://ecarry.cc/2020/09/02/linux_super_inode_block/">Linux 超级块和 i-node</a></p><h1 id="四、-VIM"><a href="#四、-VIM" class="headerlink" title="四、 VIM"></a>四、 VIM</h1><p><strong>VIM 特点</strong></p><ul><li>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在；</li><li>很多个别软件的编辑介面都会主动呼叫 vi (例如未来会谈到的 crontab, visudo, edquota 等指令)；</li><li>vim 具有程式编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程式设计；</li><li>编辑速度快</li></ul><h2 id="4-1-VIM-编辑器"><a href="#4-1-VIM-编辑器" class="headerlink" title="4.1 VIM 编辑器"></a>4.1 VIM 编辑器</h2><h2 id="4-2-VIM-模式"><a href="#4-2-VIM-模式" class="headerlink" title="4.2 VIM 模式"></a>4.2 VIM 模式</h2><h3 id="4-2-1-命令模式"><a href="#4-2-1-命令模式" class="headerlink" title="4.2.1 命令模式"></a>4.2.1 命令模式</h3><h3 id="4-2-2-编辑模式"><a href="#4-2-2-编辑模式" class="headerlink" title="4.2.2 编辑模式"></a>4.2.2 编辑模式</h3><h3 id="4-2-3-可视化模式"><a href="#4-2-3-可视化模式" class="headerlink" title="4.2.3 可视化模式"></a>4.2.3 可视化模式</h3><h3 id="4-2-4-末行模式"><a href="#4-2-4-末行模式" class="headerlink" title="4.2.4 末行模式"></a>4.2.4 末行模式</h3><h2 id="3-3-VIM-相关操作"><a href="#3-3-VIM-相关操作" class="headerlink" title="3.3 VIM 相关操作"></a>3.3 VIM 相关操作</h2><h2 id="3-4-VIM-项目实战"><a href="#3-4-VIM-项目实战" class="headerlink" title="3.4 VIM 项目实战"></a>3.4 VIM 项目实战</h2><h1 id="五、-用户和组"><a href="#五、-用户和组" class="headerlink" title="五、 用户和组"></a>五、 用户和组</h1><h2 id="4-1-用户和组的概念"><a href="#4-1-用户和组的概念" class="headerlink" title="4.1 用户和组的概念"></a>4.1 用户和组的概念</h2><h2 id="4-2-用户管理操作"><a href="#4-2-用户管理操作" class="headerlink" title="4.2 用户管理操作"></a>4.2 用户管理操作</h2><h2 id="4-3-用户组管理操作"><a href="#4-3-用户组管理操作" class="headerlink" title="4.3 用户组管理操作"></a>4.3 用户组管理操作</h2><h2 id="4-4-企业级用户管理实战"><a href="#4-4-企业级用户管理实战" class="headerlink" title="4.4 企业级用户管理实战"></a>4.4 企业级用户管理实战</h2><h1 id="五、-管道命令和-ssh"><a href="#五、-管道命令和-ssh" class="headerlink" title="五、 管道命令和 ssh"></a>五、 管道命令和 ssh</h1><h2 id="5-1-管道命令"><a href="#5-1-管道命令" class="headerlink" title="5.1 管道命令 |"></a>5.1 管道命令 |</h2><h2 id="5-2-grep"><a href="#5-2-grep" class="headerlink" title="5.2 grep"></a>5.2 grep</h2><h2 id="5-3-网络配置"><a href="#5-3-网络配置" class="headerlink" title="5.3 网络配置"></a>5.3 网络配置</h2><h3 id="5-3-1-网络相关命令"><a href="#5-3-1-网络相关命令" class="headerlink" title="5.3.1 网络相关命令"></a>5.3.1 网络相关命令</h3><h2 id="5-4-SSH"><a href="#5-4-SSH" class="headerlink" title="5.4 SSH"></a>5.4 SSH</h2><h3 id="5-4-1-ssh-协议"><a href="#5-4-1-ssh-协议" class="headerlink" title="5.4.1 ssh 协议"></a>5.4.1 ssh 协议</h3><h3 id="5-4-2-sshd-服务"><a href="#5-4-2-sshd-服务" class="headerlink" title="5.4.2 sshd 服务"></a>5.4.2 sshd 服务</h3><h2 id="5-5-远程管理和文件传输"><a href="#5-5-远程管理和文件传输" class="headerlink" title="5.5 远程管理和文件传输"></a>5.5 远程管理和文件传输</h2><h1 id="六、-权限管理"><a href="#六、-权限管理" class="headerlink" title="六、 权限管理"></a>六、 权限管理</h1><h2 id="6-1-文件权限描述"><a href="#6-1-文件权限描述" class="headerlink" title="6.1 文件权限描述"></a>6.1 文件权限描述</h2><h2 id="6-2-linux-权限与用户身份类别"><a href="#6-2-linux-权限与用户身份类别" class="headerlink" title="6.2 linux 权限与用户身份类别"></a>6.2 linux 权限与用户身份类别</h2><h2 id="6-4-文件权限设置"><a href="#6-4-文件权限设置" class="headerlink" title="6.4 文件权限设置"></a>6.4 文件权限设置</h2><h2 id="6-5-权限扩展"><a href="#6-5-权限扩展" class="headerlink" title="6.5 权限扩展"></a>6.5 权限扩展</h2><p>设置位 S 与 沾附位 T</p><h2 id="6-6-ACL-权限"><a href="#6-6-ACL-权限" class="headerlink" title="6.6 ACL 权限"></a>6.6 ACL 权限</h2><h2 id="6-7-UMASK"><a href="#6-7-UMASK" class="headerlink" title="6.7 UMASK"></a>6.7 UMASK</h2><h1 id="七、-服务管理"><a href="#七、-服务管理" class="headerlink" title="七、 服务管理"></a>七、 服务管理</h1><h2 id="7-1-systemctl"><a href="#7-1-systemctl" class="headerlink" title="7.1 systemctl"></a>7.1 systemctl</h2><h2 id="7-2-ntpd-时间同步"><a href="#7-2-ntpd-时间同步" class="headerlink" title="7.2 ntpd 时间同步"></a>7.2 ntpd 时间同步</h2><h2 id="7-3-firewalld-防火墙"><a href="#7-3-firewalld-防火墙" class="headerlink" title="7.3 firewalld 防火墙"></a>7.3 firewalld 防火墙</h2><h2 id="7-4-rpm-包管理"><a href="#7-4-rpm-包管理" class="headerlink" title="7.4 rpm 包管理"></a>7.4 rpm 包管理</h2><h2 id="7-5-crond-计划任务详解"><a href="#7-5-crond-计划任务详解" class="headerlink" title="7.5 crond 计划任务详解"></a>7.5 crond 计划任务详解</h2><h1 id="八、-环境配置"><a href="#八、-环境配置" class="headerlink" title="八、 环境配置"></a>八、 环境配置</h1><h2 id="8-1-LAMP-环境概述"><a href="#8-1-LAMP-环境概述" class="headerlink" title="8.1 LAMP 环境概述"></a>8.1 LAMP 环境概述</h2><h2 id="8-2-LAMP-环境编译安装"><a href="#8-2-LAMP-环境编译安装" class="headerlink" title="8.2 LAMP 环境编译安装"></a>8.2 LAMP 环境编译安装</h2><h2 id="8-3-YUM-源配置"><a href="#8-3-YUM-源配置" class="headerlink" title="8.3 YUM 源配置"></a>8.3 YUM 源配置</h2><h2 id="8-4-YUM-配置-LAMP-环境"><a href="#8-4-YUM-配置-LAMP-环境" class="headerlink" title="8.4 YUM 配置 LAMP 环境"></a>8.4 YUM 配置 LAMP 环境</h2>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux ssh</title>
    <link href="/2020/09/21/linux_ssh/"/>
    <url>/2020/09/21/linux_ssh/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-SSH"><a href="#一、-SSH" class="headerlink" title="一、 SSH"></a>一、 SSH</h1><h2 id="1-1-ssh"><a href="#1-1-ssh" class="headerlink" title="1.1 ssh"></a>1.1 ssh</h2><p>ssh：Secure Shell，应用层协议，默认端口 22/tcp</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>通信过程及认证过程是加密的，主机认证</li><li>用户认证过程加密</li><li>数据传输过程加密</li></ul><h3 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h3><ul><li>基于口令认证</li><li>基于密钥认证</li></ul><h2 id="1-2-openSSH"><a href="#1-2-openSSH" class="headerlink" title="1.2 openSSH"></a>1.2 openSSH</h2><h3 id="1-2-1-用于-linux，C-S-架构："><a href="#1-2-1-用于-linux，C-S-架构：" class="headerlink" title="1.2.1 用于 linux，C/S 架构："></a>1.2.1 用于 linux，C/S 架构：</h3><ul><li>服务端：sshd，配置文件 /etc/ssh/sshd_config</li><li>客户端：ssh，配置文件 /etc/ssh/ssh_config</li><li>ssh-keygen：秘钥生成器</li><li>ssh-copy-id：将公钥传输至远程服务器</li><li>scp：跨主机安全复制工具</li></ul><h4 id="ssh-使用"><a href="#ssh-使用" class="headerlink" title="ssh 使用"></a>ssh 使用</h4><ul><li>ssh USERNAME@HOST：用 USERNAME 登录 HOST</li><li>ssh USERNAME@HOST ‘COMMAND’：不登录执行远程主机命令，并打印在屏幕</li></ul><h4 id="scp-使用"><a href="#scp-使用" class="headerlink" title="scp 使用"></a>scp 使用</h4><ul><li>scp SRC DEST<ul><li>-r</li><li>-a</li></ul></li><li>scp /path/to/copy USERNAME@HOST:/path/to/save：将本地文件复制到远程主机上</li><li>scp USERNAME@HOST:/path/to/copy /path/to/save：将远程主机上的文件复制到本机上</li></ul><h4 id="ssh-keygen-使用"><a href="#ssh-keygen-使用" class="headerlink" title="ssh-keygen 使用"></a>ssh-keygen 使用</h4><ul><li>ssh-keygen -t rsa<ul><li>~/.ssh/id_rsa：密钥</li><li>~/.ssh/id_rsa.pub：公钥，可复制到远程主机 <code>~/.ssh/authorized_keys</code> 下</li><li>-f /path/to/KEY_FILE：保存密钥到指定目录</li><li>-p ‘ ‘：指定加密密钥的密码，或为空</li></ul></li></ul><h4 id="ssh-copy-id"><a href="#ssh-copy-id" class="headerlink" title="ssh-copy-id"></a>ssh-copy-id</h4><ul><li>ssh-copy-id<ul><li>-i ~/.ssh/id_rsa.pub USERNAME@HOST：将公钥拷贝到远程主机</li></ul></li></ul><h1 id="二、-配置文件"><a href="#二、-配置文件" class="headerlink" title="二、 配置文件"></a>二、 配置文件</h1>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 超级块和 i-node</title>
    <link href="/2020/09/02/linux_super_inode_block/"/>
    <url>/2020/09/02/linux_super_inode_block/</url>
    
    <content type="html"><![CDATA[<h1 id="一、从物理磁盘到文件系统"><a href="#一、从物理磁盘到文件系统" class="headerlink" title="一、从物理磁盘到文件系统"></a>一、从物理磁盘到文件系统</h1><p>文件系统用来存储文件内容，文件属性和目录。且在 Linux 里万物为文件</p><p>Linux 文件系统中，是以块为单位存储信息，把硬盘分为三个部分：<strong>超级块（Super block）</strong>，<strong>i-节点表（inode table）</strong>，<strong>数据块（data block）</strong>。</p><p>要实现文件系统组件，首先需要了解 SimpleFS 磁盘布局。如前所述，此项目假定每个磁盘块的大小为4KB。磁盘的第一个块是描述文件系统其余部分布局的超级块。超级块之后的一定数量的块包含 inode 数据结构(即 i-node 表)。通常，磁盘块总数的10% 用作 inode 块(即保留用于存储 inode 表的块)。文件系统中剩余的块用作普通数据块，有时用作间接指针块，如下面的例子所示:</p><p><img src="/img/linux_super_inode_block/linux_inode_1.jpg"></p><p><strong>Magic</strong>: The first field is always the MAGIC_NUMBER or 0xf0f03410. The format routine places this number into the very first bytes of the superblock as a sort of filesystem “signature”. When the filesystem is mounted, the OS looks for this magic number. If it is correct, then the disk is assumed to contain a valid filesystem. If some other number is present, then the mount fails, perhaps because the disk is not formatted or contains some other kind of data.（第一个字段总是 MAGIC 数字或0xf0f03410。Format 例程将这个数字作为一种文件系统“签名”放在超级块的最初字节中。当文件系统被安装时，操作系统会寻找这个神奇的数字。如果是正确的，则假定磁盘包含有效的文件系统。如果存在其他数字，则挂载失败，可能是因为磁盘没有格式化或包含其他类型的数据。）</p><blockquote><p>参考资料：<a href="https://www3.nd.edu/~pbui/teaching/cse.30341.fa18/project06.html">https://www3.nd.edu/~pbui/teaching/cse.30341.fa18/project06.html</a></p></blockquote><h2 id="1-1-超级块（Super-block）"><a href="#1-1-超级块（Super-block）" class="headerlink" title="1.1 超级块（Super block）"></a>1.1 超级块（Super block）</h2><p>文件系统中第一个块被称为<strong>超级块</strong>。超级块记录了该 <strong>filesystem</strong> 的整体信息，其中包含：</p><ul><li>block 与 inode 的总量</li><li>未使用与已使用的 inode/block 数量</li><li>一个 block 与 一个 inode 的大小（block 在ext2 中为1，2，4k；inode 为 128bytes或256bytes）</li><li>filesystem 的挂载时间，最近一次写入资料的时间，最近一次检验磁盘（fsck）的时间等档案系统的相关信息</li><li>一个 valid bit 数值，若该文件系统已被挂载，则 valid bit 为0，若未被挂载，则 valid bit 为1</li></ul><p>一般来说， superblock 的大小为 <strong>1024bytes</strong>。</p><h2 id="1-2-i-节点表（inode-table）"><a href="#1-2-i-节点表（inode-table）" class="headerlink" title="1.2 i-节点表（inode table）"></a>1.2 i-节点表（inode table）</h2><p>超级块下一部分就是 <strong>i-节点表</strong> 了，该数据结构管理所有文件的属性。每个Linux文件或目录 (从技术角度讲，它们之间没有本质的区别，都为文件) 都有一个inode，而这个inode包含了所有文件的元数据 (也就是说，读取文件所需的管理数据都存储在inode中)。例如，inode包含存储文件的所有块的列表，该文件所有者信息、权限以及为该文件设置的所有其他属性。</p><p>所有i-节点都有相同的大小，并且i-节点表是这些结构的一个列表，文件系统中每个文件在该表中都有一个i-节点。</p><h3 id="1-2-1-inode-number"><a href="#1-2-1-inode-number" class="headerlink" title="1.2.1 inode number"></a>1.2.1 inode number</h3><p><strong>inode</strong> 是 inode table 中的一个条目，包含有关目录和常规文件的元数据。inode是传统Unix风格文件系统 (比如ext3/ext4) 上的数据结构。Linux扩展文件系统 (如ext2/ext3) 维护了一个inode的数组：inode table。inode table 包含该文件系统中所有文件的列表。inode table 中的各个inode项具有唯一的编号 (该文件系统唯一)，即inode number。深入inode数据结构，我们发现它存储了如下信息：</p><ul><li>文件类型： 普通文件，目录，管道等等</li><li>权限：可读，可写，可执行(read/write/excute)</li><li>链接数：链接到该inode的硬链接数</li><li>User ID：文件所有者</li><li>Group ID：所有者组ID</li><li>文件大小</li><li>时间信息：创建时间或状态改变时间（ctime）、最近修修改时间（mtime）、最近读取时间（atime）</li><li>属性：比如，不可改变位</li><li>访问控制列表</li><li>文件数据存储的实际位置</li><li>其他元数据</li></ul><p><font color=red>注意：inode中不存储文件名数据，文件名存储在目录</font></p><p><strong>特性：</strong></p><ul><li>每个 inode 大小均固定为 128bytes（ext4和xfs可设定到256bytes）</li><li>每个档案仅会占用一个 inode</li><li>所以，文件系统能够创建的文件数与 inode 的数量有关</li><li>系统读取档案时需要先找到 inode，并分析 inode 所记录的权限与使用者是否相符，符合才能够开始实际读取 data blcok 里文件的内容</li></ul><h2 id="1-3-数据块（data-block）"><a href="#1-3-数据块（data-block）" class="headerlink" title="1.3 数据块（data block）"></a>1.3 数据块（data block）</h2><p>文件系统的第三个部分就是<strong>数据块区</strong>。文件的本身内容就保存在该区域。磁盘上所有的块大小都一样，如在<strong>Ext2档案系统中所支持的block大小有1K, 2K及4K三种</strong>。格式化时block的大小就固定了，且每个block都有编号，以方便inode的记录。<font color=red>如果文件包含超过一个数据块的内容，则文件内容会存放在多个磁盘块中</font>。</p><h1 id="二、文件及目录的创建过程"><a href="#二、文件及目录的创建过程" class="headerlink" title="二、文件及目录的创建过程"></a>二、文件及目录的创建过程</h1><h2 id="2-1-文件创建过程"><a href="#2-1-文件创建过程" class="headerlink" title="2.1 文件创建过程"></a>2.1 文件创建过程</h2><p>使用 <code>touch filename</code> 创建文件：</p><p>文件的属性和文件的内容：<font color=red>内核将文件的内容放入data block，将文件的属性存放在 i-节点，文件名存放在目录</font>。</p><p>下图显示了创建一个文件的例子，该文件占用了3个数据块：</p><p><img src="/img/linux_super_inode_block/linux_inode_2.jpg"></p><p>步骤：</p><ol><li><p>文件属性存储：内核找到一块空的 i-节点，该节点 i-number 为47。内核把该文件的信息记录其中，这些信息详见 1.2.1 inode number</p></li><li><p>文件内容的存储：由于该文件需要3个数据块，内核需要在自由块列表中找到3个自由块。</p></li><li><p>记录分配情况，数据保存到了3个数据块中，所以需要记录下来。分配情况记录在 i-节点中的磁盘序号列表里。这3个编号分别放在最开始的3个位置</p></li><li><p>添加文件名到目录，新的文件名为 filename，内核将文件的入口（47，filename）添加到目录文件里。文件名和 i-节点号之间的对应关系将文件名和文件的内容属性🔗起来，找到文件名就找到了文件的 i-节点号，通过 i-节点号就能找到文件的属性及内容</p></li></ol><h2 id="2-2-目录创建过程"><a href="#2-2-目录创建过程" class="headerlink" title="2.2 目录创建过程"></a>2.2 目录创建过程</h2><p>目录也是文件，内容比较特殊，它包含了文件名字列表，而列表一般包含两个部分：<strong>i-节点</strong> 和 <strong>文件名</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 CentOS 7 下 搭建 Zabbix 5.0 LTS 日志</title>
    <link href="/2020/08/27/zabbix_install/"/>
    <url>/2020/08/27/zabbix_install/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-YUM-安装-服务端"><a href="#一、-YUM-安装-服务端" class="headerlink" title="一、 YUM 安装-服务端"></a>一、 YUM 安装-服务端</h1><h2 id="1-1-关闭防火墙和-selinux-，重启"><a href="#1-1-关闭防火墙和-selinux-，重启" class="headerlink" title="1.1 关闭防火墙和 selinux ，重启"></a>1.1 关闭防火墙和 selinux ，重启</h2><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27; /etc/selinux/config</span>[root@localhost ~]<span class="hljs-comment"># systemctl disable firewalld</span>[root@localhost ~]<span class="hljs-comment"># init 6</span></code></pre><h2 id="1-2-安装-zabbix-rpm-源，替换成-阿里云的-zabbix-源"><a href="#1-2-安装-zabbix-rpm-源，替换成-阿里云的-zabbix-源" class="headerlink" title="1.2 安装 zabbix rpm 源，替换成 阿里云的 zabbix 源"></a>1.2 安装 zabbix rpm 源，替换成 阿里云的 zabbix 源</h2><p><a href="https://mirrors.aliyun.com/">阿里云源</a></p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># rpm -Uvh https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm</span>[root@localhost ~]<span class="hljs-comment"># sed -i &#x27;s@http://repo.zabbix.com@https://mirrors.aliyun.com/zabbix@&#x27; /etc/yum.repos.d/zabbix.repo</span>[root@localhost ~]<span class="hljs-comment"># yum clean all</span></code></pre><h2 id="1-3-安装-zabbix-server-和-agent"><a href="#1-3-安装-zabbix-server-和-agent" class="headerlink" title="1.3 安装 zabbix server 和 agent"></a>1.3 安装 zabbix server 和 agent</h2><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># yum install zabbix-server-mysql zabbix-agent -y</span></code></pre><h2 id="1-4-安装-Software-Collections，便于后续安装高版本的-php，默认-yum-安装的-php-版本为-5-4-过低"><a href="#1-4-安装-Software-Collections，便于后续安装高版本的-php，默认-yum-安装的-php-版本为-5-4-过低" class="headerlink" title="1.4 安装 Software Collections，便于后续安装高版本的 php，默认 yum 安装的 php 版本为 5.4 过低"></a>1.4 安装 Software Collections，便于后续安装高版本的 php，默认 yum 安装的 php 版本为 5.4 过低</h2><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># yum install centos-release-scl -y</span></code></pre><p>启用 zabbix 前端源，修改 vi /etc/yum.repos.d/zabbix.repo，将 <strong>[zabbix-frontend]</strong> 下的 <strong>enabled=1</strong></p><h2 id="1-5-安装-zabbix-前端和相关环境"><a href="#1-5-安装-zabbix-前端和相关环境" class="headerlink" title="1.5 安装 zabbix 前端和相关环境"></a>1.5 安装 zabbix 前端和相关环境</h2><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># yum install zabbix-web-mysql-scl zabbix-apache-conf-scl -y</span></code></pre><h2 id="1-6-yum-安装-centos7-默认的-mariadb-数据库并配置数据库"><a href="#1-6-yum-安装-centos7-默认的-mariadb-数据库并配置数据库" class="headerlink" title="1.6 yum 安装 centos7 默认的 mariadb 数据库并配置数据库"></a>1.6 yum 安装 centos7 默认的 mariadb 数据库并配置数据库</h2><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># yum install mariadb-server -y</span><span class="hljs-comment">#启动数据库，并配置开机自动启动</span>[root@localhost ~]<span class="hljs-comment"># systemctl enable --now mariadb</span><span class="hljs-comment">#使用以下命令初始化 mariadb 并配置 root 密码</span>[root@localhost ~]<span class="hljs-comment"># mysql_secure_installation </span>NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!In order to <span class="hljs-built_in">log</span> into MariaDB to secure it, we<span class="hljs-string">&#x27;ll need the current</span><span class="hljs-string">password for the root user.  If you&#x27;</span>ve just installed MariaDB, andyou haven<span class="hljs-string">&#x27;t set the root password yet, the password will be blank,</span><span class="hljs-string">so you should just press enter here.</span><span class="hljs-string"></span><span class="hljs-string">Enter current password for root (enter for none): root123.</span><span class="hljs-string"></span><span class="hljs-string">#使用 root 用户进入 mysql，并建立 zabbix 数据库，注意数据库编码</span><span class="hljs-string">[root@localhost ~]# mysql -u root -p </span><span class="hljs-string">Enter password: </span><span class="hljs-string">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><span class="hljs-string">Your MariaDB connection id is 11</span><span class="hljs-string">Server version: 5.5.65-MariaDB MariaDB Server</span><span class="hljs-string"></span><span class="hljs-string">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><span class="hljs-string"></span><span class="hljs-string">Type &#x27;</span><span class="hljs-built_in">help</span>;<span class="hljs-string">&#x27; or &#x27;</span>\h<span class="hljs-string">&#x27; for help. Type &#x27;</span>\c<span class="hljs-string">&#x27; to clear the current input statement.</span><span class="hljs-string"></span><span class="hljs-string">MariaDB [(none)]&gt; </span><span class="hljs-string">create database zabbix character set utf8 collate utf8_bin;</span><span class="hljs-string">create user zabbix@localhost identified by &#x27;</span>password<span class="hljs-string">&#x27;;</span><span class="hljs-string">grant all privileges on zabbix.* to zabbix@localhost;</span><span class="hljs-string">quit;</span><span class="hljs-string"></span><span class="hljs-string">#使用以下命令导入 zabbix 数据库，zabbix 数据库用户为 zabbix，密码为 password</span><span class="hljs-string">[root@localhost ~]# zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</span><span class="hljs-string"></span><span class="hljs-string">#修改 zabbix server 配置文件vi /etc/zabbix/zabbix_server.conf 里的数据库密码</span><span class="hljs-string">DBPassword=password</span><span class="hljs-string"></span><span class="hljs-string">#修改 zabbix 的 php 配置文件vi /etc/opt/rh/rh-php72/php-fpm.d/zabbix.conf 里的时区，改成 Asia/Shanghai</span><span class="hljs-string">php_value[date.timezone] = Asia/Shanghai</span><span class="hljs-string"></span><span class="hljs-string">#启动相关服务，并配置开机自动启动</span><span class="hljs-string">[root@localhost ~]# systemctl restart zabbix-server zabbix-agent httpd rh-php72-php-fpm</span><span class="hljs-string">[root@localhost ~]# systemctl enable zabbix-server zabbix-agent httpd rh-php72-php-fpm</span></code></pre><h2 id="1-7-使用浏览器访问-http-ip-zabbix-即可访问-zabbix-的-web-页面"><a href="#1-7-使用浏览器访问-http-ip-zabbix-即可访问-zabbix-的-web-页面" class="headerlink" title="1.7 使用浏览器访问 http://ip/zabbix 即可访问 zabbix 的 web 页面"></a>1.7 使用浏览器访问 <a href="http://ip/zabbix">http://ip/zabbix</a> 即可访问 zabbix 的 web 页面</h2><h3 id="默认登录用户名-Admin-密码-zabbix"><a href="#默认登录用户名-Admin-密码-zabbix" class="headerlink" title="默认登录用户名 Admin 密码 zabbix"></a>默认登录用户名 <code>Admin</code> 密码 <code>zabbix</code></h3><h1 id="二、-安装客户端"><a href="#二、-安装客户端" class="headerlink" title="二、 安装客户端"></a>二、 安装客户端</h1><h2 id="2-1-关闭防火墙和-selinux-，重启"><a href="#2-1-关闭防火墙和-selinux-，重启" class="headerlink" title="2.1 关闭防火墙和 selinux ，重启"></a>2.1 关闭防火墙和 selinux ，重启</h2><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27; /etc/selinux/config</span>[root@localhost ~]<span class="hljs-comment"># systemctl disable firewalld</span>[root@localhost ~]<span class="hljs-comment"># init 6</span></code></pre><h2 id="2-2-安装-zabbix-rpm-源，替换成-阿里云的-zabbix-源"><a href="#2-2-安装-zabbix-rpm-源，替换成-阿里云的-zabbix-源" class="headerlink" title="2.2 安装 zabbix rpm 源，替换成 阿里云的 zabbix 源"></a>2.2 安装 zabbix rpm 源，替换成 阿里云的 zabbix 源</h2><p><a href="https://mirrors.aliyun.com/">阿里云源</a></p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># rpm -Uvh https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm</span>[root@localhost ~]<span class="hljs-comment"># sed -i &#x27;s@http://repo.zabbix.com@https://mirrors.aliyun.com/zabbix@&#x27; /etc/yum.repos.d/zabbix.repo</span>[root@localhost ~]<span class="hljs-comment"># yum clean all</span></code></pre><h2 id="2-3-安装-zabbix-agent"><a href="#2-3-安装-zabbix-agent" class="headerlink" title="2.3 安装 zabbix agent"></a>2.3 安装 zabbix agent</h2><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># yum install zabbix-agent -y</span></code></pre><h2 id="2-4-修改-zabbix-agent-配置文件"><a href="#2-4-修改-zabbix-agent-配置文件" class="headerlink" title="2.4 修改 zabbix-agent 配置文件"></a>2.4 修改 zabbix-agent 配置文件</h2><p>配置文件位置：<code>/etc/zabbix/zabbix_agentd.conf</code></p><pre><code class="hljs ini"><span class="hljs-section">[root@localhost ~]</span><span class="hljs-comment"># vi /etc/zabbix/zabbix_agentd.conf</span><span class="hljs-attr">PidFile</span>=/run/zabbix/zabbix_agentd.pid<span class="hljs-attr">LogFile</span>=/var/log/zabbix/zabbix_agentd.log<span class="hljs-attr">LogFileSize</span>=<span class="hljs-number">0</span><span class="hljs-attr">Server</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span>            <span class="hljs-comment">#服务端地址</span><span class="hljs-attr">ListenPort</span>=<span class="hljs-number">10050</span>              <span class="hljs-comment">#监听端口</span><span class="hljs-attr">ListenIP</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span>          <span class="hljs-comment">#客户端本机IP</span><span class="hljs-attr">ServerActive</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span>      <span class="hljs-comment">#服务端地址</span><span class="hljs-attr">Hostname</span>=Ubuntu               <span class="hljs-comment">#主机名，需要跟后面网页配置的主机名相同</span><span class="hljs-attr">Include</span>=/etc/zabbix/zabbix_agentd.d/*.conf</code></pre><h2 id="2-5-启动或重启-zabbix-agent-服务"><a href="#2-5-启动或重启-zabbix-agent-服务" class="headerlink" title="2.5 启动或重启 zabbix-agent 服务"></a>2.5 启动或重启 zabbix-agent 服务</h2><p><code>systemctl restart zabbix-agent</code></p><h3 id="查看-zabbix-agent-状态"><a href="#查看-zabbix-agent-状态" class="headerlink" title="查看 zabbix-agent 状态"></a>查看 zabbix-agent 状态</h3><p><code>systemctl status zabbix-agent</code></p><h3 id="设置开机自动启动"><a href="#设置开机自动启动" class="headerlink" title="设置开机自动启动"></a>设置开机自动启动</h3><p><code>systemctl enable zabbix-agent</code></p>]]></content>
    
    
    <categories>
      
      <category>Zabbix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zabbix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDS VSP 双盘故障（存在 pin data）</title>
    <link href="/2020/08/24/HDS_VSP_PIN_DATA/"/>
    <url>/2020/08/24/HDS_VSP_PIN_DATA/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>接客户邮件，HDS VSP 有故障，到现场查看，有块硬盘故障，操作界面发现 Pinned Track 闪烁，点开如下图：</p><p><img src="/img/HDS_VSP/HDS_VSP_PIN_DATA_pin.jpg"></p><p>未理睬，接下来正常换故障硬盘，故障硬盘为 HDD24-08：</p><p><img src="/img/HDS_VSP/HDS_VSP_PIN_DATA_2.jpg"></p><p>换完硬盘后一切顺利，故障盘也有回拷进度条：</p><p><img src="/img/HDS_VSP/HDS_VSP_PIN_DATA_3.jpg"></p><h1 id="告警信息"><a href="#告警信息" class="headerlink" title="告警信息"></a>告警信息</h1><p>第二天，客户电话联系，HDS VSP 有故障，到现场查看为昨天更换的硬盘位，硬盘状态为 <strong>Blocked</strong>：</p><p><img src="/img/HDS_VSP/HDS_VSP_PIN_DATA_4.jpg"></p><p>首先以为是备件硬盘质量问题，相继更换不同批次备件5次，故障依旧，无法从热备盘 <strong>HDD054-0F</strong> 回拷数据，查看 SIM 信息，发现都是回拷不到一小时中断</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>经原厂工程师分析故障原因：<br>7月23日存储硬盘 <strong>HDD024-08</strong> 完全故障，再通过RAID机制向热备盘 <strong>HDD54-0F</strong> 恢复数据的过程中发现同一RAID组中的 <strong>HDD020-08</strong> 硬盘故障，导致有部分数据无法恢复到 <strong>HDD54-0F</strong>，在00:27这个数据lun产生了pin data。此RAID组发生了两块磁盘同时故障的问题，导致RAID保护机制失效。</p><p><img src="/img/HDS_VSP/HDS_VSP_PIN_DATA_5.jpg"></p><p>当时 <strong>HDD20-08</strong> SIM 信息：<br><img src="/img/HDS_VSP/HDS_VSP_PIN_DATA_6.jpg"></p><p><strong>Pin data</strong> 信息：</p><p><img src="/img/HDS_VSP/HDS_VSP_PIN_DATA_7.jpg"></p><h1 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>备份 lun 00:27 所涉及的数据进行备份</li><li>单独对 lun 00:27 进行备份</li></ol><p>?<br>删除操作</p><h2 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h2><ol><li>开启存储 MODE MODE 模式，开启方式 ?，密码为 mode</li><li>进入 <strong>install</strong> —&gt; <strong>change config？</strong> ，将 <strong>(SOMs)System option modes</strong> 改为 Mode 22</li><li>在存储中将 <strong>HDD20-08</strong> 硬盘上的数据拷到 Spare disk<ul><li>步骤：Mantenance –&gt; 选中硬盘 HDD20-08 –&gt; Other –&gt; Spare Disk</li><li>此时，提示 Pinned Track exists. Do you want to stop this process?</li><li>点击 No，输入密码 exist-pintrack</li></ul></li><li>等待 Copy end，更换 HDD20-08 硬盘并回拷数据</li><li>检查是否产生新的 pin data，如有则需要再次检查系统日志</li><li>没有产生新的 pin data，则关闭 Mode 22 后格式化 lun 00:27。格式化完成后原本的 pin data 消失</li></ol><h1 id="根因"><a href="#根因" class="headerlink" title="根因"></a>根因</h1>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP 地址发生冲突导致网络故障，排查解决</title>
    <link href="/2020/08/18/ip_trouble/"/>
    <url>/2020/08/18/ip_trouble/</url>
    
    <content type="html"><![CDATA[<h1 id="1、故障摘要"><a href="#1、故障摘要" class="headerlink" title="1、故障摘要"></a><strong>1、故障摘要</strong></h1><p>一般 IP 冲突（大多为自动分配地址的 PC 入网，与现有固定 IP 发生冲突）造成设备无法上线或者不断上线和下线，网络推流死机等现象</p><h1 id="2、故障具体情况"><a href="#2、故障具体情况" class="headerlink" title="2、故障具体情况"></a><strong>2、故障具体情况</strong></h1><p>大多为自动分配地址的 PC 入网，与现有固定 IP 发生冲突</p><h1 id="3、故障分析及处理"><a href="#3、故障分析及处理" class="headerlink" title="3、故障分析及处理"></a><strong>3、故障分析及处理</strong></h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><p>将电脑接入局域网，在终端输入：<code>arp -a</code> ，查看局域网内所有的 IP，当看到有两个 IP 一样的时候，就可以确定冲突的 IP</p><h2 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h2><p>当知道冲突 IP 后，用<code>nbtstat -a ip</code>(ip 为冲突 ip)命令，查看冲突 IP 的设备信息，找到该设备</p><h2 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h2><p>修改该设备 IP 信息</p><h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a><strong>4、总结</strong></h1>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 运维初级学习笔记</title>
    <link href="/2020/08/18/linux_maintenance/"/>
    <url>/2020/08/18/linux_maintenance/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-了解-Linux"><a href="#一、-了解-Linux" class="headerlink" title="一、 了解 Linux"></a>一、 了解 Linux</h1><h2 id="1-1-Linux-的基本原则"><a href="#1-1-Linux-的基本原则" class="headerlink" title="1.1 Linux 的基本原则"></a>1.1 Linux 的基本原则</h2><ol><li>由目的单一的小程序组成；组合小程序完成复杂任务</li><li>一切皆文件</li><li>尽量避免捕获用户接口</li><li>配置文件保存为纯文本格式</li></ol><h2 id="1-2-GUI"><a href="#1-2-GUI" class="headerlink" title="1.2 GUI"></a>1.2 GUI</h2><pre><code class="hljs bash">Graphic User InterfaceWindowsX-Window    Gnome: C    RDE: C++    XFace</code></pre><h2 id="1-3-CLI"><a href="#1-3-CLI" class="headerlink" title="1.3 CLI"></a>1.3 CLI</h2><pre><code class="hljs bash">Command-line Interfaceshbashcshzshkshkshtcsh命令提示符，prompt，bash(shell)    <span class="hljs-comment">#: root</span>    $: 普通用户命令格式    命令   选项     参数            选项：                短选项：-                    多个选项可以组合：ls -a -l = ls -al                长选项：--            参数：命令作用的对象```  <span class="hljs-comment">## 1.4 su(SwitchUser，切换用户)</span>```bash    su - run a <span class="hljs-built_in">command</span> with substitute user and group ID[root@localhost ~]<span class="hljs-comment"># su [-l] 用户名</span></code></pre><h2 id="1-5-API-Application-program-Interface"><a href="#1-5-API-Application-program-Interface" class="headerlink" title="1.5 API(Application program Interface)"></a>1.5 API(Application program Interface)</h2><p> .so 文件：Shared Object 动态链接库，库文件，应用程序所需要的</p><h1 id="二、-常用命令"><a href="#二、-常用命令" class="headerlink" title="二、 常用命令"></a>二、 常用命令</h1><h2 id="2-1-ls"><a href="#2-1-ls" class="headerlink" title="2.1 ls"></a>2.1 ls</h2><pre><code class="hljs bash">ls    -l：长格式        文件类型：            -：普通文件（file）            d：目录文件（directory）            b：块设备文件（block）            c：字符设备文件（character）            l：符号链接文件（symbolic link file）            p：命令管道文件（pipe）            s：套接字文件（socket）[root@localhost ~]<span class="hljs-comment"># ls -l /dev</span>crw-------. 1 root root     10, 235 7月  20 18:39 autofsdrwxr-xr-x. 2 root root         200 8月   9 16:36 blocklrwrwxxrwx. 1 root root           3 7月  20 18:39 cdrom -&gt; sr0brw-rw----. 1 root cdrom    11,   0 7月  20 18:39 sr0srw-rw-rw-. 1 root root           0 7月  20 18:39 <span class="hljs-built_in">log</span>    -a：显示以 . 开头的隐藏文件    -i：index node，inode        [root@localhost ~]<span class="hljs-comment"># ls -li</span>        34051578 <span class="hljs-built_in">test</span>    -R：递归（recursive）显示</code></pre><h2 id="2-2-cd"><a href="#2-2-cd" class="headerlink" title="2.2 cd"></a>2.2 cd</h2><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>：change directory    <span class="hljs-built_in">cd</span> ~USERNAME：进入指定用户的 home 目录    <span class="hljs-built_in">cd</span> -：在当前目录和前一次所在目录之间来回切换</code></pre><h2 id="2-3-type"><a href="#2-3-type" class="headerlink" title="2.3 type"></a>2.3 type</h2><p>显示指定命令属于哪种类型<br>内置命令（shell 内置）：内部的，内建<br>外部命令：在文件系统的某个路径下有一个命令名称相应的可执行文件</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># type cd</span><span class="hljs-built_in">cd</span> 是 shell 内嵌        <span class="hljs-comment">#内置命令</span>[root@localhost ~]<span class="hljs-comment"># which ls</span><span class="hljs-built_in">alias</span> ls=<span class="hljs-string">&#x27;ls --color=auto&#x27;</span>  <span class="hljs-comment">#外部命令</span>        /usr/bin/ls</code></pre><h2 id="2-4-打印环境变量"><a href="#2-4-打印环境变量" class="headerlink" title="2.4 打印环境变量"></a>2.4 打印环境变量</h2><pre><code class="hljs bash">显示环境变量[root@localhost ~]<span class="hljs-comment"># printevn</span>PATH=/usr/<span class="hljs-built_in">local</span>/sbin:/usr/<span class="hljs-built_in">local</span>/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><h2 id="2-5-命令选项"><a href="#2-5-命令选项" class="headerlink" title="2.5 命令选项"></a>2.5 命令选项</h2><ul><li>&lt;&gt;：必选项</li><li>[]：可选项</li><li>…：可多次出现</li><li>|：多选一</li><li>{}：分组</li></ul><h1 id="三、-文件系统操作"><a href="#三、-文件系统操作" class="headerlink" title="三、 文件系统操作"></a>三、 文件系统操作</h1><h2 id="3-1-目录详解"><a href="#3-1-目录详解" class="headerlink" title="3.1 目录详解"></a>3.1 目录详解</h2><p>rootfs：根文件系统</p><pre><code class="hljs bash">/boot：系统启动相关文件，如内核、initrd 以及 grub(bootloader)/dev：设备文件        块设备：随机访问，将数据分为块，称为数据块，如硬盘        字符设备：线性访问，按字符为单位        设备号：主设备号（major）和次设备号（minor）/etc：配置文件/lib64：库文件    静态库    动态库：.so(shared object)    /modules：内核模块文件/opt：可选目录/proc：伪文件系统，内核映射文件/sys：伪文件系统，跟硬件设备相关的属性映射文件/tmp：临时文件/var：可变化文件，如存放日志文件/bin：可执行文件，用户命令/sbin：管理命令/usr：Unix Software Resource(shared,read-only),操作系统软件资源所放置的目录,所有系统默认的软件都会放置到/usr</code></pre><h2 id="3-2-管理"><a href="#3-2-管理" class="headerlink" title="3.2 管理"></a>3.2 管理</h2><h3 id="3-2-1-文件管理"><a href="#3-2-1-文件管理" class="headerlink" title="3.2.1 文件管理"></a>3.2.1 文件管理</h3><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><ul><li>touch：change file timestamps<br>  -a：修改访问时间<br>  -m：修改更改时间<br>  -t：修改到指定时间</li></ul><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><ul><li>stat：显示文件或文件系统状态</li></ul><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># stat test</span>  File: ‘<span class="hljs-built_in">test</span>’  Size: 4             Blocks: 8          IO Block: 4096   regular fileDevice: fd00h/64768d  Inode: 34051578    Links: 1Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)Context: unconfined_u:object_r:admin_home_t:s0Access: 2020-08-18 23:29:02.280000000 +0800Modify: 2020-08-18 23:26:58.260000000 +0800Change: 2020-08-18 23:29:02.280000000 +0800 Birth: -</code></pre><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><h3 id="3-2-2-目录管理"><a href="#3-2-2-目录管理" class="headerlink" title="3.2.2 目录管理"></a>3.2.2 目录管理</h3><ul><li>ls</li><li>cd</li><li>pwd</li><li>mkdir：创建空目录<br>  -p：依次创建层级目录，如 mkdir -p /1/2/3<br>  -v：显示详情</li></ul><pre><code class="hljs bash"><span class="hljs-comment">#例1：在目录下创建多个目录，如在空目录 /mnt/ 下创建 /mnt/test/x/m,/mnt/test/y</span>[root@localhost ~]<span class="hljs-comment"># mkdir -pv /mnt/test/&#123;x/m,y&#125;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test/x&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test/x/m&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test/y&quot;</span><span class="hljs-comment">#例2：在目录下创建 a_b,a_c,d_b,d_C 文件</span>[root@localhost ~]<span class="hljs-comment"># mkdir -pv /mnt/test2/&#123;a,d&#125;_&#123;b,c&#125;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2/a_b&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2/a_c&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2/d_b&quot;</span>mkdir: 已创建目录 <span class="hljs-string">&quot;/mnt/test2/d_c&quot;</span></code></pre><ul><li>rmdir：删除空目录</li></ul><h3 id="3-2-3-文本处理"><a href="#3-2-3-文本处理" class="headerlink" title="3.2.3 文本处理"></a>3.2.3 文本处理</h3><pre><code class="hljs bash">cut：    -d：指定字段分隔符，默认是空格    -f：指定要显示的字段        -f 1，3 显示字段1和3的字符        -f 1-3 显示字段1到3的字符</code></pre><h3 id="3-2-4-命令历史"><a href="#3-2-4-命令历史" class="headerlink" title="3.2.4 命令历史"></a>3.2.4 命令历史</h3><pre><code class="hljs bash"><span class="hljs-built_in">history</span>：查看历史命令    -c：清空命令历史    -d OFFSET [n]：删除指定位置的命令    -w：保存命令历史至历史文件中!n：执行命令历史的第N条命令</code></pre><h3 id="3-2-5-grep"><a href="#3-2-5-grep" class="headerlink" title="3.2.5 grep"></a>3.2.5 grep</h3><p>根据模式，搜索文本，并将符合模式的文本行显示出来<br>Pattern：文本字符和正则表达式的元字符组合而成的匹配条件</p><pre><code class="hljs bash">grep [OPTIONS] PATTERN [FILE...]        -i：忽略大小字母        -v：显示没有被匹配到的行        -o：只显示被模式匹配到的字符串        -E：使用扩展正则表达式        -A <span class="hljs-comment">#：显示匹配到的后#行</span>        -B <span class="hljs-comment">#：显示匹配到的前#行</span>        -C <span class="hljs-comment">#：显示匹配到的上下#行</span></code></pre><h3 id="3-2-6-正则表达式（REGular-EXPression-REGEXP）"><a href="#3-2-6-正则表达式（REGular-EXPression-REGEXP）" class="headerlink" title="3.2.6 正则表达式（REGular EXPression, REGEXP）"></a>3.2.6 正则表达式（REGular EXPression, REGEXP）</h3><p><strong>元字符：</strong></p><p>.：匹配其前面的字符任意次</p><p>[ ]：匹配指定范围内的任意单字符</p><p>[^]：匹配指定范围外的任意单个字符</p><table><thead><tr><th align="left">字符簇</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[[:alpha:]]</td><td align="left">任何字母</td></tr><tr><td align="left">[[:digit:]]</td><td align="left">任何数字</td></tr><tr><td align="left">[[:alnum:]]</td><td align="left">任何字母和数字</td></tr><tr><td align="left">[[:space:]]</td><td align="left">任何空白字符</td></tr><tr><td align="left">[[:upper:]]</td><td align="left">任何大写字母</td></tr><tr><td align="left">[[:lower:]]</td><td align="left">任何小写字母</td></tr><tr><td align="left">[[:punct:]]</td><td align="left">任何标点符号</td></tr><tr><td align="left">[[:xdigit:]]</td><td align="left">任何16进制的数字，相当于[0-9a-fA-F]</td></tr></tbody></table><p><strong>匹配次数：</strong></p><pre><code class="hljs bash">*：匹配其前面的字符任意次\?：匹配其前面的的字符1次或0次\&#123;m,n\&#125;：匹配其前面的字符至少m次，至多n次</code></pre><p><strong>位置锚定：</strong></p><pre><code class="hljs bash">^：锚定行首，此字符后面的任意内容必须出现在行首[root@localhost learing]<span class="hljs-comment"># cat test_grep_fenzu.txt </span> 1space  2space   3space<span class="hljs-comment">#显示行首至少有一个空白字符</span>[root@localhost learing]<span class="hljs-comment"># grep -E &#x27;^[[:space:]]+&#x27; test_grep_fenzu.txt </span> 1space  2space   3space$：锚定行尾，此字符后面的任意内容必须出现在行尾^$：空白行\&lt;或\b：锚定词首，其后面的任意字符必须作为单次首部出现\&gt;或\b：锚定词尾，其前面的任意字符必须作为单次尾部出现<span class="hljs-comment">#使用 \&lt;()\&gt; 找出1-255的数字</span>[root@localhost learing]<span class="hljs-comment"># ifconfig | grep -E &#x27;\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#x27;</span>        inet 192.168.2.22  netmask 255.255.255.0  broadcast 192.168.2.255        inet6 fd2a:2d84:d032:0:650f:b141:8e42:b014  prefixlen 64  scopeid 0x0&lt;global&gt;        inet6 fe80::3416:22f7:9cb1:88ba  prefixlen 64  scopeid 0x20&lt;link&gt;        inet6 fd2a:2d84:d032::778  prefixlen 128  scopeid 0x0&lt;global&gt;        RX packets 976525  bytes 271923354 (259.3 MiB)        TX packets 884321  bytes 110229028 (105.1 MiB)<span class="hljs-comment">#查找 ip 地址</span>[root@localhost learing]<span class="hljs-comment"># ifconfig | grep -E &#x27;(\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.)&#123;3&#125;\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#x27;</span>        inet 192.168.2.22  netmask 255.255.255.0  broadcast 192.168.2.255        inet 127.0.0.1  netmask 255.0.0.0</code></pre><p><strong>分组：</strong></p><pre><code class="hljs bash">\(\)    \(ab\)：ab为一整体出现[root@localhost learing]<span class="hljs-comment"># cat test_grep_fenzu.txt </span>catCatchinacCChina 1space  2space   3space<span class="hljs-comment">#not use ()</span>[root@localhost learing]<span class="hljs-comment"># grep -E &#x27;C|cat&#x27; test_grep_fenzu.txt </span>catCatCChina<span class="hljs-comment">#use ()</span>[root@localhost learing]<span class="hljs-comment"># grep -E &#x27;(C|c)at&#x27; test_grep_fenzu.txt </span>catCat</code></pre><h1 id="四、-bash"><a href="#四、-bash" class="headerlink" title="四、 bash"></a>四、 bash</h1><h2 id="4-1-变量类型"><a href="#4-1-变量类型" class="headerlink" title="4.1 变量类型"></a>4.1 变量类型</h2><p><strong>变量算法：</strong></p><p>$[$A-$B]：变量 A 减去 变量 B</p><h2 id="4-2-引用变量"><a href="#4-2-引用变量" class="headerlink" title="4.2 引用变量"></a>4.2 引用变量</h2><p>${VAR_NAME}，一般花括号可省略，某些情况无法省略</p><pre><code class="hljs bash"><span class="hljs-comment">#无法省略</span>[root@localhost learing]<span class="hljs-comment"># ANIMAL=pig</span>[root@localhost learing]<span class="hljs-comment"># echo &quot;there are some $ANIMALs.&quot;</span>there are some .[root@localhost learing]<span class="hljs-comment"># echo &quot;there are some $&#123;ANIMAL&#125;s.&quot;</span>there are some pigs.</code></pre><h2 id="4-3-程序执行返回代码"><a href="#4-3-程序执行返回代码" class="headerlink" title="4.3 程序执行返回代码"></a>4.3 程序执行返回代码</h2><p>程序执行返回状态码（0-255）：</p><ul><li>0：正确执行</li><li>1-255：错误执行，1、2、127 为系统预留</li></ul><h2 id="4-4-条件判断"><a href="#4-4-条件判断" class="headerlink" title="4.4 条件判断"></a>4.4 条件判断</h2><h3 id="4-4-1-条件测试类型"><a href="#4-4-1-条件测试类型" class="headerlink" title="4.4.1 条件测试类型"></a>4.4.1 条件测试类型</h3><ul><li>整数测试</li><li>字符测试</li><li>文件测试</li></ul><h3 id="4-4-2-条件测试表达式"><a href="#4-4-2-条件测试表达式" class="headerlink" title="4.4.2 条件测试表达式"></a>4.4.2 条件测试表达式</h3><ul><li>[ expression ]</li><li>[[ expression]]</li></ul><h3 id="4-4-3-命令逻辑关系"><a href="#4-4-3-命令逻辑关系" class="headerlink" title="4.4.3 命令逻辑关系"></a>4.4.3 命令逻辑关系</h3><p><strong>逻辑与：&amp;&amp;</strong></p><ul><li>第一个条件为假时，第二个条件就不用再判断，最总结果为假</li><li>第一个条件为真是，还需要判断第二个条件</li></ul><p>例子：</p><pre><code class="hljs bash"><span class="hljs-comment">#判断用户 user1 是否存在，不存在就增加 user1 用户</span>! id user1 &amp;&amp; useradd user1</code></pre><p><strong>逻辑或：||</strong><br>有个真，就是真<br>例子：</p><pre><code class="hljs bash"><span class="hljs-comment">#判断用户 user1 存在，就显示用户已存在，否则，就添加用户</span>id user1 &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;user1 exists.&#x27;</span> || useradd user1<span class="hljs-comment">#判断用户 user1 不存在，就添加用户，否则，显示已存在</span>! id user1 &amp;&amp; useradd user1 || <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;user1 exists.&#x27;</span></code></pre><h3 id="4-4-4-shell-算术运算"><a href="#4-4-4-shell-算术运算" class="headerlink" title="4.4.4 shell 算术运算"></a>4.4.4 shell 算术运算</h3><ol><li>let 算数表达式<ul><li>let C=$A+$B</li></ul></li><li>$[算术表达式]<ul><li>$[$A-$B]</li></ul></li><li>$((算术表达式))<ul><li>$((算术表达式))</li></ul></li></ol><h3 id="4-4-5-exit"><a href="#4-4-5-exit" class="headerlink" title="4.4.5 exit"></a>4.4.5 exit</h3><p>退出脚本</p><h3 id="4-4-6-文件测试"><a href="#4-4-6-文件测试" class="headerlink" title="4.4.6 文件测试"></a>4.4.6 文件测试</h3><ul><li>-e File：测试文件是否存在</li><li>-f File：测试文件是否为普通文件</li><li>-d File：测试指定目录是否为目录</li><li>-r File：测试当前用户对指定文件是否有可读权限</li><li>-w</li><li>-x</li></ul><h2 id="4-5-sed-Stream-EDitor"><a href="#4-5-sed-Stream-EDitor" class="headerlink" title="4.5 sed (Stream EDitor)"></a>4.5 sed (Stream EDitor)</h2><p><font color=red>默认不编辑原文件，仅对模式空间的数据做处理</font></p><pre><code class="hljs bash">sed [options] <span class="hljs-string">&#x27;AddressCommand&#x27;</span> file1 [file2 ...]    -n：静默模式，不再默认显示模式空间的内容    -i：直接修改原文件    -e script：可以同时执行多个脚本    -f filename：读取 filename 里的脚本处理 sed /path/to/sed_script 作用file    -r：表示使用扩展正则表达式</code></pre><p><strong>Address</strong></p><ol><li><p>StartLine,EndLine: </p><ul><li>1,100 ：1到100行</li><li>$：最后一行</li></ul></li><li><p>/模式定义/：/^root/</p></li><li><p>/pattern1/,/pattern2/：第一次被 pattern1 匹配到的行，至第一次被 pattern2 匹配到的行结束，中中间的行</p></li><li><p>LineNumber：指定的行数</p></li><li><p>StartLine，+N：从 StartLine 开始，向后的 N行</p></li></ol><p><strong>Command</strong></p><h3 id="4-5-1-d：删除符合条件的行"><a href="#4-5-1-d：删除符合条件的行" class="headerlink" title="4.5.1 d：删除符合条件的行"></a>4.5.1 d：删除符合条件的行</h3><pre><code>- sed &#39;1,3d&#39; /etc/fstab ：删除 fstab 的第 1 到 第 3 行- sed &#39;/oot/d&#39; /etc/fstab ：删除包含 oot 的行</code></pre><h3 id="4-5-2-p：显示符合条件的行"><a href="#4-5-2-p：显示符合条件的行" class="headerlink" title="4.5.2 p：显示符合条件的行"></a>4.5.2 p：显示符合条件的行</h3><pre><code>- sed -n &#39;/^\//a\#sed test&#39; /etc/fstab </code></pre><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># sed -n &#x27;/^\//p&#x27; /etc/fstab </span>/dev/mapper/centos-root /                       xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><h3 id="4-5-3-a-string：在指定的行后面追加新行，内容为-string"><a href="#4-5-3-a-string：在指定的行后面追加新行，内容为-string" class="headerlink" title="4.5.3 a \string：在指定的行后面追加新行，内容为 string"></a>4.5.3 a \string：在指定的行后面追加新行，内容为 string</h3><pre><code>- sed &#39;/^\//a\#sed test&#39; /etc/fstab ：在 / 开头的行下行添加一行内容为 #sed test 的行- \n 可以换行</code></pre><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># sed &#x27;/^\//a\#sed test&#x27; /etc/fstab </span><span class="hljs-comment">#</span><span class="hljs-comment"># /etc/fstab</span><span class="hljs-comment"># Created by anaconda on Sat Jun  6 20:09:07 2020</span><span class="hljs-comment">#</span><span class="hljs-comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span><span class="hljs-comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span><span class="hljs-comment">#</span>/dev/mapper/centos-root /                       xfs     defaults        0 0<span class="hljs-comment">#sed test</span>UUID=39b6f37f-531f-41c2-a498-dbe216fcfc4b /boot                   xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0<span class="hljs-comment">#sed test</span></code></pre><h3 id="4-5-4-i-string：在指定的行前面添加新行，内容为-string"><a href="#4-5-4-i-string：在指定的行前面添加新行，内容为-string" class="headerlink" title="4.5.4 i \string：在指定的行前面添加新行，内容为 string"></a>4.5.4 i \string：在指定的行前面添加新行，内容为 string</h3><h3 id="4-5-5-r-filename：将指定文件的内容添加至符合条件的行处"><a href="#4-5-5-r-filename：将指定文件的内容添加至符合条件的行处" class="headerlink" title="4.5.5 r filename：将指定文件的内容添加至符合条件的行处"></a>4.5.5 r filename：将指定文件的内容添加至符合条件的行处</h3><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cat /etc/issue</span>\SKernel \r on an \m[root@localhost ~]<span class="hljs-comment"># sed &#x27;1r /etc/issue&#x27; /etc/fstab </span>\SKernel \r on an \m<span class="hljs-comment">#</span><span class="hljs-comment"># /etc/fstab</span><span class="hljs-comment"># Created by anaconda on Sat Jun  6 20:09:07 2020</span><span class="hljs-comment">#</span><span class="hljs-comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span><span class="hljs-comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span><span class="hljs-comment">#</span>/dev/mapper/centos-root /                       xfs     defaults        0 0UUID=39b6f37f-531f-41c2-a498-dbe216fcfc4b /boot                   xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><h3 id="4-5-6-w-filename：将指定范围内的内容另存至指定的文件中"><a href="#4-5-6-w-filename：将指定范围内的内容另存至指定的文件中" class="headerlink" title="4.5.6 w filename：将指定范围内的内容另存至指定的文件中"></a>4.5.6 w filename：将指定范围内的内容另存至指定的文件中</h3><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># sed -n &#x27;/^\//w /root/mount.txt&#x27; /etc/fstab </span>[root@localhost ~]<span class="hljs-comment"># cat /root/mount.txt </span>/dev/mapper/centos-root /                       xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><h3 id="4-5-7-s-pattern-string-修饰符-：查找并替换，替换每行中第一次被匹配到的字符串"><a href="#4-5-7-s-pattern-string-修饰符-：查找并替换，替换每行中第一次被匹配到的字符串" class="headerlink" title="4.5.7 s/pattern/string/[修饰符]：查找并替换，替换每行中第一次被匹配到的字符串"></a>4.5.7 s/pattern/string/[修饰符]：查找并替换，替换每行中第一次被匹配到的字符串</h3><ul><li>修饰符<ul><li>g ：全局替换</li><li>i：忽略大小写</li></ul></li><li>s///,s###,s@@@：可使用其他分隔符</li></ul><pre><code class="hljs bash"><span class="hljs-comment">#查找 root 替换成 ROOT，查找能够用正则表达式</span>[root@localhost ~]<span class="hljs-comment"># sed &#x27;s/root/ROOT/&#x27; /etc/fstab </span>/dev/mapper/centos-ROOT /                       xfs     defaults        0 0UUID=39b6f37f-531f-41c2-a498-dbe216fcfc4b /boot                   xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></pre><h3 id="4-5-8-更改字符串"><a href="#4-5-8-更改字符串" class="headerlink" title="4.5.8 更改字符串"></a>4.5.8 更改字符串</h3><pre><code class="hljs bash"><span class="hljs-comment">#将字符带有 l..k 后面添加 r</span>[root@localhost learing]<span class="hljs-comment"># cat sed.txt </span>likelove<span class="hljs-comment">#第一种，用 &amp;</span>[root@localhost learing]<span class="hljs-comment"># sed &#x27;s/l..e/&amp;r/&#x27; sed.txt </span>likerlover<span class="hljs-comment">#第二种，用分组</span>[root@localhost learing]<span class="hljs-comment"># sed &#x27;s/\(l..e\)/\1r/&#x27; sed.txt </span>likerlover</code></pre><h3 id="4-5-9-删除每行开头的空格"><a href="#4-5-9-删除每行开头的空格" class="headerlink" title="4.5.9 删除每行开头的空格"></a>4.5.9 删除每行开头的空格</h3><pre><code class="hljs bash"><span class="hljs-comment">#可删除多个空格</span>[root@localhost learing]<span class="hljs-comment"># history | sed &#x27;s/^[[:space:]]*//g&#x27;</span>1022  <span class="hljs-built_in">history</span> | sed <span class="hljs-string">&#x27;s/ //&#x27;</span>1023  <span class="hljs-built_in">history</span> | sed <span class="hljs-string">&#x27;s/^ //&#x27;</span>1024  <span class="hljs-built_in">history</span> | sed <span class="hljs-string">&#x27;s/[[:space:]//&#x27;</span>1025  <span class="hljs-built_in">history</span> | sed <span class="hljs-string">&#x27;s/[[:space:]]//&#x27;</span>1026  <span class="hljs-built_in">history</span> | sed <span class="hljs-string">&#x27;s/^[[:space:]]+//&#x27;</span>1027  <span class="hljs-built_in">history</span> | sed <span class="hljs-string">&#x27;s/^[[:space:]]*//&#x27;</span>1028  <span class="hljs-built_in">history</span> | sed <span class="hljs-string">&#x27;s/^[[:space:]]+1//&#x27;</span>1029  <span class="hljs-built_in">history</span> | sed <span class="hljs-string">&#x27;s/^[[:space:]]*//&#x27;</span></code></pre><h2 id="4-6-字符串测试"><a href="#4-6-字符串测试" class="headerlink" title="4.6 字符串测试"></a>4.6 字符串测试</h2><h3 id="4-6-1-判断相等"><a href="#4-6-1-判断相等" class="headerlink" title="4.6.1 == 判断相等"></a>4.6.1 == 判断相等</h3><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># A=HELLO</span>[root@localhost ~]<span class="hljs-comment"># B=HI</span>[root@localhost ~]<span class="hljs-comment"># [ $A == $B ]</span>[root@localhost ~]<span class="hljs-comment"># echo $?</span>1</code></pre><h2 id="4-6-2-！-判断不等"><a href="#4-6-2-！-判断不等" class="headerlink" title="4.6.2 ！= 判断不等"></a>4.6.2 ！= 判断不等</h2><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># A=HELLO</span>[root@localhost ~]<span class="hljs-comment"># B=HI</span>[root@localhost ~]<span class="hljs-comment"># [ $A != $B ]</span>[root@localhost ~]<span class="hljs-comment"># echo $?</span>0</code></pre><h2 id="4-6-3-n-string-字符串为空"><a href="#4-6-3-n-string-字符串为空" class="headerlink" title="4.6.3 -n string 字符串为空"></a>4.6.3 -n string 字符串为空</h2><h2 id="4-6-4-s-string-字符串不为空"><a href="#4-6-4-s-string-字符串不为空" class="headerlink" title="4.6.4 -s string 字符串不为空"></a>4.6.4 -s string 字符串不为空</h2><h1 id="五、-存储"><a href="#五、-存储" class="headerlink" title="五、 存储"></a>五、 存储</h1><h2 id="5-1-接口"><a href="#5-1-接口" class="headerlink" title="5.1 接口"></a>5.1 接口</h2><ul><li>IDE</li></ul><p>理论速度：133Mbps，并行</p><ul><li>SATA</li></ul><p>理论速度：300Mbps，串行</p><ul><li>SATA2</li></ul><p>理论速度：600Mbps，串行</p><ul><li>SATA3</li></ul><p>理论速度：6Gbps，串行</p><ul><li>USB3.0</li></ul><p>理论速度：480Mbps，串行</p><ul><li>SCSI</li></ul><p>SCSI：Small Computer System Interface，并行</p><h2 id="5-2-RAID"><a href="#5-2-RAID" class="headerlink" title="5.2 RAID"></a>5.2 RAID</h2><p>TODO…</p><h2 id="5-3-mdadm-实现软-RAID"><a href="#5-3-mdadm-实现软-RAID" class="headerlink" title="5.3 mdadm 实现软 RAID"></a>5.3 mdadm 实现软 RAID</h2><h1 id="六、-网络"><a href="#六、-网络" class="headerlink" title="六、 网络"></a>六、 网络</h1><h1 id="七、-进程"><a href="#七、-进程" class="headerlink" title="七、 进程"></a>七、 进程</h1><h2 id="7-1-内核数据结构"><a href="#7-1-内核数据结构" class="headerlink" title="7.1 内核数据结构"></a>7.1 内核数据结构</h2><ul><li>task structure<ul><li>PPID</li><li>PID</li><li>Name </li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为 HCNA 学习笔记</title>
    <link href="/2020/07/26/Huawei_route_base/"/>
    <url>/2020/07/26/Huawei_route_base/</url>
    
    <content type="html"><![CDATA[<p>华为认证网络工程师是由华为公司认证与采购部推出的独立认证体系，与之前的华为认证不同，简称HCNA。</p><h1 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h1><h2 id="1-1-华为路由-交换视图切换"><a href="#1-1-华为路由-交换视图切换" class="headerlink" title="1.1 华为路由/交换视图切换"></a>1.1 华为路由/交换视图切换</h2><p>&lt;Huawei&gt; 用户视图 —-&gt; [Huawei] 系统视图</p><pre><code class="hljs routeros">&lt;Huawei&gt;system-view Enter<span class="hljs-built_in"> system </span>view, return<span class="hljs-built_in"> user </span>view with Ctrl+Z.[Huawei]</code></pre><h2 id="1-2-查看路由信息"><a href="#1-2-查看路由信息" class="headerlink" title="1.2 查看路由信息"></a>1.2 查看路由信息</h2><p>版本：</p><pre><code class="hljs routeros">&lt;Huawei&gt;dis version Huawei Versatile<span class="hljs-built_in"> Routing </span>Platform SoftwareVRP (R) software, Version 5.110 (eNSP V100R001C00)Copyright (c) 2000-2011 HUAWEI TECH CO., LTD</code></pre><p>操作系统 <font color=red>VRP</font>—&gt; Huawei Versatile Routing Platform Software</p><p>查看 flash（操作系统及配置文件都放在 flash 里面）：</p><pre><code class="hljs angelscript">&lt;Huawei&gt;dir#显示所有文件Directory of flash:/  Idx  Attr     Size(Byte)  Date        Time       FileName     <span class="hljs-number">0</span>  drw-              -  Aug <span class="hljs-number">07</span> <span class="hljs-number">2015</span> <span class="hljs-number">13</span>:<span class="hljs-number">51</span>:<span class="hljs-number">14</span>   src    <span class="hljs-number">1</span>  drw-              -  Jul <span class="hljs-number">31</span> <span class="hljs-number">2020</span> <span class="hljs-number">14</span>:<span class="hljs-number">34</span>:<span class="hljs-number">44</span>   pmdata    <span class="hljs-number">2</span>  drw-              -  Jul <span class="hljs-number">31</span> <span class="hljs-number">2020</span> <span class="hljs-number">14</span>:<span class="hljs-number">34</span>:<span class="hljs-number">50</span>   dhcp    <span class="hljs-number">3</span>  -rw-             <span class="hljs-number">28</span>  Jul <span class="hljs-number">31</span> <span class="hljs-number">2020</span> <span class="hljs-number">14</span>:<span class="hljs-number">34</span>:<span class="hljs-number">50</span>   <span class="hljs-keyword">private</span>-data.txt    <span class="hljs-number">4</span>  -rw-            <span class="hljs-number">452</span>  Jul <span class="hljs-number">31</span> <span class="hljs-number">2020</span> <span class="hljs-number">14</span>:<span class="hljs-number">39</span>:<span class="hljs-number">27</span>   vrpcfg.zip#路由配置信息，配置完路由器 save 后生成的文件<span class="hljs-number">32</span>,<span class="hljs-number">004</span> KB total (<span class="hljs-number">31</span>,<span class="hljs-number">995</span> KB free)</code></pre><p>文件操作命令：</p><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> vrpcfg.zip<span class="hljs-comment">#删除配置文件</span><span class="hljs-keyword">rename</span> vrpcfg.zip vrpcfg.zip.bak<span class="hljs-comment">#重命名配置文件</span>copy vrpcfg.zip vrpcfg.zip.bak<span class="hljs-comment">#复制文件</span>mkdirdemo<span class="hljs-comment">#创建文件夹</span>cd demo<span class="hljs-comment">#进入demo文件夹</span>unzip xx.zip <span class="hljs-comment">#解压</span>more xx<span class="hljs-comment">#查看文件内容</span>带 [ ] 表示位于回收站里的文件<span class="hljs-keyword">reset</span> <span class="hljs-keyword">recycle</span>-<span class="hljs-keyword">bin</span>  <span class="hljs-comment">#清空回收站</span></code></pre><h1 id="二、配置端口"><a href="#二、配置端口" class="headerlink" title="二、配置端口"></a>二、配置端口</h1><pre><code class="hljs routeros">[Huawei]int e0/0/0#进入端口[Huawei-Ethernet0/0/0]ip <span class="hljs-builtin-name">add</span> 192.168.1.1 24#配置ip和24位子网掩码[Huawei-Ethernet0/0/0]dis this#显示接口信息<span class="hljs-comment">#</span>interface Ethernet0/0/0<span class="hljs-built_in"> ip address </span>192.168.1.1 255.255.255.0<span class="hljs-comment">#</span>return[Huawei-Ethernet0/0/0]undo<span class="hljs-built_in"> ip address </span>#删除接口信息</code></pre><h2 id="2-1-显示接口摘要"><a href="#2-1-显示接口摘要" class="headerlink" title="2.1 显示接口摘要"></a>2.1 显示接口摘要</h2><pre><code class="hljs routeros">[Huawei]display<span class="hljs-built_in"> ip </span>int brief <span class="hljs-number">*d</span>own: administratively down!down: FIB overload down^down: standby(l): loopback(s): spoofing(d): Dampening SuppressedThe number of<span class="hljs-built_in"> interface </span>that is UP <span class="hljs-keyword">in</span> Physical is 3The number of<span class="hljs-built_in"> interface </span>that is DOWN <span class="hljs-keyword">in</span> Physical is 8The number of<span class="hljs-built_in"> interface </span>that is UP <span class="hljs-keyword">in</span> Protocol is 3The number of<span class="hljs-built_in"> interface </span>that is DOWN <span class="hljs-keyword">in</span> Protocol is 8Interface                        <span class="hljs-built_in"> IP </span>Address/Mask      Physical   Protocol  Ethernet0/0/0                     192.168.1.1/24       up         up        Ethernet0/0/1                     172.16.1.1/24        up         up        GigabitEthernet0/0/0              unassigned           down       down      GigabitEthernet0/0/1              unassigned           down       down      GigabitEthernet0/0/2              unassigned           down       down      GigabitEthernet0/0/3              unassigned           down       down      NULL0                             unassigned           up         up(s)     Serial0/0/0                       unassigned           down       down      Serial0/0/1                       unassigned           down       down      Serial0/0/2                       unassigned           down       down      Serial0/0/3                       unassigned           down       down</code></pre><h2 id="2-2-显示路由表"><a href="#2-2-显示路由表" class="headerlink" title="2.2 显示路由表"></a>2.2 显示路由表</h2><blockquote><p>路由器转发数据包的唯一依据，是路由器转发数据包的一张“地图”</p></blockquote><pre><code class="hljs angelscript">[Huawei]display ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public         Destinations : <span class="hljs-number">6</span>        Routes : <span class="hljs-number">6</span>        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">8</span>   Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0     <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>      Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>     <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>     Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span></code></pre><h2 id="2-3-关闭信息中心防止弹出日志"><a href="#2-3-关闭信息中心防止弹出日志" class="headerlink" title="2.3 关闭信息中心防止弹出日志"></a>2.3 关闭信息中心防止弹出日志</h2><pre><code class="hljs pgsql">[Huawei]undo <span class="hljs-keyword">info</span>-center <span class="hljs-keyword">enable</span> <span class="hljs-keyword">Info</span>: Information center <span class="hljs-keyword">is</span> disabled.</code></pre><h1 id="三、配置路由"><a href="#三、配置路由" class="headerlink" title="三、配置路由"></a>三、配置路由</h1><p><img src="/img/Huawei_route/Huawei_route_base_route.jpg"></p><h2 id="3-1-直连路由（Direct-routing）"><a href="#3-1-直连路由（Direct-routing）" class="headerlink" title="3.1 直连路由（Direct routing）"></a>3.1 直连路由（Direct routing）</h2><blockquote><p>路由器接口所连接的子网的路由方式称为直连路由</p></blockquote><p>直接连接的路由，当路由器的接口配置好 ip 地址并且 up 后，会自动创建该路由。路由器默认情况下，只能到达直连的网段。</p><p>列：路由器 R2 ，只能在直连网段 12.1.1.x 和 23.1.1.x 下通信</p><p><img src="/img/Huawei_route/Huawei_route_base_1.jpg"></p><p>其路由表：</p><p><img src="/img/Huawei_route/Huawei_route_base_2.jpg"></p><h2 id="3-2-静态路由（Static-routing）"><a href="#3-2-静态路由（Static-routing）" class="headerlink" title="3.2 静态路由（Static routing）"></a>3.2 静态路由（Static routing）</h2><blockquote><p>一种路由的方式，路由项（routing entry）由手动配置，而非动态决定。</p></blockquote><p>PC1 与 PC2 通信，需要配置静态路由：</p><p><img src="/img/Huawei_route/Huawei_route_base_3.jpg"></p><p>PC1 —&gt; PC2</p><p> <font color=pink>src:192.168.1.2 —&gt; dst:172.16.1.2</font></p><p>R1：</p><p>[R1]ip route-static <font color=red>172.16.1.0 24</font> <font color=blue>12.1.1.2</font></p><p><font color=red>红色</font>：目标网段</p><p><font color=blue>蓝色</font>：下一跳（next-hop），下一个传递者、承接者</p><p>路由表：</p><pre><code class="hljs angelscript">[R1]display ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public         Destinations : <span class="hljs-number">7</span>        Routes : <span class="hljs-number">7</span>        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface       <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>       <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">8</span>   Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0     <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Static  <span class="hljs-number">60</span>   <span class="hljs-number">0</span>          RD   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>     Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span></code></pre><p>R2：</p><p>[R2]ip route-static <font color=red>172.16.1.0 24</font> <font color=blue>23.1.1.3</font></p><p>回包路由配置：</p><p>PC2 —&gt; PC1</p><p><font color=pink>dst:192.168.1.2 &lt;— src:172.16.1.2</font></p><p>R3:</p><p>[R3]ip route-static 192.168.1.0 24 23.1.1.2</p><p>R2:</p><p>[R2]ip route-static 192.168.1.0 24 12.1.1.1</p><h2 id="3-3-路由优先级（Preference）"><a href="#3-3-路由优先级（Preference）" class="headerlink" title="3.3 路由优先级（Preference）"></a>3.3 路由优先级（Preference）</h2><blockquote><p>思科：管理距离。衡量路由的优先程度，到达同款同一目标有两种协议，此时优选路由优先级较小的路由协议。</p></blockquote><p>路由优先级范围：0-255</p><p>常见路由协议默认的优先级（数字越小，优先级越高）：</p><ul><li>直连路由 0</li><li>静态路由 60</li><li>Rip（路由信息协议） 100</li><li>Ospf（Open Shortest Path First开放式最短路径优先） 10</li></ul><p>禁用端口：</p><pre><code class="hljs awk">[Huawei]int e0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span> [Huawei-Ethernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>]shutdown<span class="hljs-comment">#关闭端口</span>[Huawei-Ethernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>]undo shutdown <span class="hljs-comment">#开启端口</span></code></pre><p><img src="/img/Huawei_route/Huawei_route_base_4.jpg"></p><p>目标：实现千兆 Ge 0/0/0 作为主链路，百兆 E 0/0/0 作为备份链路</p><p>R1:</p><pre><code class="hljs angelscript">[R1]ip route-static <span class="hljs-number">210.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">24</span> <span class="hljs-number">21.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> preference <span class="hljs-number">50</span></code></pre><p>CT：</p><pre><code class="hljs angelscript">[ct]ip route-static <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">24</span> <span class="hljs-number">21.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> preference <span class="hljs-number">50</span></code></pre><p>调整优先级：</p><pre><code class="hljs angelscript">[Huawei]ip route-static <span class="hljs-number">210.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">24</span> <span class="hljs-number">21.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> preference <span class="hljs-number">50</span></code></pre><p><font color=red>达到某相同目标网段，路由表始终放置最优路由</font></p><pre><code class="hljs angelscript">[Huawei]dis ip rouRoute Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public         Destinations : <span class="hljs-number">9</span>        Routes : <span class="hljs-number">9</span>        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface       <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>       <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>       <span class="hljs-number">21.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">21.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>        GigabitEthernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>       <span class="hljs-number">21.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       GigabitEthernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">8</span>   Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>     Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>      <span class="hljs-number">210.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Static  <span class="hljs-number">50</span>   <span class="hljs-number">0</span>          RD   <span class="hljs-number">21.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>        GigabitEthernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span></code></pre><h2 id="3-4-负载均衡"><a href="#3-4-负载均衡" class="headerlink" title="3.4 负载均衡"></a>3.4 负载均衡</h2><p>数据（负载）被均分到两条链路传输</p><h2 id="3-5-路由度量"><a href="#3-5-路由度量" class="headerlink" title="3.5 路由度量"></a>3.5 路由度量</h2><blockquote><p>度量值，路由开销，metric，cost。到达某目标所花费的开销（代价）的总和，用来衡量路径的优劣</p></blockquote><h2 id="3-6-缺省路由（Default-route）"><a href="#3-6-缺省路由（Default-route）" class="headerlink" title="3.6 缺省路由（Default route）"></a>3.6 缺省路由（Default route）</h2><blockquote><p>默认路由，default route，pre 60</p></blockquote><pre><code class="hljs angelscript">[Huawei]ip route-static <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> <span class="hljs-number">0</span> <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> #访问任何网段都将数据包交给 <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span></code></pre><p><font color=red>注：缺省路由属于特殊的静态路由</font></p><p><font color=red>注：PC 的网关其实就是一种缺省路由</font></p><p><font color=red>缺省路由属于“替补路由”，只有当其他路由不可达时才会使用缺省路由。</font></p><p>缺省路由适用于<font color=red>边缘节点</font>及<font color=red>企业出口</font></p><h2 id="3-7-环回接口（Loopback）"><a href="#3-7-环回接口（Loopback）" class="headerlink" title="3.7 环回接口（Loopback）"></a>3.7 环回接口（Loopback）</h2><blockquote><p>逻辑接口，模拟网段、PC、服务器、后期用于动态路由选举 Router-ID</p></blockquote><p>配置环回接口：</p><pre><code class="hljs angelscript">[Huawei]<span class="hljs-built_in">int</span> LoopBack <span class="hljs-number">0</span>[Huawei-LoopBack0]ip add <span class="hljs-number">220.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> <span class="hljs-number">24</span></code></pre><h2 id="3-8-DHCP（Dynamic-Host-Configuration-Protocol）"><a href="#3-8-DHCP（Dynamic-Host-Configuration-Protocol）" class="headerlink" title="3.8 DHCP（Dynamic Host Configuration Protocol）"></a>3.8 DHCP（Dynamic Host Configuration Protocol）</h2><blockquote><p>动态主机配置协议是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p></blockquote><p><font color=red>BOOTP（Bootstrap Protocol，引导程序协议）是一种引导协议，基于IP/UDP协议，也称自举协议，是DHCP协议的前身。</font></p><p><img src="/img/Huawei_route/Huawei_route_base_5.jpg"></p><p>开启 DHCP 功能：</p><pre><code class="hljs bash">[Huawei]dhcp <span class="hljs-built_in">enable</span></code></pre><p>创建地址池：</p><pre><code class="hljs routeros">[Huawei]ip<span class="hljs-built_in"> pool </span>add_pool[Huawei-ip-pool-add_pool]gateway-list 192.168.1.1[Huawei-ip-pool-add_pool]network 192.168.1.0 mask 24[Huawei-ip-pool-add_pool]dns-list 192.168.1.1 8.8.8.8[Huawei-ip-pool-add_pool]dis this<span class="hljs-comment">#</span>ip<span class="hljs-built_in"> pool </span>add_pool gateway-list 192.168.1.1<span class="hljs-built_in"> network </span>192.168.1.0 mask 255.255.255.0 dns-list 192.168.1.1 8.8.8.8<span class="hljs-comment">#</span>return[Huawei-ip-pool-add_pool]q[Huawei]int e0/0/0#和用户相连端口[Huawei-Ethernet0/0/0]dhcp select global #使用本地全局配置的地址池分配<span class="hljs-built_in"> IP </span>地址</code></pre><p>客户端 PC6 从本地服务地址池 add_pool 获取 DHCP 地址：</p><p><img src="/img/Huawei_route/Huawei_route_base_6.jpg"></p><p>获取地址包：</p><p><img src="/img/Huawei_route/Huawei_route_base_7.jpg"></p><p>用户发送的第一个 DHCP 请求包源是 0.0.0.0 目标为 255.255.255.255 的广播报文，该报文称为 dhcp discover</p><p><img src="/img/Huawei_route/Huawei_route_base_8.jpg"></p><p>显示 dhcp 分配记录：</p><pre><code class="hljs routeros">[Huawei]dis<span class="hljs-built_in"> ip pool </span>name add_pool used    Pool-name      : add_pool  Pool-No        : 0 <span class="hljs-built_in"> Lease </span>         : 1 Days 0 Hours 0 Minutes  Domain-name    : -  DNS-server0    : 192.168.1.1       DNS-server1    : 8.8.8.8           NBNS-server0   : -                 Netbios-type   : -                 Position       : Local           Status           : Unlocked  Gateway-0      : 192.168.1.1       Mask           : 255.255.255.0  VPN<span class="hljs-built_in"> instance </span>  : -- -----------------------------------------------------------------------------         Start           End     Total  Used  Idle(Expired)  Conflict  Disable -----------------------------------------------------------------------------     192.168.1.1   192.168.1.254   253     3        250(0)         0        0 -----------------------------------------------------------------------------  <span class="hljs-built_in"> Network </span>section :   --------------------------------------------------------------------------  Index             <span class="hljs-built_in"> IP </span>              MAC     <span class="hljs-built_in"> Lease </span>  Status    --------------------------------------------------------------------------    251   192.168.1.252    5489-98c2-3d98       3018   Used           252   192.168.1.253    5489-98e4-1b88       3360   Used           253   192.168.1.254    5489-9856-795c       3364   Used         --------------------------------------------------------------------------</code></pre><h2 id="3-9-RIP-Routing-Information-Protocol"><a href="#3-9-RIP-Routing-Information-Protocol" class="headerlink" title="3.9 RIP(Routing Information Protocol)"></a>3.9 RIP(Routing Information Protocol)</h2><blockquote><p>RIP（路由信息协议）协议基于距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。这种协议的路由器只关心自己周围的世界，只与自己相邻的路由器交换信息，范围限制在15跳(15度)之内，再远，它就不关心了。RIP应用于OSI网络七层模型的应用层。各厂家定义的管理距离（AD，即优先级）如下：华为定义的优先级是100，思科定义的优先级是120。缺点：古老，收敛速度很慢！</p></blockquote><p><img src="/img/Huawei_route/Huawei_route_base_9.jpg"></p><p>配置RIP：</p><p><img src="/img/Huawei_route/Huawei_route_base_10.jpg"></p><p>R1:</p><pre><code class="hljs routeros">[R1-rip-1]dis this<span class="hljs-comment">#</span>rip 1 undo summary#关闭自动汇总 version 2#版本2<span class="hljs-built_in"> network </span>192.168.1.0#宣告直连主类网络<span class="hljs-built_in"> network </span>12.0.0.0#宣告直连主类网络<span class="hljs-comment">#</span>return</code></pre><p>R2:</p><pre><code class="hljs routeros">[R2-rip-1]dis this<span class="hljs-comment">#</span>rip 1 undo summary version 2<span class="hljs-built_in"> network </span>12.0.0.0<span class="hljs-built_in"> network </span>23.0.0.0<span class="hljs-built_in"> network </span>172.16.0.0<span class="hljs-comment">#</span>return</code></pre><p>R3:</p><pre><code class="hljs routeros">[R3-rip-1]dis this<span class="hljs-comment">#</span>rip 1 undo summary version 2<span class="hljs-built_in"> network </span>23.0.0.0<span class="hljs-built_in"> network </span>10.0.0.0<span class="hljs-comment">#</span>return</code></pre><p>Rip 报文：</p><p><img src="/img/Huawei_route/Huawei_route_base_11.jpg"></p><p>每隔 30s 发送一次报文，目标地址是：224.0.0.9 组播地址，报文里存放的是路由信息</p><p><img src="/img/Huawei_route/Huawei_route_base_12.jpg"></p><p>Rip 只看距离远近，距离是以跳数（Metric，经过路由器的个数）</p><h2 id="3-10-静默接口（Silent-interface）"><a href="#3-10-静默接口（Silent-interface）" class="headerlink" title="3.10 静默接口（Silent-interface）"></a>3.10 静默接口（Silent-interface）</h2><p><font color=red>PC/客户端 不需要 Rip 报文，可以将路由连接客户端接口配置为抑制接口（silent-interface，静默接口）：</font></p><pre><code class="hljs angelscript">[Huawei-rip<span class="hljs-number">-1</span>]silent-<span class="hljs-keyword">interface</span> <span class="hljs-symbol">e0</span>/<span class="hljs-symbol">0</span>/<span class="hljs-symbol">0</span>#将 <span class="hljs-symbol">e0</span>/<span class="hljs-symbol">0</span>/<span class="hljs-symbol">0</span> 口配置为静默接口，<span class="hljs-symbol">Rip</span>的路由更新将不再从该接口发送</code></pre><p>此时，R1 的路由表：</p><pre><code class="hljs angelscript">[R1]dis ip routing-table Route Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public         Destinations : <span class="hljs-number">9</span>        Routes : <span class="hljs-number">9</span>        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface     <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  RIP     <span class="hljs-number">100</span>  <span class="hljs-number">2</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>#Rip优先级为<span class="hljs-number">100</span>       <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>       <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>       <span class="hljs-number">23.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  RIP     <span class="hljs-number">100</span>  <span class="hljs-number">1</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">8</span>   Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0     <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  RIP     <span class="hljs-number">100</span>  <span class="hljs-number">1</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>     Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span></code></pre><h2 id="3-11-OSPF-Open-Shortest-Path-First"><a href="#3-11-OSPF-Open-Shortest-Path-First" class="headerlink" title="3.11 OSPF(Open Shortest Path First)"></a>3.11 OSPF(Open Shortest Path First)</h2><blockquote><p>开放式最短路径优先协议是 IETF 定义的一种基于链路状态的内部网关路由协议</p></blockquote><p>ospf 优先级为：10</p><p><img src="/img/Huawei_route/Huawei_route_base_13.jpg"></p><p>Area 0：骨干区域、核心区域</p><p>Area 1、2…：常规区域</p><ul><li>每个区域都维护一个独立的LSDB</li><li><font color=red>Area 0是骨干区域，其他区域都必须与此区域相连</font></li></ul><h3 id="3-11-1-配置-OSPF："><a href="#3-11-1-配置-OSPF：" class="headerlink" title="3.11.1 配置 OSPF："></a>3.11.1 配置 OSPF：</h3><p><img src="/img/Huawei_route/Huawei_route_base_14.jpg"></p><p>R1：</p><pre><code class="hljs angelscript">[Huawei]ospf <span class="hljs-number">1</span>[Huawei-ospf<span class="hljs-number">-1</span>]area <span class="hljs-number">0</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]network <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> ?  X.X.X.X  OSPF wild card bits[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]network <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]network <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]dis <span class="hljs-keyword">this</span># area <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>  network <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>  network <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>#<span class="hljs-keyword">return</span></code></pre><p>R2：</p><pre><code class="hljs angelscript">[Huawei]ospf <span class="hljs-number">1</span>[Huawei-ospf<span class="hljs-number">-1</span>]area <span class="hljs-number">0</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]network <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]network <span class="hljs-number">23.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]network <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]dis <span class="hljs-keyword">this</span># area <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>  network <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>  network <span class="hljs-number">23.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>  network <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>#<span class="hljs-keyword">return</span></code></pre><p>R3:</p><pre><code class="hljs angelscript">[Huawei]ospf <span class="hljs-number">1</span>[Huawei-ospf<span class="hljs-number">-1</span>]area <span class="hljs-number">0</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]network <span class="hljs-number">23.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]network <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>[Huawei-ospf<span class="hljs-number">-1</span>-area<span class="hljs-number">-0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]dis <span class="hljs-keyword">this</span># area <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>  network <span class="hljs-number">23.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>  network <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>#<span class="hljs-keyword">return</span></code></pre><p>配置完 OSPF 的 R1 路由信息：</p><pre><code class="hljs angelscript">[Huawei]dis ip routing-tableRoute Flags: R - relay, D - download to fib------------------------------------------------------------------------------Routing Tables: Public         Destinations : <span class="hljs-number">9</span>        Routes : <span class="hljs-number">9</span>        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface     <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  OSPF    <span class="hljs-number">10</span>   <span class="hljs-number">3</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>       <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>       <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>       <span class="hljs-number">23.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  OSPF    <span class="hljs-number">10</span>   <span class="hljs-number">2</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">8</span>   Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       InLoopBack0     <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  OSPF    <span class="hljs-number">10</span>   <span class="hljs-number">2</span>           D   <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>        Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>     Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>/<span class="hljs-number">32</span>  Direct  <span class="hljs-number">0</span>    <span class="hljs-number">0</span>           D   <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>       Ethernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span></code></pre><h3 id="3-11-2-OSPF-的报文：常见5种"><a href="#3-11-2-OSPF-的报文：常见5种" class="headerlink" title="3.11.2 OSPF 的报文：常见5种"></a>3.11.2 OSPF 的报文：常见5种</h3><p>hello：小巧，用来建立和维持邻居关系</p><p><img src="/img/Huawei_route/Huawei_route_base_15.jpg"></p><p>DBD 、LSR、LSU、LSack：用于传递路由信息，刚开始时发送</p><p>重置 OSPF 进程来抓取上面4个包：</p><pre><code class="hljs routeros">&lt;Huawei&gt;reset<span class="hljs-built_in"> ospf </span>process #重置（reset）大多需要在\&lt;Huawei&gt; 用户视图 下操作Warning: The<span class="hljs-built_in"> OSPF </span>process will be reset. Continue? [Y/N]:y</code></pre><p><img src="/img/Huawei_route/Huawei_route_base_16.jpg"></p><h3 id="3-11-3-OSPF-邻居表"><a href="#3-11-3-OSPF-邻居表" class="headerlink" title="3.11.3 OSPF 邻居表"></a>3.11.3 OSPF 邻居表</h3><pre><code class="hljs routeros">[R2]dis<span class="hljs-built_in"> ospf peer </span>brief <span class="hljs-built_in"> OSPF </span>Process 1 with Router ID 12.1.1.2 <span class="hljs-built_in"> Peer </span>Statistic Information ----------------------------------------------------------------------------<span class="hljs-built_in"> Area </span>Id         <span class="hljs-built_in"> Interface </span>                      <span class="hljs-built_in"> Neighbor </span>id      State     0.0.0.0          Ethernet0/0/0                    192.168.1.1      Full         0.0.0.0          Ethernet0/0/1                    23.1.1.1         Full         ----------------------------------------------------------------------------</code></pre><h3 id="3-11-4-OSPF-静默接口（silent-interface）"><a href="#3-11-4-OSPF-静默接口（silent-interface）" class="headerlink" title="3.11.4 OSPF 静默接口（silent-interface）"></a>3.11.4 OSPF 静默接口（silent-interface）</h3><pre><code class="hljs routeros">[R1]ospf 1[R1-ospf-1]silent-interface e0/0/0[R1-ospf-1]dis this<span class="hljs-comment">#</span>ospf 1 silent-interface Ethernet0/0/0<span class="hljs-built_in"> area </span>0.0.0.0 <span class="hljs-built_in"> network </span>192.168.1.0 0.0.0.255 <span class="hljs-built_in"> network </span>12.1.1.0 0.0.0.255<span class="hljs-comment">#</span>return</code></pre><h2 id="3-12-Telnet"><a href="#3-12-Telnet" class="headerlink" title="3.12 Telnet"></a>3.12 Telnet</h2><p><img src="/img/Huawei_route/Huawei_route_base_17.jpg"></p><p>开启 telnet 服务（华为默认开启）：</p><pre><code class="hljs routeros">[R4]telnet<span class="hljs-built_in"> server </span><span class="hljs-builtin-name">enable</span> Info: The Telnet<span class="hljs-built_in"> server </span>has been enabled.</code></pre><p>R4 创建用户名和密码：</p><pre><code class="hljs ada">[R4]aaa#三 A 认证[R4-aaa]local-user ?  STRING&lt;<span class="hljs-number">1</span>-<span class="hljs-number">64</span>&gt;   User name, <span class="hljs-keyword">in</span> form <span class="hljs-keyword">of</span> <span class="hljs-symbol">&#x27;user</span>@domain&#x27;. Can <span class="hljs-keyword">use</span> wildcard <span class="hljs-string">&#x27;*&#x27;</span>,                 <span class="hljs-keyword">while</span> displaying <span class="hljs-keyword">and</span> modifying, such as *@isp,user@*,*@*.Can                 <span class="hljs-keyword">not</span> include invalid character / \ : * ? &quot; &lt; &gt; | @ &#x27;[R4-aaa]local-user telnetuser ?  <span class="hljs-keyword">access</span>-limit   Set <span class="hljs-keyword">access</span> limit <span class="hljs-keyword">of</span> user(s)  ftp-directory  Set user(s) FTP directory permitted  idle-timeout   Set the timeout period <span class="hljs-keyword">for</span> terminal user(s)  password       Set password   privilege      Set admin user(s) level  service-<span class="hljs-keyword">type</span>   <span class="hljs-type">Service </span>types <span class="hljs-keyword">for</span> authorized user(s)  state          Activate/Block the user(s)  user-group     User group[R4-aaa]local-user telnetuser password cipher telnetuser privilege level <span class="hljs-number">3</span> #配置用户名密码，权限为<span class="hljs-number">3</span>[R4-aaa]local-user telnetuser service-<span class="hljs-keyword">type</span> <span class="hljs-type">telnet  </span>#指定账户的类型为 telnet[R4]user-<span class="hljs-keyword">interface</span> [R4]user-<span class="hljs-keyword">interface</span> ?  INTEGER&lt;<span class="hljs-number">0</span>,<span class="hljs-number">34</span>-<span class="hljs-number">48</span>,<span class="hljs-number">50</span>-<span class="hljs-number">54</span>&gt;   The first user terminal <span class="hljs-keyword">interface</span> to be configured  console                  Primary user terminal <span class="hljs-keyword">interface</span>  current                  The current user terminal <span class="hljs-keyword">interface</span>  maximum-vty              The maximum number <span class="hljs-keyword">of</span> VTY users, the default value                           <span class="hljs-keyword">is</span> <span class="hljs-number">5</span>  vty                      The virtual user terminal <span class="hljs-keyword">interface</span> [R4]user-<span class="hljs-keyword">interface</span> vty <span class="hljs-number">0</span> <span class="hljs-number">4</span>[R4-ui-vty0-<span class="hljs-number">4</span>]au[R4-ui-vty0-<span class="hljs-number">4</span>]authe[R4-ui-vty0-<span class="hljs-number">4</span>]authentication-mode ?  aaa       AAA authentication  none      Login without checking  password  Authentication through the password <span class="hljs-keyword">of</span> a user terminal <span class="hljs-keyword">interface</span>[R4-ui-vty0-<span class="hljs-number">4</span>]authentication-mode aaa[R4-ui-vty0-<span class="hljs-number">4</span>]dis this#user-<span class="hljs-keyword">interface</span> con <span class="hljs-number">0</span>user-<span class="hljs-keyword">interface</span> vty <span class="hljs-number">0</span> <span class="hljs-number">4</span> authentication-mode aaauser-<span class="hljs-keyword">interface</span> vty <span class="hljs-number">16</span> <span class="hljs-number">20</span>#<span class="hljs-keyword">return</span>[R4]user-<span class="hljs-keyword">interface</span> ?  INTEGER&lt;<span class="hljs-number">0</span>,<span class="hljs-number">34</span>-<span class="hljs-number">48</span>,<span class="hljs-number">50</span>-<span class="hljs-number">54</span>&gt;   The first user terminal <span class="hljs-keyword">interface</span> to be configured  console                  Primary user terminal <span class="hljs-keyword">interface</span>  current                  The current user terminal <span class="hljs-keyword">interface</span>  maximum-vty              The maximum number <span class="hljs-keyword">of</span> VTY users, the default value                           <span class="hljs-keyword">is</span> <span class="hljs-number">5</span>  vty                      The virtual user terminal <span class="hljs-keyword">interface</span> [R4]user-<span class="hljs-keyword">interface</span> vty <span class="hljs-number">0</span> <span class="hljs-number">4</span># 同时允许<span class="hljs-number">5</span>个人远程控制[R4-ui-vty0-<span class="hljs-number">4</span>]authentication-mode ?  aaa       AAA authentication  none      Login without checking  password  Authentication through the password <span class="hljs-keyword">of</span> a user terminal <span class="hljs-keyword">interface</span>[R4-ui-vty0-<span class="hljs-number">4</span>]authentication-mode aaa#认证模式为 aaa [R4-ui-vty0-<span class="hljs-number">4</span>]dis this#user-<span class="hljs-keyword">interface</span> con <span class="hljs-number">0</span>user-<span class="hljs-keyword">interface</span> vty <span class="hljs-number">0</span> <span class="hljs-number">4</span> authentication-mode aaauser-<span class="hljs-keyword">interface</span> vty <span class="hljs-number">16</span> <span class="hljs-number">20</span>#<span class="hljs-keyword">return</span></code></pre><p>R1 连接 telnet 服务端：</p><pre><code class="hljs routeros">&lt;R1&gt;telnet 34.1.1.2Trying 34.1.1.2 <span class="hljs-built_in">..</span>.Press CTRL+K <span class="hljs-keyword">to</span> abortConnected <span class="hljs-keyword">to</span> 34.1.1.2 <span class="hljs-built_in">..</span>.Login authenticationUsername:adminPassword:Info: The max number of VTY<span class="hljs-built_in"> users </span>is 10, <span class="hljs-keyword">and</span> the number      of current VTY<span class="hljs-built_in"> users </span>on line is 1.      The current login time is 2020-07-31 10:14:55.&lt;R4&gt;</code></pre><h3 id="3-12-1-PC-客户端连接-telnet-服务器："><a href="#3-12-1-PC-客户端连接-telnet-服务器：" class="headerlink" title="3.12.1 PC 客户端连接 telnet 服务器："></a>3.12.1 PC 客户端连接 telnet 服务器：</h3><p>PC 开启 telnet 服务：</p><p>控制面板–&gt;程序–&gt;启动或关闭 Windows 功能 –&gt; Telnet Client</p><p><img src="/img/Huawei_route/Huawei_route_base_19.jpg"></p><p>本机 PC 连接 eNSP Cloud 设置：</p><p><img src="/img/Huawei_route/Huawei_route_base_18.jpg"></p><p>本机需要增加静态路由从192.168.1.1 通信：</p><p><img src="/img/Huawei_route/Huawei_route_base_20.jpg"></p><p>显示本地 PC 路由表：</p><p><img src="/img/Huawei_route/Huawei_route_base_21.jpg"></p><h2 id="3-13-FTP（File-Transfer-Protocol"><a href="#3-13-FTP（File-Transfer-Protocol" class="headerlink" title="3.13 FTP（File Transfer Protocol)"></a>3.13 FTP（File Transfer Protocol)</h2><p>使用 FTP 实现远程文件传输的同时，还可以保证数据传输的可靠性和高效性。</p><h3 id="3-13-1-开启-FTP-服务"><a href="#3-13-1-开启-FTP-服务" class="headerlink" title="3.13.1 开启 FTP 服务"></a>3.13.1 开启 FTP 服务</h3><pre><code class="hljs routeros">[R4]ftp<span class="hljs-built_in"> server </span><span class="hljs-builtin-name">enable</span> Info: Succeeded <span class="hljs-keyword">in</span> starting the FTP server.</code></pre><p><img src="/img/Huawei_route/Huawei_route_base_22.jpg"></p><p>创建 FTP  账户：</p><pre><code class="hljs crmsh">[R4]aaa[R4-aaa]local-<span class="hljs-keyword">user</span> <span class="hljs-title">ftpuser</span> password cipher ftpuser privilege level <span class="hljs-number">3</span> ftp-directory flash:<span class="hljs-literal">Inf</span>o: Add a new user.[R4-aaa]local-<span class="hljs-keyword">user</span> <span class="hljs-title">ftpuser</span> service-<span class="hljs-keyword">type</span> ftp<span class="hljs-comment">#此账户用于 FTP 服务</span></code></pre><p>连接 FTP 服务器：</p><pre><code class="hljs angelscript">&lt;R1&gt;ftp <span class="hljs-number">34.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>Trying <span class="hljs-number">34.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> ...Press CTRL+K to abortConnected to <span class="hljs-number">34.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>.<span class="hljs-number">220</span> FTP service ready.User(<span class="hljs-number">34.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>:(none)):ftpuser<span class="hljs-number">331</span> Password required <span class="hljs-keyword">for</span> ftpuser.Enter password:<span class="hljs-number">230</span> User logged <span class="hljs-keyword">in</span>.[ftp]dir<span class="hljs-number">200</span> Port command okay.<span class="hljs-number">150</span> Opening ASCII mode data connection <span class="hljs-keyword">for</span> *.drwxrwxrwx   <span class="hljs-number">1</span> noone    nogroup         <span class="hljs-number">0</span> Aug <span class="hljs-number">07</span>  <span class="hljs-number">2015</span> srcdrwxrwxrwx   <span class="hljs-number">1</span> noone    nogroup         <span class="hljs-number">0</span> Jul <span class="hljs-number">31</span> <span class="hljs-number">08</span>:<span class="hljs-number">39</span> pmdatadrwxrwxrwx   <span class="hljs-number">1</span> noone    nogroup         <span class="hljs-number">0</span> Jul <span class="hljs-number">31</span> <span class="hljs-number">08</span>:<span class="hljs-number">39</span> dhcp-rwxrwxrwx   <span class="hljs-number">1</span> noone    nogroup       <span class="hljs-number">603</span> Jul <span class="hljs-number">31</span> <span class="hljs-number">15</span>:<span class="hljs-number">09</span> <span class="hljs-keyword">private</span>-data.txtdrwxrwxrwx   <span class="hljs-number">1</span> noone    nogroup         <span class="hljs-number">0</span> Jul <span class="hljs-number">31</span> <span class="hljs-number">08</span>:<span class="hljs-number">54</span> mplstpoam-rwxrwxrwx   <span class="hljs-number">1</span> noone    nogroup       <span class="hljs-number">507</span> Jul <span class="hljs-number">31</span> <span class="hljs-number">15</span>:<span class="hljs-number">19</span> ftp.demo-rwxrwxrwx   <span class="hljs-number">1</span> noone    nogroup       <span class="hljs-number">507</span> Jul <span class="hljs-number">31</span> <span class="hljs-number">15</span>:<span class="hljs-number">09</span> vrpcfg.zip<span class="hljs-number">226</span> Transfer complete.</code></pre><h1 id="四、构建冗余型企业网络"><a href="#四、构建冗余型企业网络" class="headerlink" title="四、构建冗余型企业网络"></a>四、构建冗余型企业网络</h1><p>VLAN、Trunk、STP、VRRP、链路聚合、ACL</p><h2 id="4-1-VLAN（Virtual-Local-Area-Network）"><a href="#4-1-VLAN（Virtual-Local-Area-Network）" class="headerlink" title="4.1 VLAN（Virtual Local Area Network）"></a>4.1 VLAN（Virtual Local Area Network）</h2><blockquote><p>虚拟局域网是将一个物理的局域网在逻辑上划分成多个广播域的技术。通过在交换机上配置 VLAN ，可以实现在同一个 VLAN 内的用户可以进行二层互访，而不同 VLAN 间的用户被二层隔离。这样既能够隔离广播域，又能够提升网络的安全性。</p></blockquote><h3 id="4-1-1-配置"><a href="#4-1-1-配置" class="headerlink" title="4.1.1 配置"></a>4.1.1 配置</h3><p><img src="/img/Huawei_route/Huawei_route_base_23.jpg"></p><p>创建 VLAN：</p><pre><code class="hljs routeros">[SW1]vlan batch 10 20#同时创建多个<span class="hljs-built_in"> VLAN </span>：<span class="hljs-built_in"> VLAN </span>10 、VLAN 20[SW1]int gi0/0/1#进入 GE 0/0/1 口[SW1-GigabitEthernet0/0/1]port link-type access #将接口类型配置为 access[SW1-GigabitEthernet0/0/1]port<span class="hljs-built_in"> default vlan </span>10 #将接口划分到<span class="hljs-built_in"> VLAN </span>10 里[SW1-GigabitEthernet0/0/1]dis this<span class="hljs-comment">#</span>interface GigabitEthernet0/0/1<span class="hljs-built_in"> port </span>link-type access<span class="hljs-built_in"> port default vlan </span>10<span class="hljs-comment">#</span>return<span class="hljs-comment">#查看 VLAN 配置</span>[SW1]dis vlanThe total number of vlans is : 3--------------------------------------------------------------------------------U: Up;         D: Down;         TG: Tagged;         UT: Untagged;MP: Vlan-mapping;               ST: Vlan-stacking;<span class="hljs-comment">#: ProtocolTransparent-vlan;    *: Management-vlan;</span>--------------------------------------------------------------------------------VID <span class="hljs-built_in"> Type </span>   Ports                                                          --------------------------------------------------------------------------------1    common  UT:GE0/0/4(U)      GE0/0/5(D)      GE0/0/6(D)      GE0/0/7(D)                      GE0/0/8(D)      GE0/0/9(D)      GE0/0/10(D)     GE0/0/11(D)                     GE0/0/12(D)     GE0/0/13(D)     GE0/0/14(D)     GE0/0/15(D)                     GE0/0/16(D)     GE0/0/17(D)     GE0/0/18(D)     GE0/0/19(D)                     GE0/0/20(D)     GE0/0/21(D)     GE0/0/22(D)     GE0/0/23(D)                     GE0/0/24(D)                                                     10   common  UT:GE0/0/1(U)      GE0/0/2(U)                                      20   common  UT:GE0/0/3(U)                                                      VID  Status  Property      MAC-LRN Statistics Description      --------------------------------------------------------------------------------1    <span class="hljs-builtin-name">enable</span> <span class="hljs-built_in"> default </span>      <span class="hljs-builtin-name">enable</span>  <span class="hljs-builtin-name">disable</span>   <span class="hljs-built_in"> VLAN </span>0001                         10   <span class="hljs-builtin-name">enable</span> <span class="hljs-built_in"> default </span>      <span class="hljs-builtin-name">enable</span>  <span class="hljs-builtin-name">disable</span>   <span class="hljs-built_in"> VLAN </span>0010                         20   <span class="hljs-builtin-name">enable</span> <span class="hljs-built_in"> default </span>      <span class="hljs-builtin-name">enable</span>  <span class="hljs-builtin-name">disable</span>   <span class="hljs-built_in"> VLAN </span>0020</code></pre><p><font color=red>注： VLAN 1 属于默认 VLAN，默认情况下所有接口都在 VLAN 1 下。VLAN 隔离广播的同时，也会隔离 arp，从而导致单播无法通信。如果想让不同 VLAN 单播可以通信，还需要三层设备（路由器、三层交换机）做路由。</font></p><p>注：默认情况下，交换机的一个接口只能从属一个 VLAN，只允许该 VLAN 的数据通过。</p><h2 id="4-2-Trunk（干道，主干链路）"><a href="#4-2-Trunk（干道，主干链路）" class="headerlink" title="4.2 Trunk（干道，主干链路）"></a>4.2 Trunk（干道，主干链路）</h2><blockquote><p>通常用于交换机和交换机之间，通过一个接口传输多个 VLAN 的数据包。</p></blockquote><h3 id="4-2-1-配置"><a href="#4-2-1-配置" class="headerlink" title="4.2.1 配置"></a>4.2.1 配置</h3><p><img src="/img/Huawei_route/Huawei_route_base_24.jpg"></p><p>将交换机与交换机相连接的端口类型改为 Trunk 类型</p><pre><code class="hljs routeros">[SW1]int gi0/0/4[SW1-GigabitEthernet0/0/4]port link-type trunk #将接口类型配置为 trunk[SW1-GigabitEthernet0/0/4]port trunk allow-pass<span class="hljs-built_in"> vlan </span>all #允许所有的<span class="hljs-built_in"> VLAN </span>通过[SW1-GigabitEthernet0/0/4]dis this<span class="hljs-comment">#</span>interface GigabitEthernet0/0/4<span class="hljs-built_in"> port </span>link-type trunk<span class="hljs-built_in"> port </span>trunk allow-pass<span class="hljs-built_in"> vlan </span>2 <span class="hljs-keyword">to</span> 4094<span class="hljs-comment">#</span>return[SW1-GigabitEthernet0/0/4]port link-type ?  access        Access<span class="hljs-built_in"> port</span>#接 PC 端口  dot1q-tunnel  QinQ port  hybrid        Hybrid<span class="hljs-built_in"> port</span>#混合口 即可以接 PC 也可以接交换机（华为交换机的默认接口）  trunk         Trunk<span class="hljs-built_in"> port</span>#接交换机  <span class="hljs-comment">#查看接口类型</span>[SW1]dis<span class="hljs-built_in"> port </span>vlanPort                    Link<span class="hljs-built_in"> Type </span>   PVID  Trunk<span class="hljs-built_in"> VLAN </span>List-------------------------------------------------------------------------------GigabitEthernet0/0/1    access       10    -                                   GigabitEthernet0/0/2    access       10    -                                   GigabitEthernet0/0/3    access       20    -                                   GigabitEthernet0/0/4    trunk        1     1GigabitEthernet0/0/5    hybrid       1     -                                   GigabitEthernet0/0/6    hybrid       1     -                                             GigabitEthernet0/0/7    hybrid       1     -</code></pre><p>PC 到交换机 access 口的包：</p><p><img src="/img/Huawei_route/Huawei_route_base_25.jpg"></p><p><font color=red>注：PC 不识 VLAN 标记，不识 tag，只有通过交换机的 trunk 接口发出的报文才具备 VLAN 的标记（802.1q tag），见下图</font></p><p>交换机 trunk 到 trunk 交换机包：</p><p><img src="/img/Huawei_route/Huawei_route_base_26.jpg"></p><h3 id="4-2-2-PVID-本征-VLAN，native-vlan"><a href="#4-2-2-PVID-本征-VLAN，native-vlan" class="headerlink" title="4.2.2 PVID(本征 VLAN，native vlan)"></a>4.2.2 PVID(本征 VLAN，native vlan)</h3><p>该 VLAN 的报文经过 trunk 接口时不打标记。默认情况下本征 VLAN 是 VLAN 1。</p><pre><code class="hljs routeros">[SW1]dis<span class="hljs-built_in"> port vlan </span>Port                    Link<span class="hljs-built_in"> Type </span>   PVID  Trunk<span class="hljs-built_in"> VLAN </span>List-------------------------------------------------------------------------------GigabitEthernet0/0/1    access       10    -                                   GigabitEthernet0/0/2    access       10    -                                   GigabitEthernet0/0/3    access       20    -                                   GigabitEthernet0/0/4    trunk        1     1-4094GigabitEthernet0/0/5    hybrid       1     -                                   GigabitEthernet0/0/6    hybrid       1     -                                   GigabitEthernet0/0/7    hybrid       1     -</code></pre><p>例：</p><p><img src="/img/Huawei_route/Huawei_route_base_27.jpg"></p><p>PC8 和 PC9 默认属于 VLAN 1，它们通信经过交换机 trunk 时，是不打 tag 的。</p><p><img src="/img/Huawei_route/Huawei_route_base_28.jpg"></p><h4 id="修改-PVID"><a href="#修改-PVID" class="headerlink" title="修改 PVID"></a>修改 PVID</h4><pre><code class="hljs routeros"><span class="hljs-comment">#两台相连交换机 trunk 都需要修改</span>[SW1]int gi 0/0/4[SW1-GigabitEthernet0/0/4]port trunk pvid<span class="hljs-built_in"> vlan </span>20[SW2]int gi 0/0/1[SW2-GigabitEthernet0/0/1]port trunk pvid<span class="hljs-built_in"> vlan </span>20</code></pre><p>当 PVID 修改为 VLAN 20 后，VLAN 20 下的 PC 通信经过交换机 trunk 时不打 tag。</p><h2 id="4-3-VLAN-间路由"><a href="#4-3-VLAN-间路由" class="headerlink" title="4.3 VLAN 间路由"></a>4.3 VLAN 间路由</h2><p><font color=red>注：不同的 VLAN 之间互相通信必须要有三层设备（路由器、多层交换机）做中转。</font></p><h3 id="4-3-1-多层交换机–SVI（switch-virtual-interface，常用）"><a href="#4-3-1-多层交换机–SVI（switch-virtual-interface，常用）" class="headerlink" title="4.3.1 多层交换机–SVI（switch virtual interface，常用）"></a>4.3.1 多层交换机–SVI（switch virtual interface，常用）</h3><p><img src="/img/Huawei_route/Huawei_route_base_29.jpg"></p><h4 id="SVI-配置"><a href="#SVI-配置" class="headerlink" title="SVI 配置"></a>SVI 配置</h4><pre><code class="hljs routeros">[Huawei]int Vlanif 10[Huawei-Vlanif10]ip<span class="hljs-built_in"> address </span>192.168.10.1 24#给<span class="hljs-built_in"> VLAN </span>10 配置<span class="hljs-built_in"> ip </span>地址 10.1 作为<span class="hljs-built_in"> VLAN </span>10 的用户网关[Huawei-Vlanif10]dis this<span class="hljs-comment">#</span>interface Vlanif10<span class="hljs-built_in"> ip address </span>192.168.10.1 255.255.255.0<span class="hljs-comment">#</span>return[Huawei]int Vlanif 20[Huawei-Vlanif20]ip<span class="hljs-built_in"> address </span>192.168.20.1 24#给<span class="hljs-built_in"> VLAN </span>20 配置<span class="hljs-built_in"> ip </span>地址 20.1 作为<span class="hljs-built_in"> VLAN </span>20 的用户网关<span class="hljs-comment">#调试</span>[Huawei]dis<span class="hljs-built_in"> ip interface </span>brief <span class="hljs-number">*d</span>own: administratively down^down: standby(l): loopback(s): spoofingThe number of<span class="hljs-built_in"> interface </span>that is UP <span class="hljs-keyword">in</span> Physical is 4The number of<span class="hljs-built_in"> interface </span>that is DOWN <span class="hljs-keyword">in</span> Physical is 1The number of<span class="hljs-built_in"> interface </span>that is UP <span class="hljs-keyword">in</span> Protocol is 3The number of<span class="hljs-built_in"> interface </span>that is DOWN <span class="hljs-keyword">in</span> Protocol is 2Interface                        <span class="hljs-built_in"> IP </span>Address/Mask      Physical   Protocol  MEth0/0/1                         unassigned           down       down      NULL0                             unassigned           up         up(s)     Vlanif1                           unassigned           up         down      Vlanif10                          192.168.10.1/24      up         up        Vlanif20                          192.168.20.1/24      up         up<span class="hljs-comment">#显示路由表</span>[Huawei]dis<span class="hljs-built_in"> ip </span>routing-table Route Flags: R - relay, D - download <span class="hljs-keyword">to</span> fib------------------------------------------------------------------------------Routing Tables: Public         Destinations : 6        Routes : 6        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0   192.168.10.0/24  Direct  0    0           D   192.168.10.1    Vlanif10   192.168.10.1/32  Direct  0    0           D   127.0.0.1       Vlanif10   192.168.20.0/24  Direct  0    0           D   192.168.20.1    Vlanif20   192.168.20.1/32  Direct  0    0           D   127.0.0.1       Vlanif20</code></pre><p>注：</p><p>VLAN 间路由：通过三层设备路由，使得不同 VLAN 间可以互相通信，但是仅仅允许单播通信。不同 VLAN 之间广播帧依然被隔离既没有失去 VLAN 原本的意义。</p><h3 id="4-3-2-路由器–单臂路由"><a href="#4-3-2-路由器–单臂路由" class="headerlink" title="4.3.2 路由器–单臂路由"></a>4.3.2 路由器–单臂路由</h3><p><img src="/img/Huawei_route/Huawei_route_base_30.jpg"></p><h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><pre><code class="hljs routeros">[Router]int e0/0/0.?#可生成的逻辑接口  &lt;1-4096&gt;   [Router]int e0/0/0.10[Router-Ethernet0/0/0.10]ip<span class="hljs-built_in"> address </span>192.168.10.254 24#为逻辑接口 10 配置10网段的网关[Router-Ethernet0/0/0.10]dot1q termination vid 10#绑定<span class="hljs-built_in"> VLAN </span>10[Router-Ethernet0/0/0.10]arp broadcast <span class="hljs-builtin-name">enable</span> #使子接口有ARP广播功能[Router-Ethernet0/0/0.10]dis this<span class="hljs-comment">#</span>interface Ethernet0/0/0.10 dot1q termination vid 10<span class="hljs-built_in"> ip address </span>192.168.10.254 255.255.255.0 arp broadcast enable<span class="hljs-comment">#</span>return[Router]int e0/0/0.20[Router-Ethernet0/0/0.20]ip<span class="hljs-built_in"> address </span>192.168.20.254 24[Router-Ethernet0/0/0.20]dot1q termination vid 20[Router-Ethernet0/0/0.20]arp broadcast <span class="hljs-builtin-name">enable</span> [Router-Ethernet0/0/0.20]dis this<span class="hljs-comment">#</span>interface Ethernet0/0/0.20 dot1q termination vid 20<span class="hljs-built_in"> ip address </span>192.168.20.254 255.255.255.0 arp broadcast enable<span class="hljs-comment">#</span>return[Router]dis<span class="hljs-built_in"> ip </span>routing-tableRoute Flags: R - relay, D - download <span class="hljs-keyword">to</span> fib------------------------------------------------------------------------------Routing Tables: Public         Destinations : 8        Routes : 8        Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0   192.168.10.0/24  Direct  0    0           D   192.168.10.254  Ethernet0/0/0.10   192.168.10.2/32  Direct  0    0           D   192.168.10.2    Ethernet0/0/0.10 192.168.10.254/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0.10   192.168.20.0/24  Direct  0    0           D   192.168.20.254  Ethernet0/0/0.20   192.168.20.2/32  Direct  0    0           D   192.168.20.2    Ethernet0/0/0.20 192.168.20.254/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0.20</code></pre><h2 id="4-4-ACL（Access-Control-List）"><a href="#4-4-ACL（Access-Control-List）" class="headerlink" title="4.4 ACL（Access Control List）"></a>4.4 ACL（Access Control List）</h2><blockquote><p>访问控制列表</p></blockquote><ul><li>基本ACL（2000-2999）：只能匹配源 IP 地址</li><li>高级ACL（3000-3999）：可以匹配源IP、目标IP、源端口、目标端口等三层和四层的字段</li></ul><h3 id="4-4-1-配置"><a href="#4-4-1-配置" class="headerlink" title="4.4.1 配置"></a>4.4.1 配置</h3><p><img src="/img/Huawei_route/Huawei_route_base_31.jpg"></p><p><strong>例1：</strong></p><p>禁止 Client 1 192.168.10.1 访问172.16.10.0 网段：</p><p>配置 R2 路由：</p><pre><code class="hljs routeros"><span class="hljs-comment">#配置 ACL 规则</span>[R2]acl ?  INTEGER&lt;2000-2999&gt;  Basic access-list(<span class="hljs-builtin-name">add</span> <span class="hljs-keyword">to</span> current using rules)#基本 ACL  INTEGER&lt;3000-3999&gt;  Advanced access-list(<span class="hljs-builtin-name">add</span> <span class="hljs-keyword">to</span> current using rules)#高级 ACL  INTEGER&lt;4000-4999&gt;  Specify a L2 acl group <span class="hljs-built_in"> ipv6 </span>               ACL<span class="hljs-built_in"> IPv6 </span>  name                Specify a named ACL  number              Specify a numbered ACL[R2-acl-basic-2000]rule ?  INTEGER&lt;0-4294967294&gt;  ID of ACL rule  deny                   Specify matched packet deny#拒绝  permit                 Specify matched packet permit#允许[R2-acl-basic-2000]rule deny source 192.168.10.1 ?  IP_ADDR&lt;X.X.X.X&gt;  Wildcard of source  0                 Wildcard bits : 0.0.0.0 ( a host )[R2-acl-basic-2000]rule deny source 192.168.10.1 0#拒绝源地址为192.168.10.1的任何数据包，0代表主机，不代表某个网段[R2-acl-basic-2000]dis this[V200R003C00]<span class="hljs-comment">#</span>acl number 2000   rule 5 deny source 192.168.10.1 0 # 5 为自动生成的执行编号，第二条则为10（每条+5）<span class="hljs-comment">#</span>return<span class="hljs-comment">#在接口的入方向调用 ACL 规则</span>[R2]int gi0/0/0[R2-GigabitEthernet0/0/0]traffic-filter inbound acl 2000 #在 R2 接口的入（inbound）方向调用 acl[R2-GigabitEthernet0/0/0]dis this[V200R003C00]<span class="hljs-comment">#</span>interface GigabitEthernet0/0/0<span class="hljs-built_in"> ip address </span>12.1.1.2 255.255.255.0  traffic-filter inbound acl 2000<span class="hljs-comment">#</span>return</code></pre><p><strong>例2：</strong></p><p><img src="/img/Huawei_route/Huawei_route_base_31.jpg"></p><p>在 R2 上配置<em>高级 ACL</em> 拒绝 Client 1 和 PC2 ping Server1（拒绝 ICMP 协议数据包），但是允许其 HTTP 访问 Server 1。</p><pre><code class="hljs angelscript">#配置 ACL 规则[R2]acl <span class="hljs-number">3000</span>[R2-acl-adv<span class="hljs-number">-3000</span>]rule deny icmp source <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span> destination <span class="hljs-number">172.16</span><span class="hljs-number">.10</span><span class="hljs-number">.2</span> <span class="hljs-number">0</span>#拒绝 <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span> 网段 ping（ICMP） Server <span class="hljs-number">1</span>(<span class="hljs-number">172.16</span><span class="hljs-number">.10</span><span class="hljs-number">.2</span> <span class="hljs-number">0</span>代表本机)[R2-acl-adv<span class="hljs-number">-3000</span>]dis <span class="hljs-keyword">this</span>[V200R003C00]#acl number <span class="hljs-number">3000</span>   rule <span class="hljs-number">5</span> deny icmp source <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span> destination <span class="hljs-number">172.16</span><span class="hljs-number">.10</span><span class="hljs-number">.2</span> <span class="hljs-number">0</span> #<span class="hljs-keyword">return</span>#接口入调用 ACL 规则[R2]<span class="hljs-built_in">int</span> gi0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>[R2-GigabitEthernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>]traffic-filter inbound acl <span class="hljs-number">3000</span></code></pre><p><strong>例3：</strong></p><p><img src="/img/Huawei_route/Huawei_route_base_31.jpg"></p><p>拒绝源地址 192.168.10.2 telnet（port 23） 访问12.1.1.2</p><pre><code class="hljs angelscript">#配置 ACL 规则[R2]acl <span class="hljs-number">3001</span>[R2-acl-adv<span class="hljs-number">-3001</span>]rule deny tcp source <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.2</span> <span class="hljs-number">0</span> destination <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> <span class="hljs-number">0</span> destination-port eq <span class="hljs-number">23</span>[R2-acl-adv<span class="hljs-number">-3001</span>]dis <span class="hljs-keyword">this</span>[V200R003C00]#acl number <span class="hljs-number">3001</span>   rule <span class="hljs-number">5</span> deny tcp source <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.2</span> <span class="hljs-number">0</span> destination <span class="hljs-number">12.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> <span class="hljs-number">0</span> destination-port eq telnet #<span class="hljs-keyword">return</span>#接口入调用 ACL 规则[R2]<span class="hljs-built_in">int</span> gi0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>[R2-GigabitEthernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>]traffic-filter inbound acl <span class="hljs-number">3001</span></code></pre><p><font color=red><strong>注：</strong></font></p><ol><li><strong>一个接口的同一个方向，只能调用一个 ACL</strong></li><li><strong>一个 ACL 里面可以有多个 rule 规则，从上往下依次执行</strong></li><li><strong>数据包一旦被某 rule 匹配，就不再继续向下匹配</strong></li><li><strong>默认隐含放过所有（华为的 ACL 用来拒绝数据包时）</strong></li></ol><h1 id="五、NAT（Network-Address-Translation）"><a href="#五、NAT（Network-Address-Translation）" class="headerlink" title="五、NAT（Network Address Translation）"></a>五、NAT（Network Address Translation）</h1><blockquote><p>网络地址转换主要用于实现位于内部网络的主机访问外部网络的功能。当局域网内的主机需要访问外部网络时，通过 NAT 技术可以将其私网地址转换为公网地址，并且多个私网地址可以共用一个公网地址，这样既能保证网络互通，有节省公网地址。</p></blockquote><ul><li>NAT 一般部署在连接内网和外网的网关设备上</li></ul><p><strong>私有地址：任何人都能使用</strong></p><p>A 10.0.0.0/8</p><p>B 172.16.0.0-172.31.255.255</p><p>C 192.168.0.0/16</p><h2 id="5-1-Static-NAT-配置"><a href="#5-1-Static-NAT-配置" class="headerlink" title="5.1 Static NAT 配置"></a>5.1 Static NAT 配置</h2><blockquote><p>一对一（一一映射），一个私网地址对应一个公网地址，外网的用户可以访问内网的主机</p></blockquote><p><img src="/img/Huawei_route/Huawei_route_base_32.jpg"></p><p>基础配置：</p><ol><li>配置好 IP 地址</li><li>出口配置缺省路由<code>[OUT]ip route-static 0.0.0.0 0 12.1.1.6</code></li><li>在企业路由WAN端口（GE 0/0/1）配置 Static NAT</li></ol><pre><code class="hljs routeros">[OUT]int gi 0/0/1[OUT-GigabitEthernet0/0/1]nat static ?  <span class="hljs-builtin-name">enable</span>    <span class="hljs-builtin-name">Enable</span> function  global    Specify global information of<span class="hljs-built_in"> NAT</span>#全局公网地址  protocol  Specify protocol[OUT-GigabitEthernet0/0/1]nat static global 12.1.1.2 ?  inside  Specify inside information of<span class="hljs-built_in"> NAT </span> #内部网络[OUT-GigabitEthernet0/0/1]nat static global 12.1.1.2 inside 192.168.1.2 #将私网地址 1.2 和 12.1.1.2 做一对一映射[OUT-GigabitEthernet0/0/1]dis this[V200R003C00]<span class="hljs-comment">#</span>interface GigabitEthernet0/0/1 description TO_wan<span class="hljs-built_in"> ip address </span>12.1.1.1 255.255.255.248 <span class="hljs-built_in"> nat </span>static global 12.1.1.2 inside 192.168.1.2 netmask 255.255.255.255<span class="hljs-comment">#</span>return</code></pre><p>用内网 PC 192.168.1.2 Ping 百度（9.9.9.9），从企业路由WAN端口（GE 0/0/1）出抓包：</p><p><img src="/img/Huawei_route/Huawei_route_base_33.jpg"></p><p>发现此时内网地址 192.168.1.2 已经被转换为 12.1.1.2 </p><p>调试：查看 NAT 转换过程：</p><pre><code class="hljs routeros">[OUT]dis<span class="hljs-built_in"> nat </span>session protocol icmp <span class="hljs-built_in"> NAT </span>Session Table Information:     Protocol          : ICMP(1)     SrcAddr   Vpn     : 192.168.1.2                                         DestAddr  Vpn     : 9.9.9.9                                            <span class="hljs-built_in"> Type </span>Code IcmpId  : 0   8   49311     NAT-Info       New SrcAddr     : 12.1.1.2              New DestAddr    : ----       New IcmpId      : ----</code></pre><h2 id="5-2-NAPT-Network-Address-Port-Translation"><a href="#5-2-NAPT-Network-Address-Port-Translation" class="headerlink" title="5.2 NAPT (Network Address Port Translation)"></a>5.2 NAPT (Network Address Port Translation)</h2><p>由于NAT实现是私有IP和NAT的公共IP之间的转换，那么，私有网中同时与公共网进行通信的主机数量就受到NAT的公共IP地址数量的限制。为了克服 这种限制，NAT被进一步扩展到在进行IP地址转换的同时进行Port的转换，这就是网络地址端口转换NAPT（Network Address Port Translation）技术。<br>    NAPT与NAT的区别在于，NAPT不仅转换IP包中的IP地址，还对IP包中TCP和UDP的Port进行转换。这使得多台私有网主机利用1个NAT公共IP就可以同时和公共网进行通信。（NAPT多了对TCP和UDP的端口号的转换）</p><pre><code>私有网主机192.168.1.2要访问公共网中的 Http服务器166.111.80.200。首先，要建立TCP连接，假设分配的TCP Port是1010，发送了1个IP包（Des=166.111.80.200:80,Src=192.168.1.2:1010）,当IP包经过NAT 网关时，NAT会将IP包的源IP转换为NAT的公共IP，同时将源Port转换为NAT动态分配的1个Port。然后，转发到公共网，此时IP包 （Des=166.111.80.200：80，Src=202.204.65.2:2010）已经不含任何私有网IP和Port的信息。由于IP包的源 IP和Port已经被转换成NAT的公共IP和Port，响应的IP包 （Des=202.204.65.2:,Src=2010166.111.80.200:80）将被发送到NAT。这时NAT会将IP包的目的IP转换成 私有网主机的IP，同时将目的Port转换为私有网主机的Port，然后将IP包 （Des=192.168.1.2:1010，Src=166.111.80.200:80）转发到私网。对于通信双方而言，这种IP地址和Port的转 换是完全透明的。</code></pre><h2 id="5-3-NAT-–-Easy-IP"><a href="#5-3-NAT-–-Easy-IP" class="headerlink" title="5.3 NAT – Easy IP"></a>5.3 NAT – Easy IP</h2><p>Easy IP 方式的实现原理与上节介绍的地址池NAPT 转换原理类似，可以算是NAPT的一种特例，不同的是Easy IP 方式可以实现自动根据路由器上WAN 接口的公网IP 地址实现与私网IP 地址之间的映射（无需创建公网地址池）。<br>Easy IP 主要应用于将路由器WAN 接口IP 地址作为要被映射的公网IP 地址的情形，特别适合小型局域网接入Internet 的情况。这里的小型局域网主要指中小型网吧、小型办公室等环境，一般具有以下特点：内部主机较少、出接口通过拨号方式获得临时（或固定）公网IP 地址以供内部主机访问Internet。图6-3 所示为Easy IP 方式的实现原理，具体过程如下。<br><img src="/img/Huawei_route/Huawei_route_base_57.jpg"><br>① 假设私网中的Host A 主机要访问公网的Server，首先要向Router 发送一个请求报文（即Outbound 方向），此时报文中的源地址是10.1.1.100，端口号1540。<br>② Router 在收到请求报文后自动利用公网侧WAN 接口临时或者固定的“公网IP地址:端口号”（162.10.2.8:5480），建立与内网侧报文“源IP 地址:源端口号”间的Easy IP转换表项（也包括正、反两个方向），并依据正向Easy IP 表项的查找结果将报文转换后向公网侧发送。此时，转换后的报文源地址和源端口号由原来的（10.1.1.100:1540）转换成了（162.10.2.8:5480）。<br>③ Server 在收到请求报文后需要向Router 发送响应报文（即Inbound 方向），此时只须将收到的请求报文中的源IP 地址、源端口号和目的IP 地址、目的端口号对调即可，即此时的响应报文中的目的IP 地址、目的端口号为162.10.2.8:5480。<br>④ Router 在收到公网侧Server 的回应报文后，根据其“目的IP 地址:目的端口号”查找反向Easy IP 表项，并依据查找结果将报文转换后向内网侧发送。即转换后的报文中的目的IP 地址为10.1.1.100，目的端口号为1540，与Host A 发送请求报文中的源IP地址和源端口完全一样。<br>如果私网中的Host B 也要访问公网，则它所利用的公网IP 地址与Host A 一样，都是路由器WAN 口的公网IP 地址，但转换时所用的端口号一定要与Host A 转换时所用的端口不一样。</p><blockquote><p>允许多个私网地址转换成一个公网 IP ，常用</p></blockquote><p><img src="/img/Huawei_route/Huawei_route_base_32.jpg"></p><p>基础配置：</p><ol><li><p>首先配置 ACL 匹配内网私网地址段</p><pre><code class="hljs angelscript">[OUT]acl <span class="hljs-number">2000</span>[OUT-acl-basic<span class="hljs-number">-2000</span>]rule permit source <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span>[OUT-acl-basic<span class="hljs-number">-2000</span>]dis <span class="hljs-keyword">this</span>[V200R003C00]#acl number <span class="hljs-number">2000</span>   rule <span class="hljs-number">5</span> permit source <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span> #<span class="hljs-keyword">return</span>[OUT-acl-basic<span class="hljs-number">-2000</span>]</code></pre></li></ol><p><font color=red>注：ACL 用来做匹配范围时，没有默认隐含允许所有的规则</font></p><ol start="2"><li><pre><code>[OUT-GigabitEthernet0/0/1]nat ?  outbound  Specify net address translation        #Easy IP，配置 NAT 地址池的转换策略，可以选择匹配ACL模式或不匹配ACL两种模式  server    Specify NAT server            #可以将某服务器的某端口映射出去（安全）  static    Specify static NAT            #静态 NAT，一对一 [OUT-GigabitEthernet0/0/1]nat outbound ?  INTEGER&lt;2000-3999&gt;  Apply basic or advanced ACL        #配置的 ACL 编号[OUT-GigabitEthernet0/0/1]nat outbound 2000 <pre><code class="hljs routeros">   原理：内网私网地址出包时转换成公网接口 WAN（GE 0/0/1）当前的<span class="hljs-built_in"> IP </span>地址<span class="hljs-comment">### 5.3.1 NAT -- Server</span>&gt; 可以将某服务器的某端口映射出去（安全）配置：![](/img/Huawei_route/Huawei_route_base_34.jpg)</code></pre>[OUT-GigabitEthernet0/0/1]nat server protocol tcp global 12.1.1.3 www inside 192.168.1.254 www         #将服务器的80端口映射成公网地址的80端口[OUT-GigabitEthernet0/0/1]dis this[V200R003C00]#interface GigabitEthernet0/0/1description TO_wanip address 12.1.1.1 255.255.255.248 nat server protocol tcp global 12.1.1.3 www inside 192.168.1.254 www#return<pre><code class="hljs http"># 六、广域网封装协议&gt; 广域网中经常会使用串行链路来提供远距离的数据传输，高级数据链路控制 HDLC （  High-Level Data Link Control  ）和点对点协议 PPP （  Point to Point Protocol ）是两种典型的串口封装协议。 ## 6.1 PPP（  Point to Point Protocol ）&gt; PPP （点对点协议）协议是一种点到点链路层协议，主要用于在全双工的同异步链路上进行点到点的数据传输### 6.1.1 PPP 配置![](/img/Huawei_route/Huawei_route_base_35.jpg)</code></pre>[R1]int Serial 4/0/0[R1-Serial4/0/0]ip add 12.1.1.1 24[R1-Serial4/0/0]dis this[V200R003C00]#interface Serial4/0/0link-protocol pppip address 12.1.1.1 255.255.255.0 #return[R1]ping 12.1.1.2PING 12.1.1.2: 56  data bytes, press CTRL_C to break Reply from 12.1.1.2: bytes=56 Sequence=1 ttl=255 time=20 ms Reply from 12.1.1.2: bytes=56 Sequence=2 ttl=255 time=30 ms</code></pre></li></ol><pre><code class="hljs awk">抓包，PPP的封装方式：![](<span class="hljs-regexp">/img/</span>Huawei_route/Huawei_route_base_36.jpg) &lt;font color=red&gt;注：PPP 可以对链路做认证&lt;/font&gt;：PAP 认证、CHAP 认证<span class="hljs-comment">#### PAP认证配置（密码明文传输，两次握手）</span>![](<span class="hljs-regexp">/img/</span>Huawei_route/Huawei_route_base_37.jpg)</code></pre><p>#认证端（服务端）<br>[R2]aaa<br>[R2-aaa]local-user HCNP password cipher hcnp123        #创建本地用户名和密码<br>Info: Add a new user.<br>[R2-aaa]local-user hcnp service-type ppp            #创建的账户用作 ppp 认证<br>[R2]int Serial 4/0/0<br>[R2-Serial4/0/0]ppp authentication-mode pap            #进入接口开启认证</p><p>#被认证端（客户端）<br>[R1]int Serial 4/0/0<br>[R1-Serial4/0/0]ppp pap local-user HCNP password ?<br>  cipher  Display the current password with cipher text<br>  simple  Display the current password with plain text<br>[R1-Serial4/0/0]ppp pap local-user HCNP password simple hcnp123 #发送 pap 用户名密码认证</p><pre><code class="hljs http">#### CHAP 认证配置（三次握手，加密传输）![](/img/Huawei_route/Huawei_route_base_37.jpg)</code></pre><p>#认证端（服务端）<br>[R2-Serial4/0/0]ppp authentication-mode chap<br>[R2-Serial4/0/0]dis this<br>[V200R003C00]<br>#<br>interface Serial4/0/0<br> link-protocol ppp<br> ppp authentication-mode chap<br> ip address 12.1.1.2 255.255.255.0<br>#<br>return</p><p>#被认证端（客户端）<br>[R1-Serial4/0/0]ppp chap user HCNP<br>[R1-Serial4/0/0]ppp chap password simple hcnp123</p><pre><code class="hljs http">## 6.2 HDLC（High-Level Data Link Control ）&gt; HDLC（高级数据链路控制） 是高级数据链路控制协议，是一种数据链路层的协议。HDLC 是一个 ISO 标准的面向位的数据链路协议，其在同步串行数据链路上封装数据，最常用于点对点链接### 6.2.1 HDLC 配置![](/img/Huawei_route/Huawei_route_base_35.jpg)</code></pre><p>[R1]int s4/0/0<br>[R1-Serial4/0/0]dis this<br>[V200R003C00]<br>#<br>interface Serial4/0/0<br> link-protocol ppp                    #华为、H3C 串口默认封装方式为 PPP，思科为 HDLC<br> ip address 12.1.1.1 255.255.255.0<br>#<br>return<br>[R1-Serial4/0/0]link-protocol ?<br>  fr    Select FR as line protocol<br>  hdlc  Enable HDLC protocol<br>  lapb  LAPB(X.25 level 2 protocol)<br>  ppp   Point-to-Point protocol<br>  sdlc  SDLC(Synchronous Data Line Control) protocol<br>  x25   X.25 protocol<br>[R1-Serial4/0/0]link-protocol hdlc         #手动修改成 HDLC<br>Warning: The encapsulation protocol of the link will be changed. Continue? [Y/N]<br>:y<br>[R1-Serial4/0/0]dis this<br>[V200R003C00]<br>#<br>interface Serial4/0/0<br> link-protocol hdlc<br> ip address 12.1.1.1 255.255.255.0<br>#<br>return</p><pre><code class="hljs awk">&lt;font color=red&gt;注：两个相连端口封装方式需要一致，不然无法通信，所以路由 R2 需要做相同配置。&lt;/font&gt;通信抓包：![](<span class="hljs-regexp">/img/</span>Huawei_route/Huawei_route_base_35.jpg)<span class="hljs-comment">## 6.3 FR（Frame-relay）</span>&gt; 帧中继<span class="hljs-comment">### 6.3.1 FR 配置</span>![](<span class="hljs-regexp">/img/</span>Huawei_route/Huawei_route_base_39.jpg)</code></pre><p>[R1-Serial4/0/0]dis this<br>[V200R003C00]<br>#<br>interface Serial4/0/0<br> link-protocol fr<br> ip address 12.1.1.1 255.255.255.0<br>#<br>return</p><p>#查看映射<br>[R1]dis fr map-info<br>Map Statistics for interface Serial4/0/0 (DTE)<br>  DLCI = 102, IP INARP 12.1.1.2, Serial4/0/0<br>    create time = 2020/08/07 09:25:46, status = ACTIVE<br>    encapsulation = ietf, vlink = 2, broadcast</p><pre><code class="hljs shell">抓包：![](/img/Huawei_route_base_40.jpg)<span class="hljs-meta">#</span><span class="bash"> 七、链路聚合</span><span class="hljs-meta">&gt;</span><span class="bash">链路捆绑、端口聚合、eth-channel</span><span class="hljs-meta">&gt;</span><span class="hljs-meta">&gt;</span><span class="bash">随着网络规模不断扩大，用户对骨干链路的带宽和可靠性提出了越来越高的要求。在传统技术中，常用更换高速率的接口板或更换支持高速率接口板的设备的方式来增加带宽，但这种方案需要付出高额的费用，而且不够灵活。</span><span class="hljs-meta">&gt;</span><span class="bash">采用链路聚合技术可以在不进行硬件升级的条件下，通过将多个物理接口捆绑为一个逻辑接口，来达到增加链路带宽的目的。在实现增大带宽目的的同时，链路聚合采用备份链路的机制，可以有效的提高设备之间链路的可靠性。</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 配置</span></span>![](/img/Huawei_route_base_41.jpg)</code></pre><p>#现状态<br>[SW1]dis stp brief<br> MSTID  Port                        Role  STP State     Protection<br>   0    GigabitEthernet0/0/1        ROOT  FORWARDING      NONE        #FORWARDING：转发<br>   0    GigabitEthernet0/0/2        ALTE  DISCARDING      NONE        #DISCARDING：丢弃<br>   0    GigabitEthernet0/0/3        ALTE  DISCARDING      NONE<br>   0    GigabitEthernet0/0/4        DESI  FORWARDING      NONE</p><p>#配置链路聚合<br>[SW1]int Eth-Trunk 1                #创建逻辑捆绑接口组 1<br>[SW1-GigabitEthernet0/0/1]eth-trunk 1    #进入接口，将接口加入 Eth-Trunk 1<br>[SW1-GigabitEthernet0/0/2]eth-trunk 1<br>[SW1-GigabitEthernet0/0/3]eth-trunk 1<br>#查看配置<br>[SW1]dis eth-trunk<br>Eth-Trunk1’s state information is:<br>WorkingMode: NORMAL         Hash arithmetic: According to SIP-XOR-DIP<br>Least Active-linknumber: 1  Max Bandwidth-affected-linknumber: 8  #最多能捆绑8个链路<br>Operate status: up         Number Of Up Port In Trunk: 3                     </p><hr><p>PortName                      Status      Weight<br>GigabitEthernet0/0/1          Up          1<br>GigabitEthernet0/0/2          Up          1<br>GigabitEthernet0/0/3          Up          1   </p><p>[SW1]dis stp brief<br> MSTID  Port                        Role  STP State     Protection<br>   0    GigabitEthernet0/0/4        DESI  FORWARDING      NONE<br>   0    Eth-Trunk1                  ROOT  FORWARDING      NONE<br>#交换机 R2 同样配置</p><pre><code class="hljs http"># 八、VRRP&gt; Virtual Router Redundancy [rɪˈdʌndənsi] Protocol，**虚拟网关冗余协议**&gt;&gt; 三层网关冗余技术，对用户的网关做冗余## 8.1 配置![](/img/Huawei_route/Huawei_route_base_42.jpg)#### 基础配置- 核心的 IP 地址- 接入层交换机无需配置- 用户网关配置成 192.168.10.1#### VRRP 配置</code></pre><p>#核心1<br>[core1]int gi 0/0/0            #下联用户接口配置<br>[core1-GigabitEthernet0/0/0]vrrp ?<br>  arp       Gratuitous arp<br>  un-check  Uncheck VRRP packet TTL value<br>  vrid      Specify virtual router identifier<br>[core1-GigabitEthernet0/0/0]vrrp vrid ?            #指定虚拟路由器标识符（Specify virtual router identifier）<br>  INTEGER&lt;1-255&gt;  Virtual router identifier<br>[core1-GigabitEthernet0/0/0]vrrp vrid 1 ?<br>  authentication-mode  Specify password and authentication mode<br>  preempt-mode         Specify preempt mode<br>  priority             Specify priority<br>  timer                Specify timer<br>  track                Specify the track configuration<br>  version-3            Specify the device to support V3 for VRRP<br>  virtual-ip           Specify virtual IP address<br>#创建虚拟组1，并指定虚拟 IP 地址，该虚拟地址作为用户网关<br>[core1-GigabitEthernet0/0/0]vrrp vrid 1 virtual-ip 192.168.10.1<br>[core1-GigabitEthernet0/0/0]dis this<br>[V200R003C00]<br>#<br>interface GigabitEthernet0/0/0<br> ip address 192.168.10.253 255.255.255.0<br> vrrp vrid 1 virtual-ip 192.168.10.1<br>#<br>return<br>#核心2同样配置<br>[core2-GigabitEthernet0/0/0]vrrp vrid 1 priority 105    #将优先级改为105作为主路由器，优先级默认是100。数字越大越优先<br>[core2-GigabitEthernet0/0/0]dis this<br>[V200R003C00]<br>#<br>interface GigabitEthernet0/0/0<br> ip address 192.168.10.254 255.255.255.0<br> vrrp vrid 1 virtual-ip 192.168.10.1<br> vrrp vrid 1 priority 105<br>#<br>return<br>#查看 VRRP 状态<br>[core1]dis vrrp brief<br>Total:1     Master:0     Backup:1     Non-active:0<br>VRID  State        Interface                Type     Virtual IP     </p><hr><p>1     Backup       GE0/0/0                  Normal   192.168.10.1 </p><p>[core2]dis vrrp brief<br>Total:1     Master:1     Backup:0     Non-active:0<br>VRID  State        Interface                Type     Virtual IP     </p><hr><p>1     Master       GE0/0/0                  Normal   192.168.10.1 、</p><p>#查看 VRRP 详细信息<br>[core2]dis vrrp<br>  GigabitEthernet0/0/0 | Virtual Router 1<br>    State : Master<br>    Virtual IP : 192.168.10.1<br>    Master IP : 192.168.10.254<br>    PriorityRun : 105<br>    PriorityConfig : 105<br>    MasterPriority : 105<br>    Preempt : YES   Delay Time : 0 s<br>    TimerRun : 1 s<br>    TimerConfig : 1 s<br>    Auth type : NONE                #认证信息<br>    Virtual MAC : 0000-5e00-0101<br>    Check TTL : YES<br>    Config type : normal-vrrp<br>    Backup-forward : disabled<br>    Create time : 2020-08-10 12:19:35 UTC-08:00<br>    Last change time : 2020-08-10 12:24:04 UTC-08:00</p><p>#配置如上联接口断开，降低 master 优先级<br>##配置跟踪上联接口 GE 0/0/1 状态，当发现 GE 0/0/1 口 down 时，将自动降低此路由的优先级-10，以让出 master 的位置<br>[core2-GigabitEthernet0/0/0]vrrp vrid 1 track interface  GigabitEthernet 0/0/1<br>[core2-GigabitEthernet0/0/0]dis this<br>[V200R003C00]<br>#<br>interface GigabitEthernet0/0/0<br> ip address 192.168.10.254 255.255.255.0<br> vrrp vrid 1 virtual-ip 192.168.10.1<br> vrrp vrid 1 priority 105<br> vrrp vrid 1 track（跟踪） interface GigabitEthernet0/0/1<br>#<br>return<br>[core2]dis vrrp<br>  GigabitEthernet0/0/0 | Virtual Router 1<br>    State : Backup<br>    Virtual IP : 192.168.10.1<br>    Master IP : 192.168.10.253<br>    PriorityRun : 95        &lt;—降低后的优先级<br>    PriorityConfig : 105<br>    MasterPriority : 100<br>    Preempt : YES   Delay Time : 0 s<br>    TimerRun : 1 s<br>    TimerConfig : 1 s<br>    Auth type : NONE<br>    Virtual MAC : 0000-5e00-0101<br>    Check TTL : YES<br>    Config type : normal-vrrp<br>    Backup-forward : disabled<br>    Track IF : GigabitEthernet0/0/1   Priority reduced : 10    &lt;—降低优先级10<br>    IF state : DOWN        &lt;—上联端口断开<br>    Create time : 2020-08-10 12:19:35 UTC-08:00<br>    Last change time : 2020-08-10 13:17:30 UTC-08:00</p><p>#开启简单的密码认证，两个核心都需要配置（可选配置）<br>[core2-GigabitEthernet0/0/0]vrrp vrid 1 authentication-mode simple plain 123  #配置简单明文密码123</p><pre><code class="hljs routeros"><span class="hljs-comment">#### 工作原理</span>抓取核心1 GE 0/0/0 口报文![](/img/Huawei_route/Huawei_route_base_43.jpg)核心路由器会每隔一段时间（约1S）发送一个特定的<span class="hljs-built_in"> VRRP </span>报文。如果一段时间没有收到对方发来的<span class="hljs-built_in"> VRRP </span>报文，就认定对方 master 设备出现故障。此时 backup 会总动切换成 master<span class="hljs-comment"># 九、STP （Spanning Tree Protocol）</span>&gt;为了提高网络可靠性，交换网络中通常会使用冗余链路。然而，冗余链路会给交换网络带来环路风险，并导致广播风暴以及 MAC 地址表不稳定等问题，进而会影响到用户的通信质量。生成树协议 STP 可以在提高可靠性的同时又能避免环路带来的各种问题。&lt;font <span class="hljs-attribute">color</span>=red&gt;**作用：防止交换环路**&lt;/font&gt;![](/img/Huawei_route/Huawei_route_base_44.jpg)华为交换机默认开机启动 STP<span class="hljs-comment">## 9.1 实验</span>将交换机 STP 关闭，抓包：![](/img/Huawei_route/Huawei_route_base_44.jpg)</code></pre><p>[SW1]stp disable </p><pre><code class="hljs clean">PC ping ip <span class="hljs-number">1.1</span><span class="hljs-number">.1</span><span class="hljs-number">.255</span> ，为广播地址，其目标 MAC 地址为 ff:ff:ff:ff:ff:ff（交换机靠 MAC 转发）![](/img/Huawei_route/Huawei_route_base_45.jpg)### <span class="hljs-number">9.1</span><span class="hljs-number">.1</span> 引发各种问题#### 广播风暴![](/img/Huawei_route/Huawei_route_base_46.jpg)#### MAC 地址表震荡![](/imgHuawei_route<span class="hljs-comment">//Huawei_route_base_47.jpg)</span>## <span class="hljs-number">9.2</span> 工作原理STP通过阻塞端口来消除环路，并能够实现链路备份的目的。查看阻塞端口：</code></pre><p>[SW1]dis stp brief<br> MSTID  Port                        Role  STP State     Protection<br>   0    GigabitEthernet0/0/1        DESI  DISCARDING      NONE<br>   0    GigabitEthernet0/0/2        DESI  DISCARDING      NONE<br>   0    GigabitEthernet0/0/3        ROOT  FORWARDING      NONE</p><pre><code class="hljs angelscript">## <span class="hljs-number">9.3</span> STP 算法先选出不被阻塞的接口，剩下的接口都会被阻塞。### <span class="hljs-number">9.3</span><span class="hljs-number">.1</span> 过程<span class="hljs-number">1.</span> 整个网络（广播域）先选出根桥（根交换机），先比较优先级（默认<span class="hljs-number">32768</span>），再比较 MAC 地址，越小越优先。根桥上面的端口都是**指定端口**![](/img/Huawei_route/Huawei_route_base_48.jpg)显示：</code></pre><p><SW1>dis stp<br>——-[CIST Global Info][Mode MSTP]——-<br>CIST Bridge         :32768.4c1f-cc6b-2dc9     #桥ID（优先级+MAC）<br>Config Times        :Hello 2s MaxAge 20s FwDly 15s MaxHop 20<br>Active Times        :Hello 2s MaxAge 20s FwDly 15s MaxHop 20<br>CIST Root/ERPC      :32768.4c1f-cc5f-2395 / 20000   #显示根桥信息<br>CIST RegRoot/IRPC   :32768.4c1f-cc6b-2dc9 / 0<br>CIST RootPortId     :128.3<br>BPDU-Protection     :Disabled<br>TC or TCN received  :5<br>TC count per hello  :0<br>STP Converge Mode   :Normal<br>Time since last TC  :0 days 0h:17m:53s<br>Number of TC        :6<br>Last TC occurred    :GigabitEthernet0/0/1<br>—-[Port1(GigabitEthernet0/0/1)][FORWARDING]—-<br> Port Protocol       :Enabled<br> Port Role           :Designated Port<br> Port Priority       :128<br> Port Cost(Dot1T )   :Config=auto / Active=20000<br> Designated Bridge/Port   :32768.4c1f-cc6b-2dc9 / 128.1<br> Port Edged          :Config=default / Active=disabled<br> Point-to-point      :Config=auto / Active=true<br> Transit Limit       :147 packets/hello-time<br> Protection Type     :None<br>  —- More —-</p><pre><code class="hljs">2. 非根桥上面选举根端口（根端口有且仅有一个）到达根桥最近的端口当选为根端口非根交换机在选举根端口时分别依据该端口的根路劲开销、对端BID（桥ID）、对端 PID 和本端 PID![](/img/Huawei_route_base_49.jpg)3. 每段链路必须选举一个指定端口（且只有一个），桥 ID （优先级+MAC）较小的交换机上面的端口当选为指定端口![](/img/Huawei_route_base_50.jpg)4. 剩下的端口全部被阻塞![](/img/Huawei_route_base_51.jpg)查看状态：</code></pre><p><SW2>dis stp brief<br> MSTID  Port                        Role  STP State     Protection<br>   0    GigabitEthernet0/0/1        ALTE  DISCARDING      NONE    #阻塞<br>   0    GigabitEthernet0/0/2        ROOT  FORWARDING      NONE</p><pre><code class="hljs">## 9.4 更改交换机的优先级</code></pre><p>[SW2]stp priority ?<br>  INTEGER&lt;0-61440&gt;  Bridge priority, in steps of 4096   #需要4096的倍数</p><p>[SW2]stp priority 0   #将优先级改为0<br>#或者直接设置为根桥<br>[SW2]stp root ?<br>  primary    Primary root switch    #设置为根桥<br>  secondary  Secondary root switch  #设备备份根桥</p><pre><code class="hljs elixir">![](<span class="hljs-regexp">/img/</span>Huawei_route/Huawei_route_base_51.jpg)----------------&gt;![](<span class="hljs-regexp">/img/</span>Huawei_route/Huawei_route_base_52.jpg)<span class="hljs-comment">## 9.5 BPDU 报文</span>BPDU 包含桥 ID、路径开销、端口 ID、计数器等参数![](<span class="hljs-regexp">/img/</span>Huawei_route/Huawei_route_base_53.jpg)<span class="hljs-comment">## 9.6 端口重启过程</span>down ---&gt; listening ---&gt; learning ---&gt; forwarding此过程大概 <span class="hljs-number">30</span>slistening：监听端口learning：检测该端口是否需要阻塞，如要阻塞，则阻塞端口，防止环路设置边缘端口：建议将接 PC 的接口配置为边缘端口（减少接口的收敛时间）</code></pre><p>[SW1-GigabitEthernet0/0/1]stp edged-port enable</p><pre><code class="hljs dts"><span class="hljs-meta">## 9.7 STP 根保护</span>一旦使能根保护功能的指定端口收到优先级更低的 BPUD 时，端口状态将进入 Discarding 状态，不再转发报文。经过一段时间（通常为两倍的 Forward Delay）,如果端口一直没有再收到优先级较高（数值低）的 BPUD，端口会自动恢复到正常的 Forwarding 状态。<span class="hljs-params">&lt;font color=red&gt;</span>注：该指令只能在指定端口配置才会生效<span class="hljs-params">&lt;/font&gt;</span>![](<span class="hljs-meta-keyword">/img/</span>Huawei_route/Huawei_route_base_54.jpg)在根桥上的两个端口设置根保护，在 SW1 上接个优先级为 <span class="hljs-number">0</span> 的交换机</code></pre><p>[SW2-GigabitEthernet0/0/1]stp root-protection<br>[SW2-GigabitEthernet0/0/2]stp root-protection<br>#接上优先级为0的交换机，发现根桥设置根保护的端口为阻塞状态<br>[SW2]dis stp brief<br> MSTID  Port                        Role  STP State     Protection<br>   0    GigabitEthernet0/0/1        DESI  DISCARDING      ROOT<br>   0    GigabitEthernet0/0/2        DESI  DISCARDING      ROOT</p><pre><code class="hljs dts"><span class="hljs-meta">## 9.8 STP BPDU 防护</span>作用：保护根桥（全局），开启 BPDU 保护后，如果从<span class="hljs-params">&lt;font color=red&gt;</span>边缘端口<span class="hljs-params">&lt;/font&gt;</span>收到 STP 报文，交换机会自动将该接口 shutdown，从而确保根桥不会被抢占，同时确保不会出现环路。![](<span class="hljs-meta-keyword">/img/</span>Huawei_route/Huawei_route_base_54.jpg)</code></pre><p>#首先在 SW1 上的 GE 0/0/1 口配置边缘接口<br>[SW1-GigabitEthernet0/0/1]stp edged-port enable<br>在交换机 SW1 上配置 STP BPUD 防护<br>[SW1]stp bpdu-protection<br>#30S 后自动 up ，自动恢复机制<br>[SW1]error-down auto-recovery cause bpdu-protection interval 30</p><pre><code class="hljs clean">## <span class="hljs-number">9.9</span> RSTPRapaid STP  快速的生成树协议，STP 升级版设置:</code></pre><p>[SW2]stp mode rstp    #将 STP 模式切换为 RSTP</p><pre><code class="hljs http"># 十、IPV6&gt;Internal protocol version 6ipv4 32bit 地址个数为 2^32ipv6 128bit 地址个数为 2^128ipv6 实例：**2001:0DB8:0000:0000:0000:0000:0346:8D58**ipv6 由8个字段组成，每个字段占16个 bit上面地址简写：2001:DB8:0:0:0:0:346:8D58 ---&gt; 2001:DB8::346:8D58## 10.1 特殊 ipv6 地址1. ::1 本地环回地址2. :: 相当于 ipv4 0.0.0.03. FF 开头 组播 v6 地址 例如：FF::5 类似于224.0.0.5## 10.2 ipv6 静态路由配置![](/img/Huawei_route/Huawei_route_base_56.jpg)</code></pre><p>[R1]ipv6      #全局使能 ipv6 功能<br>[R1-GigabitEthernet0/0/1]ipv6 enable<br>[R1-GigabitEthernet0/0/1]ipv6 address 12::1 ?<br>  INTEGER&lt;1-128&gt;  IPv6 prefix length &lt;1-128&gt;<br>  link-local      Use link-local address<br>[R1-GigabitEthernet0/0/1]ipv6 address 12::1 64  #设置 ipv6 地址和前缀长度64<br>#查看路由器接口信息<br>[R1]dis ipv6 int brief<br>*down: administratively down<br>(l): loopback<br>(s): spoofing<br>Interface                    Physical              Protocol<br>GigabitEthernet0/0/0         up                    up<br>[IPv6 Address] 2001::1<br>GigabitEthernet0/0/1         up                    up<br>[IPv6 Address] 12::1<br>#查看路由表<br>[R1]dis ipv6 routing-table<br>#配置静态路由<br>[R1]ipv6 route-static 2002:: 64 12::2<br>#在 R2 配置缺省路由<br>[R2]ipv6 route-static :: 0 12::1<br>#查看 R1 路由表<br>[R1]dis ipv6 routing-table<br>Routing Table : Public<br>    Destinations : 7    Routes : 7</p><p> Destination  : ::1                             PrefixLength : 128<br> NextHop      : ::1                             Preference   : 0<br> Cost         : 0                               Protocol     : Direct<br> RelayNextHop : ::                              TunnelID     : 0x0<br> Interface    : InLoopBack0                     Flags        : D</p><p> Destination  : 2002::                          PrefixLength : 64<br> NextHop      : 12::2                           Preference   : 60<br> Cost         : 0                               Protocol     : Static<br> RelayNextHop : ::                              TunnelID     : 0x0<br> Interface    : GigabitEthernet0/0/1            Flags        : RD</p><pre><code>ipv6 报文：![](/img/Huawei_route/Huawei_route_base_54.jpg)## 10.3 IPV6 地址分类#### 单播#### 组播#### 任意播（取消广播概念）ipv6 无状态自动配置：PC 会通过发送特定类型的 icmp 报文请求路由器接口前缀，结合自己的 MAC 地址自动生成全球独一无二的 ipv6 地址ipv6 中以 FE80:: 开头的地址都属于本地链路地址（Link-local），只有在本地链路有效。启用了 ipv6 功能的接口都会自动生成相应的 Link-local 地址。</code></pre>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HCNA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP UDP 的区别</title>
    <link href="/2020/07/24/tcp_udp/"/>
    <url>/2020/07/24/tcp_udp/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>可靠传输、面向连接：速度慢，但是准确性高 </p><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>客户端收到报文后，需要发送 TCP 的 ACK 确认包，并告诉服务端接下来要收到的报文的序号。同时该过程确定了两者传输的 “Windows 窗口”大小。</p><h2 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h2><p>如果某应用层协议的四层使用 TCP 端口，那么在正式的数据报文传输之前，需要先建立完连接后才可以传输数据。</p><p>建立连接：<font color=red>三次握手</font>—面向连接的高层协议在正式传输数据之前需要先建立连接，建立连接的过程需要来回交互三个报文（[SYN]-[SYN,ACK]-[ACK]）</p><p><img src="/img/tcp_udp/tcp_udp_4.jpg"> </p><p>①次握手 客户端–SYN–&gt;服务器</p><p><img src="/img/tcp_udp/tcp_udp_1.jpg"> </p><p>②次握手 服务器–SYN+ACK–&gt;客户端</p><p><img src="/img/tcp_udp/tcp_udp_2.jpg"> </p><p>③次握手 客户端–ACK–&gt;服务器</p><p><img src="/img/tcp_udp/tcp_udp_3.jpg"> </p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>不可靠传输，非面向连接：速度快，但准确性差</p><h1 id="Wireshark-过滤规则"><a href="#Wireshark-过滤规则" class="headerlink" title="Wireshark 过滤规则"></a>Wireshark 过滤规则</h1><p>ip.addr == 59.36.202.3 过滤出包含 59.36.202.3 的报文</p><p>ip.src == x.x.x.x 源地址</p><p>ip.dst == x.x.x.x 目标</p><p>tcp.dstport == 80 过滤出目标端口为 80 端口</p><p>tcp.srcport == 80 过滤出源端口为 80 端口</p><p>eth.dst == 48:89:e7:ae:71:53 过滤出目标 MAC 地址</p><p>eth.src == 48:89:e7:ae:71:53 过滤出源 MAC 地址</p><p>http 过滤高层协议</p><p>and or not 同时过滤–&gt; tcp or http and (not xxx)</p><h1 id="常用协议端口号"><a href="#常用协议端口号" class="headerlink" title="常用协议端口号"></a>常用协议端口号</h1><p>HTTP : tcp 80 网页浏览</p><p>telnet : tcp 23 远程控制</p><p>FTP : tcp 20 21 文件传输</p><p>RDP : tcp 3389 远程桌面</p><h1 id="用-telnet-测试某个端口是否开放"><a href="#用-telnet-测试某个端口是否开放" class="headerlink" title="用 telnet 测试某个端口是否开放"></a>用 telnet 测试某个端口是否开放</h1><p>未打开：</p><pre><code class="hljs routeros">[root@localhost ~]# telnet 192.168.2.89 3389Trying 192.168.2.89<span class="hljs-built_in">..</span>.telnet: connect <span class="hljs-keyword">to</span><span class="hljs-built_in"> address </span>192.168.2.89: <span class="hljs-literal">No</span><span class="hljs-built_in"> route </span><span class="hljs-keyword">to</span> host</code></pre><p>打开状态：</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# telnet <span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.98</span> <span class="hljs-number">3389</span>Trying <span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.98</span>...</code></pre>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP 子网划分</title>
    <link href="/2020/07/22/ip_netmask/"/>
    <url>/2020/07/22/ip_netmask/</url>
    
    <content type="html"><![CDATA[<h2 id="IP地址（Internet-Protocol）"><a href="#IP地址（Internet-Protocol）" class="headerlink" title="IP地址（Internet Protocol）"></a>IP地址（Internet Protocol）</h2><p>在互联网漫游的计算机的身份ID。唯一标识一台网络设备的身份ID。</p><p>IP 地址为：网络位 + 主机位 -&gt; 子网掩码下详解</p><p>IPV4地址：点分十进制 32bit</p><p>192.168.1.1-&gt;11000000.10101000.00000001.00000001</p><table><thead><tr><th align="center">1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td align="center">2<sup>7</sup>=128</td><td>2<sup>6</sup>=64</td><td>2<sup>5</sup>=32</td><td>2<sup>4</sup>=16</td><td>2<sup>3</sup>=8</td><td>2<sup>2</sup>=4</td><td>2<sup>1</sup>=2</td><td>2<sup>0</sup>=1</td></tr><tr><td align="center">128</td><td>192</td><td>224</td><td>240</td><td>248</td><td>252</td><td>254</td><td>255</td></tr></tbody></table><a id="more"></a><h2 id="子网掩码（Netmask）"><a href="#子网掩码（Netmask）" class="headerlink" title="子网掩码（Netmask）"></a>子网掩码（Netmask）</h2><p>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在广域网上。</p><p><strong>例子：</strong>  </p><p>ip：192.168.1.1</p><p>二进制：11000000.10101000.00000001.00000001</p><p>netmask：255.255.255.0</p><p>二进制：<font color=green > 11111111.11111111.11111111</font>.<font color=blue > 00000000</font></p><p>根据二进制子网掩码，绿色为网络位，蓝色为主机位，即：</p><p>网络位：子网掩码1 bit 对应的位</p><p>主机位：子网掩码0 bit 对应的位</p><p>网络位为：192.168.1-&gt;11000000.10101000.00000001</p><p>主机位：00000001</p><p>主机位全0：子网地址</p><p>主机位全1：子网广播地址</p><p><font color=red >注：主机位全 0 全1 的 ip 地址和掩码的组合是无效的。</font></p><p><strong>例子：</strong></p><p>192.168.1.127 255.255.255.128</p><p>192.168.1.0—1111111</p><p>255.255.255.1—0000000</p><h2 id="网段"><a href="#网段" class="headerlink" title="网段"></a>网段</h2><p>具有<font color=red >相同网络位</font>的ip和掩码的组合称为同一个网段（局域网、子网）</p><p><font color=red >注：同一网段的PC互通不需要网关。</font></p><p><strong>例子：</strong></p><p>已知某个网络的掩码是 255.255.248.0，下面属于同一网段的是:</p><p>A. 10.110.16.1 和 10.110.25.1</p><p>B. 10.76.129.21 和 10.76.137.1</p><p>C.  10.52.57.34 和 10.52.62.2</p><p>D. 10.33.23.2 和 10.33.31.1</p><p>解：</p><p>子网掩码 255.255.248.0 -&gt; </p><p>-&gt;二进制 <font color=green >255.255.11111</font>   <font color=blue >000.0</font></p><p><font color=green >绿色：网络位</font>         <font color=blue >蓝色：主机位</font></p><p>A.</p><p><font color=green >10.110.  00010</font>   <font color=blue >000.1</font><br><font color=green >10.110.  00011</font>   <font color=blue >001.1</font></p><p>B.</p><p><font color=green >10.76.    10000</font>   <font color=blue >001.21</font><br><font color=green >10.76.    10001</font>   <font color=blue >001.1</font>  </p><p>C.</p><p><font color=green >10.52.    00111</font>   <font color=blue >001.34</font><br><font color=green >10.52.    00111</font>   <font color=blue >110.2</font></p><p>D.</p><p><font color=green >10.22.    00010</font>   <font color=blue >111.2</font><br><font color=green >10.33.    00011</font>   <font color=blue >111.1</font></p><p><strong>例子：</strong></p><p>172.16.0.0/16 分成6个子网段：</p><p>2^n&gt;=6 n=3 需要3个 bit 的子网位 </p><p>172.16.<font color=red ><strong>000</strong></font>00000.0</p><ol><li>172.16.<font color=red ><strong>000</strong></font>00000.0 –&gt; 172.16.0.0/19</li><li>172.16.<font color=red ><strong>001</strong></font>00000.0 –&gt; 172.16.32.0/19</li><li>172.16.<font color=red ><strong>010</strong></font>00000.0 –&gt; 172.16.64.0/19</li><li>172.16.<font color=red ><strong>011</strong></font>00000.0 </li><li>172.16.<font color=red ><strong>100</strong></font>00000.0 </li><li>172.16.<font color=red ><strong>101</strong></font>00000.0 </li><li>172.16.<font color=red ><strong>110</strong></font>00000.0 </li><li>172.16.<font color=red ><strong>111</strong></font>00000.0 </li></ol><h2 id="网关（Gateway）"><a href="#网关（Gateway）" class="headerlink" title="网关（Gateway）"></a>网关（Gateway）</h2><p>当 PC 访问不同网段的服务时，需要将数据交给网关处理</p><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>time to live：生命周期，指定IP包被路由器丢弃之前允许通过的最大网段数量。</p><h2 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h2><p>测试本地到达目标所经过的三层设备</p><pre><code class="hljs angelscript">C:\Users\ecarry&gt;tracert www.baidu.com通过最多 <span class="hljs-number">30</span> 个跃点跟踪到 www.a.shifen.com [<span class="hljs-number">14.215</span><span class="hljs-number">.177</span><span class="hljs-number">.39</span>] 的路由:  <span class="hljs-number">1</span>     *        *       &lt;<span class="hljs-number">1</span> 毫秒 OPENWRT [<span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.3</span>]  <span class="hljs-number">2</span>     <span class="hljs-number">1</span> ms    &lt;<span class="hljs-number">1</span> 毫秒   &lt;<span class="hljs-number">1</span> 毫秒 RT-AC1200G+<span class="hljs-number">-3220</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.1</span>]  <span class="hljs-number">3</span>     <span class="hljs-number">1</span> ms     <span class="hljs-number">1</span> ms    &lt;<span class="hljs-number">1</span> 毫秒 SMBSHARE [<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>]  <span class="hljs-number">4</span>    <span class="hljs-number">15</span> ms    <span class="hljs-number">22</span> ms     <span class="hljs-number">4</span> ms  <span class="hljs-number">100.64</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>  <span class="hljs-number">5</span>     *        *        *     请求超时。  <span class="hljs-number">6</span>     <span class="hljs-number">7</span> ms     <span class="hljs-number">7</span> ms     <span class="hljs-number">6</span> ms  <span class="hljs-number">120.36</span><span class="hljs-number">.57</span><span class="hljs-number">.29</span>  <span class="hljs-number">7</span>     *        *        *     请求超时。  <span class="hljs-number">8</span>    <span class="hljs-number">22</span> ms    <span class="hljs-number">22</span> ms    <span class="hljs-number">23</span> ms  <span class="hljs-number">113.96</span><span class="hljs-number">.4</span><span class="hljs-number">.126</span>  <span class="hljs-number">9</span>    <span class="hljs-number">23</span> ms    <span class="hljs-number">23</span> ms     *     <span class="hljs-number">98.96</span><span class="hljs-number">.135</span><span class="hljs-number">.219</span>.broad.fs.gd.dynamic<span class="hljs-number">.163</span>data.com.cn [<span class="hljs-number">219.135</span><span class="hljs-number">.96</span><span class="hljs-number">.98</span>] <span class="hljs-number">10</span>    <span class="hljs-number">20</span> ms    <span class="hljs-number">20</span> ms    <span class="hljs-number">20</span> ms  <span class="hljs-number">14.29</span><span class="hljs-number">.117</span><span class="hljs-number">.246</span> <span class="hljs-number">11</span>     *        *        *     请求超时。 <span class="hljs-number">12</span>     *        *        *     请求超时。 <span class="hljs-number">13</span>    <span class="hljs-number">19</span> ms    <span class="hljs-number">19</span> ms    <span class="hljs-number">18</span> ms  <span class="hljs-number">14.215</span><span class="hljs-number">.177</span><span class="hljs-number">.39</span></code></pre><h2 id="ARP-Address-Resolution解析-Protocol"><a href="#ARP-Address-Resolution解析-Protocol" class="headerlink" title="ARP(Address Resolution解析 Protocol)"></a>ARP(Address Resolution解析 Protocol)</h2><p>通过目的 IP 地址，请求对方 MAC 地址的过程</p><p><img src="/img/ip_netmask/ip_netmask_0.jpg"></p><p>一台主机向另外一台主机发送 ARP Request 的目的 MAC 地址为<font color=red >广播 MAC 地址</font>（FFFF.FFFF.FFFF），其请求包（request）结构为</p><p><img src="/img/ip_netmask/ip_netmask_1.jpg"></p><p>查看 APR 缓存表，通过命令<code>arp -a</code>查看，通过<code>arp -d</code>删除缓存表</p><pre><code class="hljs routeros">PC&gt;arp -a  Internet<span class="hljs-built_in"> Address </span>     Physical<span class="hljs-built_in"> Address </span>     Type  192.168.1.30          00d0.582e.0b9b        dynamic</code></pre><p>ARP 回应包（reply）结构：</p><p><img src="/img/ip_netmask/ip_netmask_2.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Linux 分区的小事</title>
    <link href="/2020/06/09/Linux_part/"/>
    <url>/2020/06/09/Linux_part/</url>
    
    <content type="html"><![CDATA[<h1 id="一、分区"><a href="#一、分区" class="headerlink" title="一、分区"></a>一、分区</h1><blockquote><p>分区是为了在逻辑上将某些柱面隔开形成边界。它是以柱面为单位来划分的，但是从CentOS 7开始，是按照扇区进行划分的。</p><p>在磁盘数据量非常大的情况下，划分分区的好处是扫描块位图等更快速：不用再扫描整块磁盘的块位图，只需扫描对应分区的块位图。</p></blockquote><h2 id="1-1-分区方法（MBR、GPT）"><a href="#1-1-分区方法（MBR、GPT）" class="headerlink" title="1.1 分区方法（MBR、GPT）"></a>1.1 分区方法（MBR、GPT）</h2><h3 id="1-1-1-MBR"><a href="#1-1-1-MBR" class="headerlink" title="1.1.1 MBR"></a>1.1.1 MBR</h3><p><strong>Master/Main Boot Record</strong></p><ul><li>446 bytes: BootLoader</li><li>64 bytes: <ul><li>16 bytes: 标识一个分区</li></ul></li><li>2 bytes：<a href="https://ecarry.cc/2020/09/02/linux_super_inode_block/#%E4%B8%80%E3%80%81%E4%BB%8E%E7%89%A9%E7%90%86%E7%A3%81%E7%9B%98%E5%88%B0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">Magic Number</a><ul><li>标记 MBR 是否有效</li></ul></li></ul><p>MBR格式的磁盘中，会维护磁盘第一个扇区——MBR扇区，在该扇区中第446字节之后的64字节是分区表，每个分区占用16字节，所以限制了一块磁盘最多只能有4个主分区(Primary,P)，如果多于4个区，只能将主分区少于4个，通过建立扩展分区(Extend,E)，然后在扩展分区建立逻辑分区(Logical,L)的方式来突破4个分区的限制，逻辑分区的数量不限制。</p><p>在Linux中，MBR格式的磁盘主分区号从1-4，扩展分区号从2-4，逻辑分区号从5开始。</p><p><strong>例如</strong>，一块盘想分成6个分区，可以：</p><p>1P+5L：sda1+sda5+sda6+sda7+sda8+sda9</p><p>2P+4L：sda1+sda2+sda5+sda6+sda7+sda8</p><p>3P+3L：sda1+sda2+sda3+sda5+sda6+sda7</p><h3 id="1-1-2-GPT"><a href="#1-1-2-GPT" class="headerlink" title="1.1.2 GPT"></a>1.1.2 GPT</h3><p>GPT格式突破了MBR的限制，它不再限制只能存储4个分区表条目，而是使用了类似MBR扩展分区表条目的格式，它允许有128个主分区，这也使得它可以对超过2TB的磁盘进行分区。</p><h2 id="1-2-MBR-和-GPT-分区表信息"><a href="#1-2-MBR-和-GPT-分区表信息" class="headerlink" title="1.2 MBR 和 GPT 分区表信息"></a>1.2 MBR 和 GPT 分区表信息</h2><p>在MBR格式分区表中，MBR扇区占用512个字节，前446个字节是主引导记录，即boot loader。中间64字节记录着分区表信息，每个主分区信息占用16字节，因此最多只能有4个主分区，最后2个字节是有效标识位。如果使用扩展分区，则扩展分区对应的16字节记录的是指向扩展分区中扩展分区表的指针。</p><p><img src="/img/linux_part/linux_part_1.png"></p><p>在MBR磁盘上，分区和启动信息是保存在一起的，如果这部分数据被覆盖或破坏，只能重建MBR。而GPT在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。GPT还为这些信息保存了循环冗余校验码(CRC)以保证其完整和正确，如果数据被破坏，GPT会发现这些破坏，并从磁盘上的其他地方进行恢复。</p><p>下面是GPT格式的分区表信息，大致约占17个字节。</p><p><img src="/img/linux_part/linux_part_2.png"></p><p>EFI部分可以分为4个区域：EFI信息区(GPT头)、分区表、GPT分区区域和备份区域。</p><ul><li>EFI信息区(GPT头)：起始于磁盘的LBA1，通常也只占用这个单一扇区。其作用是定义分区表的位置和大小。GPT头还包含头和分区表的校验和，这样就可以及时发现错误。</li><li>分区表：分区表区域包含分区表项。这个区域由GPT头定义，一般占用磁盘LBA2～LBA33扇区，每扇区可存储4个主分区的分区信息，所以共能分128个主分区。分区表中的每个分区项由起始地址、结束地址、类型值、名字、属性标志、GUID值组成。分区表建立后，128位的GUID对系统来说是唯一的。</li><li>GPT分区：最大的区域，由分配给分区的扇区组成。这个区域的起始和结束地址由GPT头定义。</li><li>备份区：备份区域位于磁盘的尾部，包含GPT头和分区表的备份。它占用GPT结束扇区和EFI结束扇区之间的33个扇区。其中最后一个扇区用来备份1号扇区的EFI信息，其余的32个扇区用来备份LBA2～LBA33扇区的分区表。</li></ul><h2 id="1-3-添加磁盘"><a href="#1-3-添加磁盘" class="headerlink" title="1.3 添加磁盘"></a>1.3 添加磁盘</h2><p>正常情况下，添加磁盘后需要重启系统才能被内核识别，在 /dev/ 下才有对应的设备号，使用 fdisk -l 才会显示出来。但是有时候不方便重启，所以下面介绍一种磁盘热插拔方式。</p><h3 id="1-3-1-Linux上磁盘热插拔"><a href="#1-3-1-Linux上磁盘热插拔" class="headerlink" title="1.3.1 Linux上磁盘热插拔"></a>1.3.1 Linux上磁盘热插拔</h3><p>获取 SCSI 设备信息：</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# lsscsi[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]    cd/dvd  QEMU     QEMU DVD-ROM     <span class="hljs-number">2.5</span>+  /dev/sr0 [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]    disk    WD       Elements SE <span class="hljs-number">25</span>FE <span class="hljs-number">1021</span>  /dev/sdb [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]    enclosu WD       SES Device       <span class="hljs-number">1021</span>  -        [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]    disk    QEMU     QEMU HARDDISK    <span class="hljs-number">2.5</span>+  /dev/sda</code></pre><p>有些操作系统没有 lsscsi 命令，则可以使用下面的方法获取 scsi 设备信息：</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# ll /sys/bus/scsi/drivers/sd/总用量 <span class="hljs-number">0</span>lrwxrwxrwx. <span class="hljs-number">1</span> root root    <span class="hljs-number">0</span> <span class="hljs-number">8</span>月   <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">54</span> <span class="hljs-number">2</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span> -&gt; ../../../../devices/pci0000:<span class="hljs-number">00</span>/<span class="hljs-number">0000</span>:<span class="hljs-number">00</span>:<span class="hljs-number">1</span>e<span class="hljs-number">.0</span>/<span class="hljs-number">0000</span>:<span class="hljs-number">01</span>:<span class="hljs-number">1</span>b<span class="hljs-number">.0</span>/usb3/<span class="hljs-number">3</span><span class="hljs-number">-1</span>/<span class="hljs-number">3</span><span class="hljs-number">-1</span>:<span class="hljs-number">1.0</span>/host2/target2:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>/<span class="hljs-number">2</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>lrwxrwxrwx. <span class="hljs-number">1</span> root root    <span class="hljs-number">0</span> <span class="hljs-number">8</span>月   <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">54</span> <span class="hljs-number">3</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span> -&gt; ../../../../devices/pci0000:<span class="hljs-number">00</span>/<span class="hljs-number">0000</span>:<span class="hljs-number">00</span>:<span class="hljs-number">05.0</span>/virtio1/host3/target3:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>/<span class="hljs-number">3</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>--w-------. <span class="hljs-number">1</span> root root <span class="hljs-number">4096</span> <span class="hljs-number">8</span>月   <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">54</span> bind--w-------. <span class="hljs-number">1</span> root root <span class="hljs-number">4096</span> <span class="hljs-number">7</span>月  <span class="hljs-number">20</span> <span class="hljs-number">18</span>:<span class="hljs-number">39</span> uevent--w-------. <span class="hljs-number">1</span> root root <span class="hljs-number">4096</span> <span class="hljs-number">8</span>月   <span class="hljs-number">9</span> <span class="hljs-number">15</span>:<span class="hljs-number">54</span> unbind[<span class="hljs-symbol">root@</span>localhost ~]# ll /sys/bus/scsi/drivers/sd/<span class="hljs-number">2</span>\:<span class="hljs-number">0</span>\:<span class="hljs-number">0</span>\:<span class="hljs-number">0</span>/block/总用量 <span class="hljs-number">0</span>drwxr-xr-x. <span class="hljs-number">8</span> root root <span class="hljs-number">0</span> <span class="hljs-number">7</span>月  <span class="hljs-number">20</span> <span class="hljs-number">18</span>:<span class="hljs-number">39</span> sdb</code></pre><p>然后查看 /proc/scsi/scsi 文件，获取对应scsi设备的详细信息：</p><pre><code class="hljs tcl">[root@localhost ~]# cat /<span class="hljs-keyword">proc</span>/scsi/scsi Attached<span class="hljs-title"> devices:</span><span class="hljs-title">Host:</span> scsi1<span class="hljs-title"> Channel:</span> 00<span class="hljs-title"> Id:</span> 00<span class="hljs-title"> Lun:</span> 00<span class="hljs-title">  Vendor:</span> QEMU<span class="hljs-title">     Model:</span> QEMU<span class="hljs-title"> DVD-ROM</span> <span class="hljs-title">    Rev:</span> 2.5+<span class="hljs-title">  Type:</span> <span class="hljs-title">  CD-ROM</span> <span class="hljs-title">                          ANSI</span> <span class="hljs-title"> SCSI</span> revision: 05Host:<span class="hljs-title"> scsi3</span> Channel: 00<span class="hljs-title"> Id:</span> 00<span class="hljs-title"> Lun:</span> 00&lt;-----/dev/sda<span class="hljs-title">  Vendor:</span> QEMU<span class="hljs-title">     Model:</span> QEMU<span class="hljs-title"> HARDDISK</span> <span class="hljs-title">   Rev:</span> 2.5+<span class="hljs-title">  Type:</span> <span class="hljs-title">  Direct-Access</span> <span class="hljs-title">                   ANSI</span> <span class="hljs-title"> SCSI</span> revision: 05Host:<span class="hljs-title"> scsi2</span> Channel: 00<span class="hljs-title"> Id:</span> 00<span class="hljs-title"> Lun:</span> 00&lt;-----/dev/sdb<span class="hljs-title">  Vendor:</span> WD<span class="hljs-title">       Model:</span> Elements<span class="hljs-title"> SE</span> 25FE<span class="hljs-title"> Rev:</span> 1021<span class="hljs-title">  Type:</span> <span class="hljs-title">  Direct-Access</span> <span class="hljs-title">                   ANSI</span> <span class="hljs-title"> SCSI</span> revision: 06Host:<span class="hljs-title"> scsi2</span> Channel: 00<span class="hljs-title"> Id:</span> 00<span class="hljs-title"> Lun:</span> 01<span class="hljs-title">  Vendor:</span> WD<span class="hljs-title">       Model:</span> SES<span class="hljs-title"> Device</span> <span class="hljs-title">      Rev:</span> 1021<span class="hljs-title">  Type:</span> <span class="hljs-title">  Enclosure</span> <span class="hljs-title">                       ANSI</span> <span class="hljs-title"> SCSI</span> revision: 06</code></pre><p>在此处，有两块<strong>直连</strong>(<strong>Direct-Access</strong>)的 scsi 磁盘，一块通过光驱cd-rom连接的光盘。我们只考虑 scsi 磁盘，所以这两块磁盘在 scsi 中的定位符为2:0:0:0和3:0:0:0。<strong>如果继续插入一块盘，那么新盘在scsi中的定位符可能为4:0:0:0</strong>，这个数值串非常重要。</p><h4 id="热插"><a href="#热插" class="headerlink" title="热插"></a>热插</h4><p>在向计算机中插入一块磁盘后，内核因为识别不了它所以不会产生任何事件通知，因此在 /sys 目录中不会产生任何文件，任何工具也就读取不了它。重启系统肯定是可以解决的，但是Linux支持热插。</p><p>热插新盘的方式是向 /proc/scsi/scsi 中写入新 scsi 设备的信息。方式如下：</p><p><code>echo &quot;scsi add-single-device a b c d&quot; &gt;/proc/scsi/scsi</code></p><p>其中：</p><p>   a == hostadapter id (first one being 0)</p><p>   b == SCSI channel on hostadapter (first one being 0)</p><p>   c == ID</p><p>   d == LUN (first one being 0)</p><p>例如上面的例子，应该添加如下信息：</p><p><code>[root@localhost ~]# echo &quot;scsi add-single-device 4:0:0:0&quot; &gt;/proc/scsi/scsi</code></p><p>重新扫描 scsi 总线也可以实现热插的功能，查看主机 SCSI 总线号：</p><pre><code class="hljs gradle">[root@localhost ~]# ls <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/scsi_host/</span>host0  host1  host2  host3#重新扫描scsi总线以热插拔方式添加新设备。[root@localhost ~]# echo <span class="hljs-string">&quot;- - -&quot;</span> &gt; <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/scsi_host/</span>host0/scan[root@localhost ~]# echo <span class="hljs-string">&quot;- - -&quot;</span> &gt; <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/scsi_host/</span>host1/scan[root@localhost ~]# echo <span class="hljs-string">&quot;- - -&quot;</span> &gt; <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/scsi_host/</span>host2/scan[root@localhost ~]# echo <span class="hljs-string">&quot;- - -&quot;</span> &gt; <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/scsi_host/</span>host3/scan[root@localhost ~]# fdisk -l      # 再查看就有了</code></pre><p>如果 scsi_host 目录系很多hostN目录，则使用循环来完成：</p><pre><code class="hljs gradle">[root@localhost ~]# ls <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/scsi_host/</span>host0   host11  host14  host17  host2   host22  host25  host28  host30  host4  host7host1   host12  host15  host18  host20  host23  host26  host29  host31  host5  host8host10  host13  host16  host19  host21  host24  host27  host3   host32  host6  host9[root@localhost ~]# <span class="hljs-keyword">for</span> i in <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/scsi_host/</span>host*/scan;<span class="hljs-keyword">do</span> echo <span class="hljs-string">&quot;- - -&quot;</span> &gt;$i;done</code></pre><p>热插之后，fdisk -l等命令就可以识别到该磁盘了。</p><h4 id="热拔"><a href="#热拔" class="headerlink" title="热拔"></a>热拔</h4><p>热拔磁盘的方式是在 /proc/scsi/scsi 中移除对应 scsi 设备的信息。方式如下：</p><p><code>echo &quot;scsi remove-single-device a b c d&quot; &gt;/proc/scsi/scsi</code></p><p>例如删除2:0:0:0这块磁盘：</p><p><code>[root@localhost ~]# echo &quot;scsi remove-single-device 2 0 0 0&quot; &gt;/proc/scsi/scsi</code></p><p>因为要删除的设备已经存在，/sys中已经有它完整的信息，所以也从其自身设备上进行删除。</p><p>首先查看scsi设备信息:</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# lsscsi[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]    cd/dvd  QEMU     QEMU DVD-ROM     <span class="hljs-number">2.5</span>+  /dev/sr0 [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]    disk    WD       Elements SE <span class="hljs-number">25</span>FE <span class="hljs-number">1021</span>  /dev/sdb [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]    enclosu WD       SES Device       <span class="hljs-number">1021</span>  -        [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]    disk    QEMU     QEMU HARDDISK    <span class="hljs-number">2.5</span>+  /dev/sda</code></pre><p> 例如要删除 /dev/sdb，即2:0:0:0。先看看它的文件信息：</p><pre><code class="hljs routeros">[root@localhost ~]# ls /sys/bus/scsi/drivers/sd/2\:0\:0\:0/block           driver                        evt_mode_parameter_change_reported  ioerr_cnt      queue_depth  scsi_generic  ueventbsg             eh_timeout                    evt_soft_threshold_reached          iorequest_cnt  queue_type   scsi_level    unpriv_sgiodelete          evt_capacity_change_reported  generic                             max_sectors    rescan       state         vendordevice_blocked  evt_inquiry_change_reported   inquiry                             modalias       rev          subsystem     vpd_pg80device_busy     evt_lun_change_reported       iocounterbits                       model          scsi_device  timeout       vpd_pg83dh_state        evt_media_change              iodone_cnt                          power          scsi_disk   <span class="hljs-built_in"> type </span>         wwid</code></pre><p>在其中有3个文件：delete、rescan和state。其中state记录了该设备是否正在运行中。而delete和rescan文件则用于删除和重新扫描该设备。</p><p>例如，删除该设备，即热拔：</p><p><code>[root@localhost ~]# echo 1 &gt; /sys/bus/scsi/drivers/sd/2\:0\:0\:0/delete</code></p><h2 id="1-4-使用-fdisk-分区工具"><a href="#1-4-使用-fdisk-分区工具" class="headerlink" title="1.4 使用 fdisk 分区工具"></a>1.4 使用 fdisk 分区工具</h2><p>fdisk 工具用来分 MBR 磁盘上的区。要分 GPT 磁盘上的区，可以使用 gdisk。parted工具对这两种格式的磁盘分区都支持。</p><p>如果一个存储设备已经分过区，那么它可能是mbr格式的，也可能是gpt格式的，如果已经是mbr格式的，则只能继续使用fdisk进行分区，如果已经是gpt格式的，则只能使用gdisk进行分区。当然，无论什么格式的都可以使用parted进行分区，只不过也只能划分和已存在分区格式一样的分区，因为无论何种格式的分区，它的分区表和分区标识是已经固定的。</p><p>使用fdisk分区，它只能实现MBR格式的分区：</p><pre><code class="hljs sql">[root@localhost ~]<span class="hljs-comment"># fdisk /dev/sda</span>欢迎使用 fdisk (util-linux 2.23.2)。更改将停留在内存中，直到您决定将更改写入磁盘。使用写入命令前请三思。命令(输入 m 获取帮助)：m命令操作   a   toggle a bootable flag   b   edit bsd disklabel   c   toggle the dos compatibility flag   d   <span class="hljs-keyword">delete</span> a <span class="hljs-keyword">partition</span>   g   <span class="hljs-keyword">create</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">empty</span> GPT <span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span><span class="hljs-comment">#新版本 fdisk 开始支持 GPT 分区了</span>   G   <span class="hljs-keyword">create</span> an IRIX (SGI) <span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span>   l   <span class="hljs-keyword">list</span> known <span class="hljs-keyword">partition</span> types   m   print this menu   n   <span class="hljs-keyword">add</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">partition</span>   o   <span class="hljs-keyword">create</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">empty</span> DOS <span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span>   p   print the <span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span>   q   quit <span class="hljs-keyword">without</span> saving changes   s   <span class="hljs-keyword">create</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">empty</span> Sun disklabel   t   <span class="hljs-keyword">change</span> a <span class="hljs-keyword">partition</span><span class="hljs-string">&#x27;s system id</span><span class="hljs-string">   u   change display/entry units</span><span class="hljs-string">   v   verify the partition table</span><span class="hljs-string">   w   write table to disk and exit</span><span class="hljs-string">   x   extra functionality (experts only)</span><span class="hljs-string"></span><span class="hljs-string">命令(输入 m 获取帮助)：p</span><span class="hljs-string"></span><span class="hljs-string">磁盘 /dev/sda：21.5 GB, 21474836480 字节，41943040 个扇区</span><span class="hljs-string">Units = 扇区 of 1 * 512 = 512 bytes</span><span class="hljs-string">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><span class="hljs-string">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><span class="hljs-string">磁盘标签类型：dos</span><span class="hljs-string">磁盘标识符：0x000c7ad0</span><span class="hljs-string"></span><span class="hljs-string">   设备 Boot      Start         End      Blocks   Id  System</span><span class="hljs-string">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><span class="hljs-string">/dev/sda2         2099200    41943039    19921920   8e  Linux LVM</span><span class="hljs-string"></span><span class="hljs-string">命令(输入 m 获取帮助)：n#新建分区</span><span class="hljs-string">Partition type:</span><span class="hljs-string">   p   primary (2 primary, 0 extended, 2 free)#总共可建4个主分区，现有2个，还剩可建两个</span><span class="hljs-string">   e   extended#扩展分区</span><span class="hljs-string">Select (default p): p</span><span class="hljs-string">分区号 (3,4，默认 3)：</span><span class="hljs-string">#建立完分区注意保存</span><span class="hljs-string">Command (m for help): w  </span><span class="hljs-string">The partition table has been altered!</span><span class="hljs-string"></span><span class="hljs-string">Calling ioctl() to re-read partition table.</span><span class="hljs-string">Syncing disks.</span></code></pre><p>上面的 fdisk 操作全部是在内存中执行的，必须保存生效。保存后，内核还未识别该分区，可以查看 /proc/partition 目录下存在的文件，这些文件是能被内核识别的分区。运行<strong>partprobe</strong>或<strong>partx</strong>命令重新读取分区表让内核识别新的分区，内核识别后才可以格式化。而且分区结束时按w保存分区表有时候会失败，提示重启，这时候运行partprobe命令可以代替重启就生效。</p><pre><code class="hljs gradle">[root@localhost ~]# partprobe <span class="hljs-regexp">/dev/</span>sdb#也可指定在 <span class="hljs-regexp">/dev/</span>sdb 上重加载分区表</code></pre><h2 id="1-5-使用-gdisk-分区工具"><a href="#1-5-使用-gdisk-分区工具" class="headerlink" title="1.5 使用 gdisk 分区工具"></a>1.5 使用 gdisk 分区工具</h2><p>使用 gdsik 需要安装这个工具包：</p><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># yum -y install gdisk</span></code></pre><p>分区的时候直接带上设备即可。以下是对新硬盘划分gpt分区的过程：</p><pre><code class="hljs sql">[root@localhost ~]<span class="hljs-comment"># gdisk /dev/sdb</span>GPT fdisk (gdisk) version 0.8.10Partition table scan:  MBR: not present  BSD: not present  APM: not present  GPT: not presentCreating new GPT entries.Command (? for <span class="hljs-keyword">help</span>): ?b       back up GPT <span class="hljs-keyword">data</span> <span class="hljs-keyword">to</span> a <span class="hljs-keyword">file</span>c       <span class="hljs-keyword">change</span> a <span class="hljs-keyword">partition</span><span class="hljs-string">&#x27;s name</span><span class="hljs-string">d       delete a partition                               # 删除分区</span><span class="hljs-string">i       show detailed information on a partition         # 列出分区详细信息</span><span class="hljs-string">l       list known partition types                       # 列出所以已知的分区类型</span><span class="hljs-string">n       add a new partition                              # 添加新分区</span><span class="hljs-string">o       create a new empty GUID partition table (GPT)    # 创建一个新的空的guid分区表</span><span class="hljs-string">p       print the partition table                        # 输出分区表信息</span><span class="hljs-string">q       quit without saving changes                      # 退出gdisk工具</span><span class="hljs-string">r       recovery and transformation options (experts only) </span><span class="hljs-string">s       sort partitions                                </span><span class="hljs-string">t       change a partition&#x27;</span>s <span class="hljs-keyword">type</span> code                   <span class="hljs-comment"># 修改分区类型</span>v       <span class="hljs-keyword">verify</span> diskw       write <span class="hljs-keyword">table</span> <span class="hljs-keyword">to</span> disk <span class="hljs-keyword">and</span> <span class="hljs-keyword">exit</span>                     <span class="hljs-comment"># 将分区信息写入到磁盘</span>x       extra functionality (experts <span class="hljs-keyword">only</span>)             ?       print this menuCommand (? <span class="hljs-keyword">for</span> <span class="hljs-keyword">help</span>): n   <span class="hljs-comment">#添加一个新分区</span><span class="hljs-keyword">Partition</span> <span class="hljs-built_in">number</span> (<span class="hljs-number">1</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>):<span class="hljs-keyword">First</span> sector (<span class="hljs-number">34</span><span class="hljs-number">-41943006</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">2048</span>) <span class="hljs-keyword">or</span> &#123;+-&#125;<span class="hljs-keyword">size</span>&#123;KMGTP&#125;:<span class="hljs-keyword">Last</span> sector (<span class="hljs-number">2048</span><span class="hljs-number">-41943006</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">41943006</span>) <span class="hljs-keyword">or</span> &#123;+-&#125;<span class="hljs-keyword">size</span>&#123;KMGTP&#125;: +<span class="hljs-number">10</span>G<span class="hljs-keyword">Current</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;Linux filesystem&#x27;</span><span class="hljs-keyword">Hex</span> code <span class="hljs-keyword">or</span> GUID (L <span class="hljs-keyword">to</span> <span class="hljs-keyword">show</span> codes, Enter = <span class="hljs-number">8300</span>):<span class="hljs-keyword">Changed</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;Linux filesystem&#x27;</span> Command (? <span class="hljs-keyword">for</span> <span class="hljs-keyword">help</span>): pDisk /dev/sdb: <span class="hljs-number">41943040</span> sectors, <span class="hljs-number">20.0</span> GiB<span class="hljs-keyword">Logical</span> sector <span class="hljs-keyword">size</span>: <span class="hljs-number">512</span> <span class="hljs-keyword">bytes</span>Disk identifier (GUID): F8AE925F<span class="hljs-number">-515</span>F<span class="hljs-number">-4807</span><span class="hljs-number">-92</span>ED<span class="hljs-number">-4109</span>D0827191<span class="hljs-keyword">Partition</span> <span class="hljs-keyword">table</span> holds up <span class="hljs-keyword">to</span> <span class="hljs-number">128</span> entries<span class="hljs-keyword">First</span> <span class="hljs-keyword">usable</span> sector <span class="hljs-keyword">is</span> <span class="hljs-number">34</span>, <span class="hljs-keyword">last</span> <span class="hljs-keyword">usable</span> sector <span class="hljs-keyword">is</span> <span class="hljs-number">41943006</span><span class="hljs-keyword">Partitions</span> will be aligned <span class="hljs-keyword">on</span> <span class="hljs-number">2048</span>-sector boundariesTotal free <span class="hljs-keyword">space</span> <span class="hljs-keyword">is</span> <span class="hljs-number">20971453</span> sectors (<span class="hljs-number">10.0</span> GiB) <span class="hljs-built_in">Number</span>  <span class="hljs-keyword">Start</span> (sector)    <span class="hljs-keyword">End</span> (sector)  <span class="hljs-keyword">Size</span>       Code  <span class="hljs-keyword">Name</span>   <span class="hljs-number">1</span>            <span class="hljs-number">2048</span>        <span class="hljs-number">20973567</span>   <span class="hljs-number">10.0</span> GiB    <span class="hljs-number">8300</span>  Linux filesystemCommand (? <span class="hljs-keyword">for</span> <span class="hljs-keyword">help</span>): i   <span class="hljs-comment"># 查看分区详细信息</span><span class="hljs-keyword">Using</span> <span class="hljs-number">1</span><span class="hljs-keyword">Partition</span> GUID code: <span class="hljs-number">0</span>FC63DAF<span class="hljs-number">-8483</span><span class="hljs-number">-4772</span><span class="hljs-number">-8E79</span><span class="hljs-number">-3</span>D69D8477DE4 (Linux filesystem)<span class="hljs-keyword">Partition</span> <span class="hljs-keyword">unique</span> GUID: B2452103<span class="hljs-number">-4</span>F32<span class="hljs-number">-4</span>B60-AEF7<span class="hljs-number">-4</span>BA42B7BF089<span class="hljs-keyword">First</span> sector: <span class="hljs-number">2048</span> (<span class="hljs-keyword">at</span> <span class="hljs-number">1024.0</span> KiB)<span class="hljs-keyword">Last</span> sector: <span class="hljs-number">20973567</span> (<span class="hljs-keyword">at</span> <span class="hljs-number">10.0</span> GiB)<span class="hljs-keyword">Partition</span> <span class="hljs-keyword">size</span>: <span class="hljs-number">20971520</span> sectors (<span class="hljs-number">10.0</span> GiB)<span class="hljs-keyword">Attribute</span> flags: <span class="hljs-number">0000000000000000</span><span class="hljs-keyword">Partition</span> <span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;Linux filesystem&#x27;</span>Command (? <span class="hljs-keyword">for</span> <span class="hljs-keyword">help</span>): w <span class="hljs-comment">#保存分区表到磁盘</span><span class="hljs-keyword">Final</span> checks complete. About <span class="hljs-keyword">to</span> write GPT data. THIS WILL OVERWRITE EXISTING<span class="hljs-keyword">PARTITIONS</span>!!<span class="hljs-keyword">Do</span> you want <span class="hljs-keyword">to</span> proceed? (Y/N): YOK; writing new GUID partition table (GPT) to /dev/sdb.The operation has completed successfully.<span class="hljs-comment">#执行partprobe重新读取分区表信息</span>[root@localhost ~]<span class="hljs-comment"># partprobe /dev/sdb</span></code></pre><h2 id="1-6-使用-parted-分区"><a href="#1-6-使用-parted-分区" class="headerlink" title="1.6 使用 parted 分区"></a>1.6 使用 parted 分区</h2><p>parted 支持 mbr 格式和 gpt 格式的磁盘分区。它的强大在于可以一步到位而不需要不断的交互式输入(也可以交互式)。</p><p>parted分区工具是实时的，所以每一步操作都是直接写入磁盘而不是写进内存，它不像 fdisk/gdisk 还需要 w 命令将内存中的结果保存到磁盘中。</p><pre><code class="hljs pgsql">[root@localhost ~]# parted /dev/sdcGNU Parted <span class="hljs-number">2.1</span><span class="hljs-keyword">Using</span> /dev/sdcWelcome <span class="hljs-keyword">to</span> GNU Parted! <span class="hljs-keyword">Type</span> <span class="hljs-string">&#x27;help&#x27;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">view</span> a list <span class="hljs-keyword">of</span> commands. (parted) help                                                               align-<span class="hljs-keyword">check</span> <span class="hljs-keyword">TYPE</span> N                      <span class="hljs-keyword">check</span> <span class="hljs-keyword">partition</span> N <span class="hljs-keyword">for</span> <span class="hljs-keyword">TYPE</span>(min|opt) alignment  <span class="hljs-keyword">check</span> NUMBER                            <span class="hljs-keyword">do</span> a simple <span class="hljs-keyword">check</span> <span class="hljs-keyword">on</span> the file <span class="hljs-keyword">system</span>(centos <span class="hljs-number">7</span>上已删除该功能)  cp [<span class="hljs-keyword">FROM</span>-DEVICE] <span class="hljs-keyword">FROM</span>-NUMBER <span class="hljs-keyword">TO</span>-NUMBER  <span class="hljs-keyword">copy</span> file <span class="hljs-keyword">system</span> <span class="hljs-keyword">to</span> another <span class="hljs-keyword">partition</span>(centos <span class="hljs-number">7</span>上已删除该功能)  help [COMMAND]                          print general help, <span class="hljs-keyword">or</span> help <span class="hljs-keyword">on</span> COMMAND  mklabel,mktable LABEL-<span class="hljs-keyword">TYPE</span>              <span class="hljs-keyword">create</span> a <span class="hljs-built_in">new</span> disklabel (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span>)  mkfs NUMBER FS-<span class="hljs-keyword">TYPE</span>                     make a FS-<span class="hljs-keyword">TYPE</span> file <span class="hljs-keyword">system</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">partition</span> NUMBER (centos <span class="hljs-number">7</span>上已删除改该功能)   mkpart PART-<span class="hljs-keyword">TYPE</span> [FS-<span class="hljs-keyword">TYPE</span>] <span class="hljs-keyword">START</span> <span class="hljs-keyword">END</span>    make a <span class="hljs-keyword">partition</span>  mkpartfs PART-<span class="hljs-keyword">TYPE</span> FS-<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">START</span> <span class="hljs-keyword">END</span>    make a <span class="hljs-keyword">partition</span> <span class="hljs-keyword">with</span> a file <span class="hljs-keyword">system</span>(centos <span class="hljs-number">7</span>上已删除该功能)     <span class="hljs-keyword">move</span> NUMBER <span class="hljs-keyword">START</span> <span class="hljs-keyword">END</span>                   <span class="hljs-keyword">move</span> <span class="hljs-keyword">partition</span> NUMBER(centos <span class="hljs-number">7</span>上已删除该功能)   <span class="hljs-type">name</span> NUMBER <span class="hljs-type">NAME</span>                        <span class="hljs-type">name</span> <span class="hljs-keyword">partition</span> NUMBER <span class="hljs-keyword">as</span> <span class="hljs-type">NAME</span>  print [devices|free|list,<span class="hljs-keyword">all</span>|NUMBER]    display the <span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span>,available devices,free space, <span class="hljs-keyword">all</span> <span class="hljs-built_in">found</span> partitions,<span class="hljs-keyword">or</span> a particular <span class="hljs-keyword">partition</span>  quit                                    <span class="hljs-keyword">exit</span> program  rescue <span class="hljs-keyword">START</span> <span class="hljs-keyword">END</span>                        rescue a lost <span class="hljs-keyword">partition</span> near <span class="hljs-keyword">START</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">END</span>  resize NUMBER <span class="hljs-keyword">START</span> <span class="hljs-keyword">END</span>                 resize <span class="hljs-keyword">partition</span> NUMBER <span class="hljs-keyword">and</span> its file <span class="hljs-keyword">system</span>(修改分区大小(centos <span class="hljs-number">7</span>上已删除该功能))  rm NUMBER                               <span class="hljs-keyword">delete</span> <span class="hljs-keyword">partition</span> NUMBER (删除分区)               <span class="hljs-keyword">select</span> DEVICE                           choose the device <span class="hljs-keyword">to</span> edit (重选磁盘进入parted状态)    <span class="hljs-keyword">set</span> NUMBER FLAG STATE                   change the FLAG <span class="hljs-keyword">on</span> <span class="hljs-keyword">partition</span> NUMBER(设置分区状态，如将其<span class="hljs-keyword">off</span>或<span class="hljs-keyword">on</span>)    toggle [NUMBER [FLAG]]                  toggle the state <span class="hljs-keyword">of</span> FLAG <span class="hljs-keyword">on</span> <span class="hljs-keyword">partition</span> NUMBER(修改文件系统类型，如swap、lvm)    unit UNIT                               <span class="hljs-keyword">set</span> the <span class="hljs-keyword">default</span> unit <span class="hljs-keyword">to</span> UNIT(修改默认单位，kB/MB/GB等)  <span class="hljs-keyword">version</span>                                 display the <span class="hljs-keyword">version</span> number <span class="hljs-keyword">and</span> copyright information <span class="hljs-keyword">of</span> GNU Parted</code></pre><p>常用的命令是mklabel、rm、print、mkpart、help、quit</p><p>parted分区的前提是磁盘已经有分区表(partition table)或磁盘标签(disk label)，否则将显示”unrecognised disk label”，这是和fdisk/gdisk不同的地方，所以需要先使用mklabel创建标签或分区表，最常见的标签(分区表)为”msdos”和”gpt”，其中msdos分区就是MBR格式的分区表，也就是会有主分区、扩展分区和逻辑分区的概念和限制。</p><p>下面使用 parted 对 /dev/sdc 创建 msdos 的新分区：</p><pre><code class="hljs routeros">[root@localhost ~]# parted /dev/sdcGNU Parted 2.1Using /dev/sdbWelcome <span class="hljs-keyword">to</span> GNU Parted!<span class="hljs-built_in"> Type </span><span class="hljs-string">&#x27;help&#x27;</span> <span class="hljs-keyword">to</span> view a list of commands.(parted) mklabel             # 创建磁盘分区标签(分区表类型)                                               New disk label type? msdos   # 选择msdos即MBR类型                                 # 上面的两步也可以直接一步进行：(parted) mklabel msdos      (parted) mkpart              # 开始进行分区     Partition type?  primary/extended? p     # 创建主分区File<span class="hljs-built_in"> system </span>type?  [ext2]? ext4          # 创建ext4文件系统                                         # (注意，这里虽然指明了文件系统，但没有任何意义，后面还是需要手动格式化并选择文件系统类型)Start? 1                                 # 分区开始位置，默认是M为单位，表示从1M开始，也可直接指定1G这种方式End? 1024                                # 分区结束位置，<span class="hljs-attribute">1024-1</span>=1023M(parted) p                   # print，查看分区信息Model: VMware, VMware Virtual S (scsi)Disk /dev/sdc: 21.5GBSector size (logical/physical): 512B/512BPartition Table: msdosNumber  Start   End     Size   <span class="hljs-built_in"> Type </span>    File<span class="hljs-built_in"> system </span> Flags 1      1049kB  1024MB  1023MB  primary<span class="hljs-comment"># 可以一步完成一个命令中的多个动作</span>(parted) mkpart p ext4 1026M 4096M       # 可以一步完成，也可以一步完成到任何位置，然后继续交互下一步                                         # 可能会提示分区未对齐<span class="hljs-string">&quot;Warning: The resulting partition is not properly aligned for best performance.&quot;</span>，忽略它(parted) mkpart e 4098 -1    # 创建扩展分区，注意创建扩展分区时不指定文件系统类型；-1表示剩余的全部分配给该分区(parted) p                                                               Model: VMware, VMware Virtual S (scsi)Disk /dev/sdc: 21.5GBSector size (logical/physical): 512B/512BPartition Table: msdos Number  Start   End     Size   <span class="hljs-built_in"> Type </span>     File<span class="hljs-built_in"> system </span> Flags 1      1049kB  1024MB  1023MB  primary 2      1026MB  4096MB  3070MB  primary 3      4098MB  21.5GB  17.4GB  extended               lba(parted) mkpart l ext4 4099 8194     # 创建逻辑分区，指定ext4(parted) mkpart l ext4 8195 -1       # 继续创建逻辑分区(parted) pModel: VMware, VMware Virtual S (scsi)Disk /dev/sdc: 21.5GBSector size (logical/physical): 512B/512BPartition Table: msdosNumber  Start   End     Size   <span class="hljs-built_in"> Type </span>     File<span class="hljs-built_in"> system </span> Flags 1      1049kB  1024MB  1023MB  primary 2      1026MB  4096MB  3070MB  primary 3      4098MB  21.5GB  17.4GB  extended               lba 5      4099MB  8194MB  4095MB  logical 6      8195MB  21.5GB  13.3GB  logical(parted) rm 5    # 删除5号分区(parted) pModel: VMware, VMware Virtual S (scsi)Disk /dev/sdc: 21.5GBSector size (logical/physical): 512B/512BPartition Table: msdosNumber  Start   End     Size   <span class="hljs-built_in"> Type </span>     File<span class="hljs-built_in"> system </span> Flags 1      1049kB  1024MB  1023MB  primary 2      1026MB  4096MB  3070MB  primary 3      4098MB  21.5GB  17.4GB  extended               lba 5      8195MB  21.5GB  13.3GB  logical(parted) quit                                    # 退出parted工具Information: You may need <span class="hljs-keyword">to</span> update /etc/fstab.  # 提示你要更新/etc/fstab中的配置，说明该工具是可以在线分区的</code></pre><p><font color=red>注：虽然parted工具中指定了文件系统，但是并没有意义，它仍需要手动进行格式化并指定分区类型。</font></p><h1 id="二、格式化分区"><a href="#二、格式化分区" class="headerlink" title="二、格式化分区"></a>二、格式化分区</h1><h2 id="2-1-mkfs-工具"><a href="#2-1-mkfs-工具" class="headerlink" title="2.1 mkfs 工具"></a>2.1 mkfs 工具</h2><p>mkfs命令通常用于在设备硬件分区上创建linux文件系统。mkfs 命令支持建立多种 Linux 文件系统，如 ext系列，xfs等等。实际上mkfs是支持多种文件系统构建命令<code>mkfs. TYPE</code>的前部分，mkfs命令通常执行的时候也是调用<code>mkfs. TYPE</code>来执行，如mkfs.ext2，mkfs.vfs，mkfs.vfat等等。</p><pre><code class="hljs css"><span class="hljs-selector-attr">[root@localhost ~]</span># <span class="hljs-selector-tag">mkfs</span><span class="hljs-selector-tag">mkfs</span>         <span class="hljs-selector-tag">mkfs</span><span class="hljs-selector-class">.btrfs</span>   <span class="hljs-selector-tag">mkfs</span><span class="hljs-selector-class">.cramfs</span>  <span class="hljs-selector-tag">mkfs</span><span class="hljs-selector-class">.ext2</span>    <span class="hljs-selector-tag">mkfs</span><span class="hljs-selector-class">.ext3</span>    <span class="hljs-selector-tag">mkfs</span><span class="hljs-selector-class">.ext4</span>    <span class="hljs-selector-tag">mkfs</span><span class="hljs-selector-class">.minix</span>   <span class="hljs-selector-tag">mkfs</span><span class="hljs-selector-class">.xfs</span></code></pre><h2 id="2-2-mke2fs-工具"><a href="#2-2-mke2fs-工具" class="headerlink" title="2.2 mke2fs 工具"></a>2.2 mke2fs 工具</h2><p>mkfs.ext2、mkfs.ext3、mkfs.ext4 或 mkfs -t extX 其实都是在调用mke2fs工具。</p><p>该工具创建文件系统时，会从 /etc/mke2fs.conf 配置中读取默认的配置项：</p><pre><code class="hljs mipsasm">mke<span class="hljs-symbol">2f</span>s [ -c ] [ -<span class="hljs-keyword">b </span><span class="hljs-keyword">block-size </span>] [ -f fragment-size ] [ -g <span class="hljs-keyword">blocks-per-group </span>] [ -G number-of-groups ]        [ -i <span class="hljs-keyword">bytes-per-inode </span>] [ -I inode-size ] [ -<span class="hljs-keyword">j </span>] [ -N number-of-inodes ] [ -m reserved-<span class="hljs-keyword">blocks-percentage </span>]        [ -q ] [ -r fs-revision-level ] [ -v ] [ -L volume-label ] [ -S ] [ -t fs-type ] device [ <span class="hljs-keyword">blocks-count </span>]选项说明：-t fs-type         ：指定要创建的文件系统类型(<span class="hljs-keyword">ext2,ext3 </span><span class="hljs-keyword">ext4)，若不指定，则从/etc/mke2fs.conf中获取默认的文件系统类型。</span><span class="hljs-keyword">-b </span><span class="hljs-keyword">block-size </span>     ：指定每个<span class="hljs-keyword">block的大小，有效值有1024、2048和4096，单位是字节。</span><span class="hljs-keyword">-I </span>inode-size      ：指定inode大小，单位为字节。必须为<span class="hljs-number">2</span>的幂次方，且大于等于<span class="hljs-number">128</span>字节。值越大，说明inode的集合体inode table占用越多的空                     间，这不仅会挤占文件系统中的可用空间，还会降低性能，因为要扫描inode table需要消耗更多时间，但是在linux kernel <span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">10</span>                     之后，由于使用inode存储了很多扩展的额外属性，所以<span class="hljs-number">128</span>字节已经不够用了，因此<span class="hljs-keyword">ext4默认的inode </span>size已经变为<span class="hljs-number">256</span>，尽管                     inode大小增大了，但因为使用inode存储扩展属性带来的性能提升远高于inode size变大导致的负面影响，所以仍建议使用<span class="hljs-number">256</span>字                     节的inode。-i <span class="hljs-keyword">bytes-per-inode </span>：指定每多少个字节就为其分配一个inode号。值越大，说明一个文件系统中分配的inode号越少，更适用于存储大量大文件，值越                     小，inode号越多，更适用于存储大量小文件。该值不能小于一个<span class="hljs-keyword">block的大小，因为这样会造成inode多余。</span><span class="hljs-keyword"> </span>                    注意，创建文件系统后该值就不能再改变了。-c                 ：创建文件系统前先检查设备是否有<span class="hljs-keyword">bad </span><span class="hljs-keyword">blocks。</span><span class="hljs-keyword">-f </span>fragment-size   ：指定fragments的大小，单位字节。-g <span class="hljs-keyword">blocks-per-group：指定每个块组中的block数量。不建议修改此项。</span><span class="hljs-keyword">-G </span>number-of-groups：该选项用于<span class="hljs-keyword">ext4文件系统(严格地说是启用了flex_bg特性)，指定虚拟块组(即一个extent)中包含的块组个数，必须为2的幂次方。</span><span class="hljs-keyword"> </span>                    对于<span class="hljs-keyword">ext4文件系统来说，使用extent的功能能极大提升其性能。</span><span class="hljs-keyword">-j </span>                ：创建带有日志功能的文件系统，即<span class="hljs-keyword">ext3。如果要指定关于日志方面的设置，在-j的基础上再使用-J指定，不过一般默认即可，具体可</span><span class="hljs-keyword"> </span>                    指定的选项看man文档。 -L new-volume-label：指定卷标名称，名称不得超出<span class="hljs-number">16</span>字节。-m reserved-<span class="hljs-keyword">blocks-percentage：指定文件系统保留block数量的比例，保留一部分block，可以降低物理碎片。默认比例为5%。</span><span class="hljs-keyword">-N </span>number-of-inodes ：强制指定该文件系统应该分配多少个inode号，它会覆盖通过计算得出inode数量的结果(根据<span class="hljs-keyword">block大小、数量和每多少字节分配</span><span class="hljs-keyword"> </span>                     一个inode得出Inode数量)，但是不建议这么做。-q                  ：安静模式，可用于脚本中-S                  ：重建superblock和group descriptions。在所有的superblock和备份的superblock都损坏时有用。它会重新初始化superblock和                      group descriptions，但不会改变inode table、<span class="hljs-keyword">bmap和imap(若真的改变，该分区数据就全丢了，还不如重新格式化)。在重建</span><span class="hljs-keyword"> </span>                     superblock后，应该执行e<span class="hljs-symbol">2f</span>sck来保证文件系统的一致性。但要注意，应该完全正确地指定<span class="hljs-keyword">block的大小，其改选项并不能完全保</span><span class="hljs-keyword"> </span>                     证数据不丢失。-v                  ：输出详细执行过程</code></pre><p><strong>所以，有可能用到的选项也就 “-t” 指定文件系统类型，”-b” 指定 block 大小，”-I” 指定 inode 大小，”-i” 指定分配 inode 的比例。</strong></p><p>例如：</p><pre><code class="hljs routeros">[root@localhost ~]# mke2fs -t ext4 -I 256 /dev/sdb2 -b 4096mke2fs 1.41.12 (17-May-2010)Filesystem label=OS type: LinuxBlock <span class="hljs-attribute">size</span>=4096 (<span class="hljs-attribute">log</span>=2)Fragment <span class="hljs-attribute">size</span>=4096 (<span class="hljs-attribute">log</span>=2)<span class="hljs-attribute">Stride</span>=0 blocks, Stripe <span class="hljs-attribute">width</span>=0 blocks655360 inodes, 2621440 blocks131072 blocks (5.00%) reserved <span class="hljs-keyword">for</span> the super userFirst data <span class="hljs-attribute">block</span>=0Maximum filesystem <span class="hljs-attribute">blocks</span>=268435456080 block groups32768 blocks per group, 32768 fragments per group8192 inodes per groupSuperblock backups stored on blocks:        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632Writing inode tables: done                           Creating journal (32768 blocks): doneWriting superblocks <span class="hljs-keyword">and</span> filesystem<span class="hljs-built_in"> accounting </span>information: doneThis filesystem will be automatically checked every 39 mounts <span class="hljs-keyword">or</span>180 days, whichever comes first.  Use tune2fs -c <span class="hljs-keyword">or</span> -i <span class="hljs-keyword">to</span> override.</code></pre><h1 id="三、查看文件系统状态信息"><a href="#三、查看文件系统状态信息" class="headerlink" title="三、查看文件系统状态信息"></a>三、查看文件系统状态信息</h1><h2 id="3-1-lsblk-list-block-devices"><a href="#3-1-lsblk-list-block-devices" class="headerlink" title="3.1 lsblk(list block devices)"></a>3.1 lsblk(list block devices)</h2><blockquote><p>用于列出设备及其状态，主要列出非空的存储设备。其实它只会列出/sys/dev/block中的主次设备号文件，且默认只列出非空设备。</p></blockquote><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# lsblkNAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda               <span class="hljs-number">8</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>   <span class="hljs-number">20</span>G  <span class="hljs-number">0</span> disk ├─sda1            <span class="hljs-number">8</span>:<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>G  <span class="hljs-number">0</span> part /boot└─sda2            <span class="hljs-number">8</span>:<span class="hljs-number">2</span>    <span class="hljs-number">0</span>   <span class="hljs-number">19</span>G  <span class="hljs-number">0</span> part   ├─centos-root <span class="hljs-number">253</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>   <span class="hljs-number">17</span>G  <span class="hljs-number">0</span> lvm  /  └─centos-swap <span class="hljs-number">253</span>:<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">2</span>G  <span class="hljs-number">0</span> lvm  [SWAP]sdb               <span class="hljs-number">8</span>:<span class="hljs-number">16</span>   <span class="hljs-number">0</span>  <span class="hljs-number">1.8</span>T  <span class="hljs-number">0</span> disk └─sdb1            <span class="hljs-number">8</span>:<span class="hljs-number">17</span>   <span class="hljs-number">0</span>  <span class="hljs-number">1.8</span>T  <span class="hljs-number">0</span> part sr0              <span class="hljs-number">11</span>:<span class="hljs-number">0</span>    <span class="hljs-number">1</span>  <span class="hljs-number">4.5</span>G  <span class="hljs-number">0</span> rom</code></pre><p>其中上面的几列意义如下：</p><p>NAME：设备名称；</p><p>MAJ:MIN：主设备号和此设备号；</p><p>RM：是否为可卸载设备，1表示可卸载设备。可卸载设备如光盘、USB等。并非能够umount的就是可卸载的；</p><p>SIZE：设备总空间大小；</p><p>RO：是否为只读；</p><p>TYPE：是磁盘disk，还是分区part，亦或是rom，还有loop设备；</p><p>mountpoint：挂载点。</p><p>另外常用的一个选项是”-f”，它可以查看到文件系统类型，和文件系统的uuid和挂载点：</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# lsblk -fNAME            FSTYPE      LABEL           UUID                                   MOUNTPOINTsda                                                                                ├─sda1          xfs                         <span class="hljs-number">39</span>b6f37f<span class="hljs-number">-531f</span><span class="hljs-number">-41</span>c2-a498-dbe216fcfc4b   /boot└─sda2          LVM2_member                 BVd9cM-wbZz-QBn3<span class="hljs-number">-8</span>IOg-A8Xc-NZ5w-u98gYr   ├─centos-root xfs                         <span class="hljs-number">0</span>a8b095d<span class="hljs-number">-743e-494</span>b-a4e3<span class="hljs-number">-1</span>dca4211d9bb   /  └─centos-swap swap                        b83b56ce<span class="hljs-number">-37f</span>2<span class="hljs-number">-460</span>a-bbd1<span class="hljs-number">-8</span>d4da4624493   [SWAP]sdb                                                                                └─sdb1          ext4                        <span class="hljs-number">2</span>bc92060-a128<span class="hljs-number">-4</span>ad5-bfbe<span class="hljs-number">-9</span>cfb61dc1870   sr0             iso9660     CentOS <span class="hljs-number">7</span> x86_64 <span class="hljs-number">2020</span><span class="hljs-number">-04</span><span class="hljs-number">-22</span><span class="hljs-number">-00</span><span class="hljs-number">-54</span><span class="hljs-number">-00</span><span class="hljs-number">-00</span></code></pre><p><font color=red>注：每个已经格式化的文件系统都有其类型和uuid，而没有格式化的设备(如/dev/sdb3)，将只显示一个Name结果，表示该设备还未进行格式化。</font></p><h2 id="3-2-blkid"><a href="#3-2-blkid" class="headerlink" title="3.2 blkid"></a>3.2 blkid</h2><p>查看文件系统类型和uuid：</p><pre><code class="hljs routeros">[root@localhost ~]# blkid/dev/sr0: <span class="hljs-attribute">UUID</span>=<span class="hljs-string">&quot;2020-04-22-00-54-00-00&quot;</span> <span class="hljs-attribute">LABEL</span>=<span class="hljs-string">&quot;CentOS 7 x86_64&quot;</span> <span class="hljs-attribute">TYPE</span>=<span class="hljs-string">&quot;iso9660&quot;</span> <span class="hljs-attribute">PTTYPE</span>=<span class="hljs-string">&quot;dos&quot;</span> /dev/sda1: <span class="hljs-attribute">UUID</span>=<span class="hljs-string">&quot;39b6f37f-531f-41c2-a498-dbe216fcfc4b&quot;</span> <span class="hljs-attribute">TYPE</span>=<span class="hljs-string">&quot;xfs&quot;</span> /dev/sda2: <span class="hljs-attribute">UUID</span>=<span class="hljs-string">&quot;BVd9cM-wbZz-QBn3-8IOg-A8Xc-NZ5w-u98gYr&quot;</span> <span class="hljs-attribute">TYPE</span>=<span class="hljs-string">&quot;LVM2_member&quot;</span> /dev/mapper/centos-root: <span class="hljs-attribute">UUID</span>=<span class="hljs-string">&quot;0a8b095d-743e-494b-a4e3-1dca4211d9bb&quot;</span> <span class="hljs-attribute">TYPE</span>=<span class="hljs-string">&quot;xfs&quot;</span> /dev/mapper/centos-swap: <span class="hljs-attribute">UUID</span>=<span class="hljs-string">&quot;b83b56ce-37f2-460a-bbd1-8d4da4624493&quot;</span> <span class="hljs-attribute">TYPE</span>=<span class="hljs-string">&quot;swap&quot;</span> /dev/sdb1: <span class="hljs-attribute">UUID</span>=<span class="hljs-string">&quot;2bc92060-a128-4ad5-bfbe-9cfb61dc1870&quot;</span> <span class="hljs-attribute">TYPE</span>=<span class="hljs-string">&quot;ext4&quot;</span></code></pre><h2 id="3-3-du"><a href="#3-3-du" class="headerlink" title="3.3 du"></a>3.3 du</h2><blockquote><p>du命令用于评估文件的空间占用情况，它会统计每个文件的大小，统计时会递归统计目录中的文件，也就是说，它会遍历整个待统计目录，所以统计速度上可能并不理想。</p></blockquote><pre><code class="hljs jboss-cli">du [OPTION]<span class="hljs-string">...</span> [FILE]<span class="hljs-string">...</span>选项说明：-a, <span class="hljs-params">--all</span>：列出目录中所有文件的统计信息，默认只会列出目录中子目录的统计信息，而不列出文件的统计信息-h, <span class="hljs-params">--human-readable</span>：人性化显示大小-0, <span class="hljs-params">--null</span>：以空字符结尾，即<span class="hljs-string">&quot;\0&quot;</span>而非换行的<span class="hljs-string">&quot;\n&quot;</span>-S, <span class="hljs-params">--separate-dirs</span>：不包含子目录的大小-s, <span class="hljs-params">--summarize</span>：对目录做总的统计，不列出目录内文件的大小信息-c,<span class="hljs-params">--total</span>：对给出的文件或目录做总计。在统计非同一个目录文件大小时非常有用。见下文例子。-d,<span class="hljs-params">--max-depth</span>：指定显示时的目录深度，默认会递归显示所有层次<span class="hljs-params">--max-depth=N</span>：只列出给定层次的目录统计，如果N=0，则等价于<span class="hljs-string">&quot;-s&quot;</span>-x, <span class="hljs-params">--one-file-system</span>：忽略不同文件系统上的文件，不对它们进行统计-X, <span class="hljs-params">--exclude-from=FILE</span>：从文件中读取要排除的文件<span class="hljs-params">--exclude=PATTERN</span>：指定要忽略不统计的文件</code></pre><pre><code class="hljs gradle">[root@localhost ~]# du -sh <span class="hljs-regexp">/etc/</span><span class="hljs-number">35</span>M     <span class="hljs-regexp">/etc/</span></code></pre><pre><code class="hljs gradle">[root@localhost ~]# du -ah <span class="hljs-regexp">/tmp/</span><span class="hljs-number">0</span>       <span class="hljs-regexp">/tmp/</span>.Test-unix<span class="hljs-number">0</span>       <span class="hljs-regexp">/tmp/</span>.font-unix<span class="hljs-number">0</span>       <span class="hljs-regexp">/tmp/</span>.ICE-unix<span class="hljs-number">0</span>       <span class="hljs-regexp">/tmp/</span>.XIM-unix<span class="hljs-number">0</span>       <span class="hljs-regexp">/tmp/</span>.X11-unix<span class="hljs-number">4.0</span>K    <span class="hljs-regexp">/tmp/</span>oraysl.status<span class="hljs-number">4.0</span>K    <span class="hljs-regexp">/tmp/</span>oraynewph.status<span class="hljs-number">0</span>       <span class="hljs-regexp">/tmp/</span>systemd-<span class="hljs-keyword">private</span>-dd51c630d55b47ac953c22e69a6c1240-mariadb.service-jPbRmD/tmp<span class="hljs-number">0</span>       <span class="hljs-regexp">/tmp/</span>systemd-<span class="hljs-keyword">private</span>-dd51c630d55b47ac953c22e69a6c1240-mariadb.service-jPbRmD<span class="hljs-number">8.0</span>K    <span class="hljs-regexp">/tmp/</span></code></pre><h2 id="3-4-df"><a href="#3-4-df" class="headerlink" title="3.4 df"></a>3.4 df</h2><p>df 用于报告磁盘空间使用率，默认显示的大小是1K大小block数量，也就是以k为单位。</p><p>和 du 不同的是，df 是读取每个文件系统的 superblock 信息，所以评估速度非常快。由于是读取 superblock，所以如果目录下挂载了另一个文件系统，是不会将此挂载的文件系统计入目录大小的。<strong>注意，du 和 df 统计的结果是不一样的。</strong></p><p>如果用 df 统计某个文件的空间使用情况，将会转而统计该文件所在文件系统的空间使用情况。</p><pre><code class="hljs angelscript">df [OPTION]... [FILE]...选项说明：-h：人性化转换大小的显示单位-i：统计inode使用情况而非空间使用情况-l, --local：只列出本地文件系统的使用情况，不列出网络文件系统信息-T, --print-type：同时输出文件系统类型-t, --type=TYPE：只列出给定文件系统的统计信息-x, --exclude-type=TYPE：指定不显示的文件系统类型的统计信息[<span class="hljs-symbol">root@</span>localhost ~]# df -hT文件系统                类型      容量  已用  可用 已用% 挂载点devtmpfs                devtmpfs  <span class="hljs-number">908</span>M     <span class="hljs-number">0</span>  <span class="hljs-number">908</span>M    <span class="hljs-number">0</span>% /devtmpfs                   tmpfs     <span class="hljs-number">919</span>M     <span class="hljs-number">0</span>  <span class="hljs-number">919</span>M    <span class="hljs-number">0</span>% /dev/shmtmpfs                   tmpfs     <span class="hljs-number">919</span>M   <span class="hljs-number">33</span>M  <span class="hljs-number">887</span>M    <span class="hljs-number">4</span>% /runtmpfs                   tmpfs     <span class="hljs-number">919</span>M     <span class="hljs-number">0</span>  <span class="hljs-number">919</span>M    <span class="hljs-number">0</span>% /sys/fs/cgroup/dev/mapper/centos-root xfs        <span class="hljs-number">17</span>G  <span class="hljs-number">2.4</span>G   <span class="hljs-number">15</span>G   <span class="hljs-number">14</span>% //dev/sda1               xfs      <span class="hljs-number">1014</span>M  <span class="hljs-number">211</span>M  <span class="hljs-number">804</span>M   <span class="hljs-number">21</span>% /boottmpfs                   tmpfs     <span class="hljs-number">184</span>M     <span class="hljs-number">0</span>  <span class="hljs-number">184</span>M    <span class="hljs-number">0</span>% /run/user/<span class="hljs-number">0</span>[<span class="hljs-symbol">root@</span>localhost ~]# df -i文件系统                  Inode 已用(I) 可用(I) 已用(I)% 挂载点devtmpfs                 <span class="hljs-number">232254</span>     <span class="hljs-number">405</span>  <span class="hljs-number">231849</span>       <span class="hljs-number">1</span>% /devtmpfs                    <span class="hljs-number">235193</span>       <span class="hljs-number">1</span>  <span class="hljs-number">235192</span>       <span class="hljs-number">1</span>% /dev/shmtmpfs                    <span class="hljs-number">235193</span>     <span class="hljs-number">542</span>  <span class="hljs-number">234651</span>       <span class="hljs-number">1</span>% /runtmpfs                    <span class="hljs-number">235193</span>      <span class="hljs-number">16</span>  <span class="hljs-number">235177</span>       <span class="hljs-number">1</span>% /sys/fs/cgroup/dev/mapper/centos-root <span class="hljs-number">8910848</span>   <span class="hljs-number">78419</span> <span class="hljs-number">8832429</span>       <span class="hljs-number">1</span>% //dev/sda1                <span class="hljs-number">524288</span>     <span class="hljs-number">339</span>  <span class="hljs-number">523949</span>       <span class="hljs-number">1</span>% /boottmpfs                    <span class="hljs-number">235193</span>       <span class="hljs-number">1</span>  <span class="hljs-number">235192</span>       <span class="hljs-number">1</span>% /run/user/<span class="hljs-number">0</span></code></pre><h1 id="四、挂载和卸载文件系统"><a href="#四、挂载和卸载文件系统" class="headerlink" title="四、挂载和卸载文件系统"></a>四、挂载和卸载文件系统</h1><h2 id="4-1-mount"><a href="#4-1-mount" class="headerlink" title="4.1 mount"></a>4.1 mount</h2><blockquote><p>mount用来显示挂载信息或者进行文件系统挂载，它的功能及其的强大(强大到离谱)，它不仅支持挂载非常多种文件系统，如ext/xfs/nfs/smbfs/cifs (win上的共享目录)等，还支持共享挂载点、继承挂载点(父子关系)、绑定挂载点、移动挂载点等等功能。在本文只介绍其最简单的挂载功能。</p></blockquote><pre><code class="hljs routeros">mount # 将显示当前已挂载信息mount [-t 欲挂载文件系统类型 ] [-o 特殊选项] 设备名 挂载目录选项说明：-a  将/etc/fstab文件里指定的挂载选项重新挂载一遍。-t  支持ext2/ext3/ext4/vfat/fat/iso9660(光盘默认格式)。 不用-t时默认会调用blkid来获取文件系统类型。-n  不把挂载记录写在/etc/mtab文件中，一般挂载会在/proc/mounts中记录下挂载信息，然后同步到/etc/mtab，指定-n表示不同步该挂载信息。-o  指定挂载特殊选项。下面是两个比较常用的：    loop  挂载镜像文件，如iso文件    ro  只读挂载    rw  读写挂载    auto  相当于mount -a    dev 如果挂载的文件系统中有设备访问入口则启用它，使其可以作为设备访问入口   <span class="hljs-built_in"> default </span>rw,suid,dev,exec,auto,nouser,async,<span class="hljs-keyword">and</span> relatime    async   异步挂载，只写到内存    sync    同步挂载，通过挂载位置写入对方硬盘    atime   修改访问时间，每次访问都修改atime会导致性能降低，所以默认是noatime    noatime 不修改访问时间，高并发时使用这个选项可以减少磁盘IO    nodiratime  不修改文件夹访问时间，高并发时使用这个选项可以减少磁盘IO    exec/noexec  挂载后的文件系统里的可执行程序是否可执行，默认是可以执行exec， 优先级高于权限的限定    remount  重新挂载，此时可以不用指定挂载点。    suid/nosuid 对挂载的文件系统启用或禁用suid，对于外来设备最好禁用suid    _netdev 需要网络挂载时默认将停留在挂载界面直到加载网络了。使用_netdev可以忽略网络正常挂载。如NFS开机挂载。   <span class="hljs-built_in"> user </span> 允许普通用户进行挂载该目录，但只允许挂载者进行卸载该目录   <span class="hljs-built_in"> users </span> 允许所有用户挂载和卸载该目录    nouser  禁止普通用户挂载和卸载该目录，这是默认的，默认情况下一个目录不指定user/users时，将只有root能挂载</code></pre><p>使用实例：</p><p><strong>(1).挂载CentOS的安装镜像到/mnt。</strong></p><pre><code class="hljs awk">mount <span class="hljs-regexp">/dev/</span>cdrom /mnt</code></pre><p><strong>(2).重新挂载。</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">mount</span> -t ext<span class="hljs-number">4</span> -o remount /dev/sdb<span class="hljs-number">1</span> /data<span class="hljs-number">1</span></code></pre><p><strong>(3).重新挂载文件系统为可读写</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">mount</span> -t ext<span class="hljs-number">4</span> -o rw remount /dev/sdb<span class="hljs-number">1</span> /data<span class="hljs-number">1</span></code></pre><p><strong>(4).挂载windows的共享目录。</strong></p><p>win上共享文件的文件系统是cifs类型，要在Linux上挂载，必须得有mount.cifs命令，如果没有则安装cifs-utils包。</p><p>假设win上共享目录的unc路径为\192.168.100.8\test，共享给的用户名和密码分别为long3:123，要挂在linux上的/mydata目录上。</p><pre><code class="hljs awk">mount.cifs -o username=<span class="hljs-string">&quot;long3&quot;</span>,password=<span class="hljs-string">&quot;123&quot;</span> <span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">100.8</span><span class="hljs-regexp">/test /my</span>data</code></pre><p>注意，如果是比较新版本的win10(2017年之后更新的版本)或较新版本的win server，直接mount.cifs会报错：</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# mount.cifs -o username=<span class="hljs-string">&quot;long3&quot;</span>,password=<span class="hljs-string">&quot;123&quot;</span> <span class="hljs-comment">//192.168.100.8/test /mnt         </span>mount error(<span class="hljs-number">112</span>): Host <span class="hljs-keyword">is</span> downRefer to the mount.cifs(<span class="hljs-number">8</span>) manual page (e.g. man mount.cifs)</code></pre><p>这是因为2017年微软的一个补丁禁用了SMBv1协议，通过smbclient的报告可知：</p><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># yum -y install samba-client</span>[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># smbclient -L //192.168.100.8</span>Enter root<span class="hljs-string">&#x27;s password: </span><span class="hljs-string">protocol negotiation failed: NT_STATUS_CONNECTION_RESET</span></code></pre><p>因此，在mount的时候指定cifs(SMB)的版本号为2.0即可：</p><pre><code class="hljs cpp">[root@localhost ~]<span class="hljs-meta"># mount.cifs -o username=<span class="hljs-meta-string">&quot;long3&quot;</span>,password=<span class="hljs-meta-string">&quot;123&quot;</span>,vers=2.0 <span class="hljs-comment">//192.168.100.8/test /mnt</span></span></code></pre><h2 id="4-2-挂载镜像文件"><a href="#4-2-挂载镜像文件" class="headerlink" title="4.2 挂载镜像文件"></a>4.2 挂载镜像文件</h2><p>有时候需要挂载CentOS的镜像文件，在虚拟机中经常是将镜像放入虚拟机的CD/DVD虚拟光驱中，然后在Linux上对/dev/cdrom进行挂载。其实/dev/cdrom是/dev/sr0的一个软链接，/dev/sr0是Linux中的光驱，所以上面的过程相当于是将镜像文件通过虚拟软件的虚拟光驱和linux的光驱连接起来，这样只需要挂载Linux中的光驱就可以了。但是，在非虚拟环境中没有虚拟光驱，而且在Linux中的一个镜像文件难道一定要拷贝到主机上通过虚拟光驱进行连接吗？</p><p>mount是一个极其强大的挂载工具，它支持挂载很多种文件类型，其中就支持挂载镜像文件，其实它连挂载目录都支持。</p><pre><code class="hljs angelscript">mount -o loop CentOS<span class="hljs-number">-6.6</span>-x86_64-bin-DVD2.iso /mnt[<span class="hljs-symbol">root@</span>localhost ~]# lsblkNAME     MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTloop0      <span class="hljs-number">7</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>   <span class="hljs-number">1.2</span>G  <span class="hljs-number">0</span> loop /mntsda        <span class="hljs-number">8</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">20</span>G  <span class="hljs-number">0</span> disk├─sda1   <span class="hljs-number">8</span>:<span class="hljs-number">1</span>    <span class="hljs-number">0</span>   <span class="hljs-number">250</span>M  <span class="hljs-number">0</span> part /boot├─sda2   <span class="hljs-number">8</span>:<span class="hljs-number">2</span>    <span class="hljs-number">0</span>  <span class="hljs-number">17.8</span>G  <span class="hljs-number">0</span> part /└─sda3   <span class="hljs-number">8</span>:<span class="hljs-number">3</span>    <span class="hljs-number">0</span>     <span class="hljs-number">2</span>G  <span class="hljs-number">0</span> part [SWAP]sr0       <span class="hljs-number">11</span>:<span class="hljs-number">0</span>    <span class="hljs-number">1</span>  <span class="hljs-number">1024</span>M  <span class="hljs-number">0</span> rom</code></pre><h2 id="4-3-umount"><a href="#4-3-umount" class="headerlink" title="4.3 umount"></a>4.3 umount</h2><pre><code class="hljs properties"><span class="hljs-attr">umount</span> <span class="hljs-string">设备名或挂载目录</span><span class="hljs-attr">umount</span> <span class="hljs-string">-lf 强制卸载</span></code></pre><h2 id="4-4-开机自动挂载-etc-fstab"><a href="#4-4-开机自动挂载-etc-fstab" class="headerlink" title="4.4 开机自动挂载/etc/fstab"></a>4.4 开机自动挂载/etc/fstab</h2><p>通过将挂载选项写入到 /etc/fstab 中，系统会自动挂载该文件中的配置项。但要注意，该文件在开机的前几个过程中就被读取，所以配置错误很可能会导致开机失败。</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# cat /etc/fstab ## /etc/fstab# Created by anaconda on Sat Jun  <span class="hljs-number">6</span> <span class="hljs-number">20</span>:<span class="hljs-number">09</span>:<span class="hljs-number">07</span> <span class="hljs-number">2020</span>## Accessible filesystems, by <span class="hljs-built_in">ref</span>erence, are maintained under <span class="hljs-string">&#x27;/dev/disk&#x27;</span># See man pages fstab(<span class="hljs-number">5</span>), findfs(<span class="hljs-number">8</span>), mount(<span class="hljs-number">8</span>) <span class="hljs-keyword">and</span>/<span class="hljs-keyword">or</span> blkid(<span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> more info#/dev/mapper/centos-root /                       xfs     defaults        <span class="hljs-number">0</span> <span class="hljs-number">0</span>UUID=<span class="hljs-number">39</span>b6f37f<span class="hljs-number">-531f</span><span class="hljs-number">-41</span>c2-a498-dbe216fcfc4b /boot                   xfs     defaults        <span class="hljs-number">0</span> <span class="hljs-number">0</span>/dev/mapper/centos-swap swap                    swap    defaults        <span class="hljs-number">0</span> <span class="hljs-number">0</span></code></pre><p>其中最后两列，它们分别表示备份文件系统和开机自检，一般都可以设置为0。</p><p>由于能用的备份工具众多，没人会在这里设置备份，所以备份列设置为0。</p><p>最后一列是开机自检设置列，开机自检调用的是fsck程序，所有有些ext类文件系统作为”/“时，可能会设置为1，但是fsck是不支持xfs文件系统的，所以对于xfs文件系统而言，该项必须设置为0。</p><p>其实无需考虑那么多，直接将这两列设置为0就可以了。</p><h2 id="4-5-修复错误的-etc-fstab"><a href="#4-5-修复错误的-etc-fstab" class="headerlink" title="4.5 修复错误的/etc/fstab"></a>4.5 修复错误的/etc/fstab</h2><p>万一 /etc/fstab 配置错误，导致开机无法加载。这时提示输入 root 密码进入单人维护模式，只不过单人模式下根文件系统是只读的，哪怕是 root 也无法直接修改 /etc/fstab，所以应该将”/“文件系统进行重新挂载。</p><p>执行下面的命令，重挂载根分区，并给读写权限，再去修改错误的 fstab 文件记录，再重启。</p><pre><code class="hljs excel">mount -<span class="hljs-built_in">n</span> -o remount,rw /</code></pre><h1 id="五、SWAP-分区"><a href="#五、SWAP-分区" class="headerlink" title="五、SWAP 分区"></a>五、SWAP 分区</h1><h2 id="5-1-查看哪个分区在充当-swap-分区"><a href="#5-1-查看哪个分区在充当-swap-分区" class="headerlink" title="5.1 查看哪个分区在充当 swap 分区"></a>5.1 查看哪个分区在充当 swap 分区</h2><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# lsblkNAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda               <span class="hljs-number">8</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>   <span class="hljs-number">20</span>G  <span class="hljs-number">0</span> disk ├─sda1            <span class="hljs-number">8</span>:<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>G  <span class="hljs-number">0</span> part /boot└─sda2            <span class="hljs-number">8</span>:<span class="hljs-number">2</span>    <span class="hljs-number">0</span>   <span class="hljs-number">19</span>G  <span class="hljs-number">0</span> part   ├─centos-root <span class="hljs-number">253</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>   <span class="hljs-number">17</span>G  <span class="hljs-number">0</span> lvm  /  └─centos-swap <span class="hljs-number">253</span>:<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">2</span>G  <span class="hljs-number">0</span> lvm  [SWAP]sdb               <span class="hljs-number">8</span>:<span class="hljs-number">16</span>   <span class="hljs-number">0</span>  <span class="hljs-number">1.8</span>T  <span class="hljs-number">0</span> disk └─sdb1            <span class="hljs-number">8</span>:<span class="hljs-number">17</span>   <span class="hljs-number">0</span>  <span class="hljs-number">1.8</span>T  <span class="hljs-number">0</span> part sr0              <span class="hljs-number">11</span>:<span class="hljs-number">0</span>    <span class="hljs-number">1</span>  <span class="hljs-number">4.5</span>G  <span class="hljs-number">0</span> rom [<span class="hljs-symbol">root@</span>localhost ~]# swapon  -s文件名                          类型            大小    已用    权限/dev/dm<span class="hljs-number">-1</span>                               partition       <span class="hljs-number">2097148</span> <span class="hljs-number">0</span>       <span class="hljs-number">-2</span></code></pre><h2 id="5-2-添加-swap-分区"><a href="#5-2-添加-swap-分区" class="headerlink" title="5.2 添加 swap 分区"></a>5.2 添加 swap 分区</h2><p>(1).可以新分一个区，在分区时指定其分区的ID号为SWAP类型。</p><p>(2).格式化为swap分区：mkswap</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>localhost ~]# mkswap /dev/sdb5Setting up swapspace version <span class="hljs-number">1</span>, size = <span class="hljs-number">1951096</span> KiBno label, UUID=<span class="hljs-number">02e5</span>af44<span class="hljs-number">-2</span>a16<span class="hljs-number">-479</span>d-b689<span class="hljs-number">-4e100</span>af6adf5</code></pre><p>(3).加入swap分区空间(swapon)：</p><pre><code class="hljs yaml">[<span class="hljs-string">root@localhost</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># swapon /dev/sdb5  </span>[<span class="hljs-string">root@localhost</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># free -m</span>             <span class="hljs-string">total</span>       <span class="hljs-string">used</span>       <span class="hljs-string">free</span>     <span class="hljs-string">shared</span>    <span class="hljs-string">buffers</span>     <span class="hljs-string">cached</span><span class="hljs-attr">Mem:</span>          <span class="hljs-number">1861        </span><span class="hljs-number">343</span>       <span class="hljs-number">1517          </span><span class="hljs-number">0</span>         <span class="hljs-number">16</span>        <span class="hljs-number">196</span><span class="hljs-string">-/+</span> <span class="hljs-attr">buffers/cache:</span>        <span class="hljs-number">131</span>       <span class="hljs-number">1730</span><span class="hljs-attr">Swap:</span>         <span class="hljs-number">3953          </span><span class="hljs-number">0</span>       <span class="hljs-number">3953</span></code></pre><p>(4).取消swap分区空间(swapoff)：</p><pre><code class="hljs yaml">[<span class="hljs-string">root@xuexi</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># swapoff /dev/sdb5</span>[<span class="hljs-string">root@xuexi</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># free -m</span>             <span class="hljs-string">total</span>       <span class="hljs-string">used</span>       <span class="hljs-string">free</span>     <span class="hljs-string">shared</span>    <span class="hljs-string">buffers</span>     <span class="hljs-string">cached</span><span class="hljs-attr">Mem:</span>          <span class="hljs-number">1861        </span><span class="hljs-number">343</span>       <span class="hljs-number">1518          </span><span class="hljs-number">0</span>         <span class="hljs-number">16</span>        <span class="hljs-number">196</span><span class="hljs-string">-/+</span> <span class="hljs-attr">buffers/cache:</span>        <span class="hljs-number">130</span>       <span class="hljs-number">1731</span><span class="hljs-attr">Swap:</span>            <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span></code></pre><p>(5).开机自动加载swap分区：</p><p>修改/etc/fstab，加上一行</p><pre><code class="hljs angelscript">/dev/sda5    swap    swap    defaults    <span class="hljs-number">0</span>    <span class="hljs-number">0</span></code></pre><blockquote><p>学习于[<a href="https://www.cnblogs.com/f-ck-need-u/">骏马金龙</a>]</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 系统启动详细流程</title>
    <link href="/2020/06/01/Linux_boot/"/>
    <url>/2020/06/01/Linux_boot/</url>
    
    <content type="html"><![CDATA[<p>POST –&gt; BIOS(Boot Sequence 启动顺序) –&gt; <a href="https://ecarry.cc/2020/06/09/Linux_part/">MBR</a>(Bootloader,446) –&gt; Kernel –&gt; initrd(init ram disk,Linux初始RAM磁盘) –&gt; /sbin/init </p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 简单内核优化</title>
    <link href="/2020/05/13/kernel_modify/"/>
    <url>/2020/05/13/kernel_modify/</url>
    
    <content type="html"><![CDATA[<h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>ulimit 为 shell 内建指令，可用来控制shell执行程序的资源。</p><pre><code class="hljs less"><span class="hljs-selector-attr">[root@localhost ~]</span># <span class="hljs-selector-tag">ulimit</span> <span class="hljs-selector-tag">-a</span><span class="hljs-selector-tag">core</span> <span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">size</span>          (blocks, -c) <span class="hljs-selector-tag">0</span><span class="hljs-selector-tag">data</span> <span class="hljs-selector-tag">seg</span> <span class="hljs-selector-tag">size</span>           (kbytes, -d) <span class="hljs-selector-tag">unlimited</span><span class="hljs-selector-tag">scheduling</span> <span class="hljs-selector-tag">priority</span>             (-e) <span class="hljs-selector-tag">0</span><span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">size</span>               (blocks, -f) <span class="hljs-selector-tag">unlimited</span><span class="hljs-selector-tag">pending</span> <span class="hljs-selector-tag">signals</span>                 (-i) <span class="hljs-selector-tag">7257</span><span class="hljs-selector-tag">max</span> <span class="hljs-selector-tag">locked</span> <span class="hljs-selector-tag">memory</span>       (kbytes, -l) <span class="hljs-selector-tag">64</span><span class="hljs-selector-tag">max</span> <span class="hljs-selector-tag">memory</span> <span class="hljs-selector-tag">size</span>         (kbytes, -m) <span class="hljs-selector-tag">unlimited</span><span class="hljs-selector-tag">open</span> <span class="hljs-selector-tag">files</span>                      (-n) <span class="hljs-selector-tag">1024</span><span class="hljs-selector-tag">pipe</span> <span class="hljs-selector-tag">size</span>            (<span class="hljs-number">512</span> bytes, -p) <span class="hljs-selector-tag">8</span><span class="hljs-selector-tag">POSIX</span> <span class="hljs-selector-tag">message</span> <span class="hljs-selector-tag">queues</span>     (bytes, -q) <span class="hljs-selector-tag">819200</span><span class="hljs-selector-tag">real-time</span> <span class="hljs-selector-tag">priority</span>              (-r) <span class="hljs-selector-tag">0</span><span class="hljs-selector-tag">stack</span> <span class="hljs-selector-tag">size</span>              (kbytes, -s) <span class="hljs-selector-tag">8192</span><span class="hljs-selector-tag">cpu</span> <span class="hljs-selector-tag">time</span>               (seconds, -t) <span class="hljs-selector-tag">unlimited</span><span class="hljs-selector-tag">max</span> <span class="hljs-selector-tag">user</span> <span class="hljs-selector-tag">processes</span>              (-u) <span class="hljs-selector-tag">7257</span><span class="hljs-selector-tag">virtual</span> <span class="hljs-selector-tag">memory</span>          (kbytes, -v) <span class="hljs-selector-tag">unlimited</span><span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">locks</span>                      (-x) <span class="hljs-selector-tag">unlimited</span></code></pre><a id="more"></a><h2 id="core-file-size"><a href="#core-file-size" class="headerlink" title="core file size"></a>core file size</h2><p>core 文件其实就是内存的映像，当程序崩溃时，存储内存的相应信息，主用用于对程序进行调试。当程序崩溃时便会产生 core 文件，其实准确的应该说是 core dump 文件,默认生成位置与可执行程序位于同一目录下，文件名为 core.*** ，其中***为数字。</p><p>开启 core 文件生成</p><blockquote><p>查看 core 文件生成是否打开，如果为0，则表示没有打开。<br>[root@localhost ~]#  ulimit -c<br>0</p><p>临时设置（如下设置2G，单位为kbyte）<br>如果生成的信息超过此大小，将会被裁剪，最终生成一个不完整的core文件。在调试此core文件的时候，<strong>gdb</strong>会提示错误。<br>ulimit -c 4194304</p></blockquote><h2 id="file-size"><a href="#file-size" class="headerlink" title="file size"></a>file size</h2><p>文本文件最大容量，可用 <code>ulimit -f</code> + 数字修改，需要限制日志文件大小时，可以修改此项</p><h2 id="open-files"><a href="#open-files" class="headerlink" title="open files"></a>open files</h2><p>系统最大打开文件数量，可用<code>ulimit -n</code> + <strong>数字</strong> 更改，一般设置为65536</p><p><code>ulimit -n 65536</code></p><p>启动任何进程，都会加载文件。针对 Web 服务器、基于java的服务会加载更多的文件，对于这些服务器，需要修改最大打开文件数。</p><h2 id="max-user-processes"><a href="#max-user-processes" class="headerlink" title="max user processes"></a>max user processes</h2><p>用户可使用最多的进程数，可用<code>ulimit -u</code> + <strong>数字</strong> 更改，一般改为65536</p><p><code>ulimit -u 65536</code></p><p><strong><u>以上修改为临时修改，需要永久修改需要修改配置文件<code>/etc/security/limits.conf</code></u></strong></p><p>当修改<code>/etc/security/limits.d/*.conf</code> 下的配置文件是，会优先使用此配置文件</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>规划和安装ESXI</title>
    <link href="/2020/04/07/vSphere_esxi_deploy/"/>
    <url>/2020/04/07/vSphere_esxi_deploy/</url>
    
    <content type="html"><![CDATA[<h1 id="1-规划-vSphere-部署"><a href="#1-规划-vSphere-部署" class="headerlink" title="1. 规划 vSphere 部署"></a>1. 规划 vSphere 部署</h1><h2 id="1-1-服务器平台"><a href="#1-1-服务器平台" class="headerlink" title="1.1 服务器平台"></a>1.1 服务器平台</h2><p>检查设备兼容性：存储控制器或者网络适配器</p><p>可使用 VNware 网上支持搜索的兼容指南（Compatibility Guide）：<a href="http://www.vmware.com/resources/compatibility/">www.vmware.com/resources/compatibility/</a></p><a id="more"></a><h2 id="1-2-存储架构"><a href="#1-2-存储架构" class="headerlink" title="1.2 存储架构"></a>1.2 存储架构</h2><ul><li>基于光纤通道和以太网光纤通道（FCoE）存储</li><li>基于iSCSI的存储</li><li>通过网络文件系统（NFS）访问的存储</li><li>支持在一种解决方案中使用多种存储协议</li></ul><h2 id="1-3-网络基础架构"><a href="#1-3-网络基础架构" class="headerlink" title="1.3 网络基础架构"></a>1.3 网络基础架构</h2><ul><li>ESXI 管理网络至少需要一个NIC（网络接口卡），推荐增加1个 NIC 冗余</li><li>vMotion 需要使用一个NIC ，推荐增加1个 NIC 冗余</li><li>使用 vSphere FT 需要至少一个NIC ，推荐增加1个 NIC 冗余</li><li>在使用 iSCSI 、 NFS 或 VSAN 的部署环境中，至少还需增加一个NIC，最好为2个</li><li>需要2个 NIC 来处理来自虚拟机本身的流量</li></ul><h1 id="2-部署-ESXI"><a href="#2-部署-ESXI" class="headerlink" title="2. 部署 ESXI"></a>2. 部署 ESXI</h1><h2 id="2-1-部署方法"><a href="#2-1-部署方法" class="headerlink" title="2.1 部署方法"></a>2.1 部署方法</h2><ul><li>交互式安装 ESXI</li><li>无人干预（脚本化）安装 ESXI</li><li>自动化分配（vSphere Auto Deploy） ESXI</li></ul><h2 id="2-2-无人干预-ESXI-安装过程的启动项选择"><a href="#2-2-无人干预-ESXI-安装过程的启动项选择" class="headerlink" title="2.2 无人干预 ESXI 安装过程的启动项选择"></a>2.2 无人干预 ESXI 安装过程的启动项选择</h2><table><thead><tr><th align="center">启动选项</th><th align="center">简要说明</th></tr></thead><tbody><tr><td align="center">ks=cdrom:/path</td><td align="center">使用CD-ROM 中指定路径的安装脚本。安装脚本会检查所有CD-ROM驱动器，直到发现与所指定路径相匹配的文件</td></tr><tr><td align="center">ks=usb</td><td align="center">USB设备中根目录下名称为ks.cfg的安装脚本。安装程序会搜索文件格式为FAT16或FAT32的USB设备</td></tr><tr><td align="center">ks=usb:/path</td><td align="center">使用USB设备上指定路径的安装脚本</td></tr><tr><td align="center">ks=protocol:/serverpath</td><td align="center">使用指定网络位置的安装脚本。支持的协议NFS、HTTP、HTTPS、FTP</td></tr></tbody></table><p>使用脚本安装ESXI，能够提高安装速度，有利于保证所有ESXI主机都有统一的配置。</p><h2 id="2-3-自动化分配（vSphere-Auto-Deploy）-ESXI"><a href="#2-3-自动化分配（vSphere-Auto-Deploy）-ESXI" class="headerlink" title="2.3 自动化分配（vSphere Auto Deploy） ESXI"></a>2.3 自动化分配（vSphere Auto Deploy） ESXI</h2><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="vSphere-设计需考虑的网络问题"><a href="#vSphere-设计需考虑的网络问题" class="headerlink" title="vSphere 设计需考虑的网络问题"></a>vSphere 设计需考虑的网络问题</h2><ul><li>VLAN支持</li><li>链路聚合、网络速度（1Gbps或10Gbps）、负载均衡、NIC接口</li></ul><h2 id="使用-vSphere-Auto-Deploy-部署-ESXI-的优缺点"><a href="#使用-vSphere-Auto-Deploy-部署-ESXI-的优缺点" class="headerlink" title="使用 vSphere Auto Deploy 部署 ESXI 的优缺点"></a>使用 vSphere Auto Deploy 部署 ESXI 的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以快速分配、快速重分配及在分配过程中快速增加新 ESXI 映像或更新。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加复杂性及需要额外的配置，解决部署无状态问题</p>]]></content>
    
    
    <categories>
      
      <category>VMware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VMware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux nmcli 使用及网络配置</title>
    <link href="/2020/03/26/linux_nmcli/"/>
    <url>/2020/03/26/linux_nmcli/</url>
    
    <content type="html"><![CDATA[<h1 id="一、nmcli-命令和网络配置文件对应关系"><a href="#一、nmcli-命令和网络配置文件对应关系" class="headerlink" title="一、nmcli 命令和网络配置文件对应关系"></a>一、nmcli 命令和网络配置文件对应关系</h1><table><thead><tr><th align="center">nmcli connection modify *</th><th align="center">ifcfg-* 文件</th></tr></thead><tbody><tr><td align="center">ipv4.method manual</td><td align="center">BOOTPROTO=none</td></tr><tr><td align="center">ipv4.method auto</td><td align="center">BOOTPROTO=dhcp</td></tr><tr><td align="center">ipv4.addresses 192.168.1.1/24</td><td align="center">IPADDR=192.168.2.230,PREFIX=24</td></tr><tr><td align="center">ipv4.dns 8.8.8.8</td><td align="center">DNS1=8.8.8.8</td></tr><tr><td align="center">ipv4.dns-seach example.com</td><td align="center">DOMAIN=example.com</td></tr><tr><td align="center">ipv4.ignore-auto-dns true</td><td align="center">PEERDNS=no</td></tr><tr><td align="center">connection.autoconnect yes</td><td align="center">ONBOOT=yes</td></tr><tr><td align="center">connection.id eth0</td><td align="center">NAME=eth0</td></tr><tr><td align="center">connection.interface-name eth0</td><td align="center">DEVICE=eth0</td></tr><tr><td align="center">802-3-ethernet.mac-address …</td><td align="center">HWADDR=…</td></tr></tbody></table><p><font color=red>注 *：网卡名称</font></p><p>可以使用 <code>nmcli device</code> 查看网卡</p><h2 id="1-1-应用"><a href="#1-1-应用" class="headerlink" title="1.1 应用"></a>1.1 应用</h2><pre><code class="hljs bash">[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># cat /etc/sysconfig/network-scripts/ifcfg-ens18 </span>TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens18DEVICE=ens18[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli connection modify ens18 ipv4.addresses 192.168.2.230/24     &lt;---配置ip地址和子网掩码</span>[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli connection modify ens18 ipv4.dns 114.114.114.114            &lt;---添加dns</span>[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli connection modify ens18 +ipv4.dns 8.8.8.8                   &lt;---添加dns</span>[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli connection modify ens18 ipv4.method manual                  &lt;---将ip获取方式改为手动</span>[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli connection modify ens18 ipv4.gateway 192.168.2.1            &lt;---配置网关地址</span>[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># cat /etc/sysconfig/network-scripts/ifcfg-ens18                   </span>TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens18DEVICE=ens18ONBOOT=yesIPADDR=192.168.2.230PREFIX=24DNS1=114.114.114.114DNS2=8.8.8.8GATEWAY=192.168.2.1</code></pre><h1 id="二、主机名"><a href="#二、主机名" class="headerlink" title="二、主机名"></a>二、主机名</h1><p>默认主机名一般为：localhost.localdomain</p><p>修改主机名：</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># hostnamectl set-hostname test</span>[root@localhost ~]<span class="hljs-comment"># cat /etc/hostname</span><span class="hljs-built_in">test</span></code></pre><h1 id="三、nmcli-命令的使用"><a href="#三、nmcli-命令的使用" class="headerlink" title="三、nmcli 命令的使用"></a>三、nmcli 命令的使用</h1><h2 id="3-1-显示网卡或某个网卡具体信息信息"><a href="#3-1-显示网卡或某个网卡具体信息信息" class="headerlink" title="3.1 显示网卡或某个网卡具体信息信息"></a>3.1 显示网卡或某个网卡具体信息信息</h2><pre><code class="hljs bash">[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli connection</span>NAME   UUID                                  TYPE      DEVICE ens18  d43b7a46-0dff-9d53-1068-ccc58c977db3  ethernet  ens18  [root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli con show</span>NAME   UUID                                  TYPE      DEVICE ens18  d43b7a46-0dff-9d53-1068-ccc58c977db3  ethernet  ens18  [root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli con show ens18</span>connection.id:                          ens18connection.uuid:                        d43b7a46-0dff-9d53-1068-ccc58c977db3connection.stable-id:                   --connection.type:                        802-3-ethernetconnection.interface-name:              ens18</code></pre><h2 id="3-2-显示所有设备状态"><a href="#3-2-显示所有设备状态" class="headerlink" title="3.2 显示所有设备状态"></a>3.2 显示所有设备状态</h2><pre><code class="hljs bash">[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli device status</span>DEVICE  TYPE      STATE      CONNECTION ens18   ethernet  connected  ens18      lo      loopback  unmanaged  --  `</code></pre><h2 id="3-3-重启网络使配置文件生效"><a href="#3-3-重启网络使配置文件生效" class="headerlink" title="3.3 重启网络使配置文件生效"></a>3.3 重启网络使配置文件生效</h2><ol><li><code>systemctl restart network</code></li><li><code>nmcli connection reload</code></li></ol><h2 id="3-4-显示所有活动连接"><a href="#3-4-显示所有活动连接" class="headerlink" title="3.4 显示所有活动连接"></a>3.4 显示所有活动连接</h2><pre><code class="hljs bash">[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># nmcli connection show --active</span>NAME   UUID                                  TYPE      DEVICE ens18  d43b7a46-0dff-9d53-1068-ccc58c977db3  ethernet  ens18</code></pre><h2 id="3-5-删除和添加一个网卡连接"><a href="#3-5-删除和添加一个网卡连接" class="headerlink" title="3.5 删除和添加一个网卡连接"></a>3.5 删除和添加一个网卡连接</h2><pre><code class="hljs bash">[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment">#  nmcli connection delete eth0 </span>[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment">#  nmcli connection add type ethernet con-name eth0 ifname eno33554992</span></code></pre><h2 id="3-6-网络接口的停用和启用"><a href="#3-6-网络接口的停用和启用" class="headerlink" title="3.6 网络接口的停用和启用"></a>3.6 网络接口的停用和启用</h2><pre><code class="hljs bash">[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment">#  nmcli connection down eth0 </span>[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment">#  nmcli connection up eth0</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux LVM</title>
    <link href="/2020/03/12/linux_lvm/"/>
    <url>/2020/03/12/linux_lvm/</url>
    
    <content type="html"><![CDATA[<h1 id="一、LVM-Logical-Volume-Manager"><a href="#一、LVM-Logical-Volume-Manager" class="headerlink" title="一、LVM (Logical Volume Manager)"></a>一、LVM (Logical Volume Manager)</h1><p>LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，LVM 是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。</p><h1 id="二、LVM-特点"><a href="#二、LVM-特点" class="headerlink" title="二、LVM 特点"></a>二、LVM 特点</h1><p>LVM 将存储<strong>虚拟化</strong>，使用逻辑卷，不会受限于物理磁盘的大小。另外，和硬件相关的存储设置被其隐藏，能不用停止应用或卸载文件系统来调整卷大小或数据迁移。这样能减少操作成本，LVM最大的特点就是可以对磁盘进行动态管理。因为逻辑卷的大小是可以动态调整的，而且不会丢失现有的数据。如果我们新增加了硬盘，其也不会改变现有上层的逻辑卷。作为一个动态磁盘管理机制，逻辑卷技术大大提高了磁盘管理的灵活性。</p><h1 id="三、LVM-工作机制"><a href="#三、LVM-工作机制" class="headerlink" title="三、LVM 工作机制"></a>三、LVM 工作机制</h1><p>LVM就是通过将底层的物理硬盘抽象的封装起来，然后以逻辑卷的方式呈现给上层应用。在传统的磁盘管理机制中，我们的上层应用是直接访问文件系统，从而对底层的物理硬盘进行读取。而在LVM中，其通过对底层的硬盘进行封装，当我们对底层的物理硬盘进行操作时，其不再是针对于分区进行操作，而是通过一个叫做逻辑卷的东西来对其进行底层的磁盘管理操作。</p><h2 id="3-1-逻辑卷管理"><a href="#3-1-逻辑卷管理" class="headerlink" title="3.1 逻辑卷管理"></a>3.1 逻辑卷管理</h2><h3 id="3-1-1-物理卷（PV，Physical-Volume）"><a href="#3-1-1-物理卷（PV，Physical-Volume）" class="headerlink" title="3.1.1 物理卷（PV，Physical Volume）"></a>3.1.1 物理卷（PV，Physical Volume）</h3><p>物理卷就是指磁盘，磁盘分区或从逻辑上和磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有和LVM相关的管理参数。当前 LVM 允许你在每个物理卷上保存这个物理卷的0至2份元数据拷贝，默认为1，保存在设备的开始处。为2时，在设备结束处保存第二份备份。</p><h3 id="3-1-1-卷组（VG，Volume-Group）"><a href="#3-1-1-卷组（VG，Volume-Group）" class="headerlink" title="3.1.1 卷组（VG，Volume Group）"></a>3.1.1 卷组（VG，Volume Group）</h3><p>LVM 卷组类似于非 LVM 系统中的物理硬盘，其由物理卷组成。能在卷组上创建一个或多LVM分区（逻辑卷）， LVM卷组由一个或多个物理卷组成。</p><h3 id="3-1-1-逻辑卷（LV，Logical-Volume）"><a href="#3-1-1-逻辑卷（LV，Logical-Volume）" class="headerlink" title="3.1.1 逻辑卷（LV，Logical Volume）"></a>3.1.1 逻辑卷（LV，Logical Volume）</h3><p>LVM的逻辑卷类似于非 LVM 系统中的硬盘分区，在逻辑卷之上能建立文件系统(比如/home或/usr等)。</p><p>关系图：</p><p><img src="/img/linux_lvm/linux_lvm_1.jpg"></p><h1 id="四、创建-LVM"><a href="#四、创建-LVM" class="headerlink" title="四、创建 LVM"></a>四、创建 LVM</h1><h2 id="4-1-检查系统是否安装-LVM-管理工具"><a href="#4-1-检查系统是否安装-LVM-管理工具" class="headerlink" title="4.1 检查系统是否安装 LVM 管理工具"></a>4.1 检查系统是否安装 LVM 管理工具</h2><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># rpm -qa |grep lvm</span>lvm2-2.02.186-7.el7_8.2.x86_64lvm2-libs-2.02.186-7.el7_8.2.x86_64<span class="hljs-comment">#未安装可使用 yum 安装</span>[root@localhost ~]<span class="hljs-comment"># yum install lvm*</span></code></pre><h2 id="4-2-创建物理卷-PV"><a href="#4-2-创建物理卷-PV" class="headerlink" title="4.2 创建物理卷 PV"></a>4.2 创建物理卷 PV</h2><p>基本 PV 命令：</p><ul><li>pvcreate 将物理分区新建为 PV</li><li>pvs/pvscan 查看系统里有 PV 的磁盘</li><li>pvdisplay 显示系统上 PV 的状态</li><li>pvremove 删除 PV</li></ul><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># lsblk </span>NAME            MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsdb               8:16   0   2G  0 disk sdc               8:32   0   2G  0 disk sdd               8:48   0   2G  0 disk sde               8:64   0   2G  0 disk sdf               8:80   0   2G  0 disk</code></pre><p>准备使用 <strong>sdb</strong>、<strong>sdc</strong> 来创建 LVM：</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># pvcreate /dev/sdb /dev/sdc</span>  Physical volume <span class="hljs-string">&quot;/dev/sdb&quot;</span> successfully created.  Physical volume <span class="hljs-string">&quot;/dev/sdc&quot;</span> successfully created.<span class="hljs-comment">#查看创建的 pv</span>[root@localhost ~]<span class="hljs-comment"># pvs</span>  PV         VG     Fmt  Attr PSize   PFree  /dev/sdb          lvm2 ---    2.00g 2.00g  /dev/sdc          lvm2 ---    2.00g 2.00g</code></pre><h2 id="4-3-创建卷组-VG"><a href="#4-3-创建卷组-VG" class="headerlink" title="4.3 创建卷组 VG"></a>4.3 创建卷组 VG</h2><p>基本 VG 命令：</p><ul><li>vgcreat [-s xM] vg_name /dev/sd.. 新建 vg，-s 后面接 pe 的大小（可选），单位是 M、G。可放多块 pv</li><li>vgextend 扩展 vg，就是增加 pv</li><li>vgs/vgscan 查看系统里有 vg 的磁盘</li><li>vgdisplay 显示系统上的 vg 状态</li><li>vgremove 删除 vg</li><li>vgreduce 在 vg 里删除 pv</li></ul><p>创建名为 vg_test ：</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># vgcreate -s 16M vg_test /dev/sdb</span>  Volume group <span class="hljs-string">&quot;vg_test&quot;</span> successfully created<span class="hljs-comment">#查看创建好的 vg</span>[root@localhost ~]<span class="hljs-comment"># vgs</span>  VG      <span class="hljs-comment">#PV #LV #SN Attr   VSize   VFree</span>  vg_test   1   0   0 wz--n-   1.98g 1.98g</code></pre><h2 id="4-4-创建逻辑卷-lv"><a href="#4-4-创建逻辑卷-lv" class="headerlink" title="4.4 创建逻辑卷 lv"></a>4.4 创建逻辑卷 lv</h2><p>基本 LV 命令：</p><ul><li>lvcreate (-l pe num)/(-L size) -n lv_name vg_name 新建 lv，lv 大小两种可选：1. -l 指定 pe 的个数，创建vg时有指定 pe大小 2.-L直接指定要创建 lv 的容量，单位为 M、G</li><li>lvextend 扩容</li><li>lvs/lvscan 查看系统里有 lv 的磁盘</li><li>lvdisplay 显示系统上 lv 的状态</li><li>lvremove 删除 lv</li><li>lvreduce 在 lv 里减少容量</li></ul><p>创建 lv_test</p><pre><code class="hljs bash"><span class="hljs-comment">#查看 vg_test 状态</span>[root@localhost ~]<span class="hljs-comment"># vgdisplay </span>  --- Volume group ---  VG Name               vg_test  System ID               Format                lvm2  Metadata Areas        1  Metadata Sequence No  1  VG Access             <span class="hljs-built_in">read</span>/write  VG Status             resizable  MAX LV                0  Cur LV                0  Open LV               0  Max PV                0  Cur PV                1  Act PV                1  VG Size               1.98 GiB  PE Size               16.00 MiB  Total PE              127  Alloc PE / Size       0 / 0     Free  PE / Size       127 / 1.98 GiB  VG UUID               Oge6D2-KPLh-RqNA-cRJ8-mc1y-0rkC-aoXmVt<span class="hljs-comment">#见 pe可用127,我们使用100个 pe</span>[root@localhost ~]<span class="hljs-comment"># lvcreate -l 100 -n lv_test vg_test</span>  Logical volume <span class="hljs-string">&quot;lv_test&quot;</span> created.[root@localhost ~]<span class="hljs-comment"># lvs</span>  LV      VG      Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert                                                   lv_test vg_test -wi-a-----   1.56g</code></pre><p><strong>格式化刚创建的 lv_test</strong></p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># mkfs.ext4 /dev/vg_test/lv_test </span>mke2fs 1.42.9 (28-Dec-2013)Discarding device blocks: <span class="hljs-keyword">done</span>                            Filesystem label=OS <span class="hljs-built_in">type</span>: LinuxBlock size=4096 (<span class="hljs-built_in">log</span>=2)Fragment size=4096 (<span class="hljs-built_in">log</span>=2)Stride=0 blocks, Stripe width=0 blocks102544 inodes, 409600 blocks20480 blocks (5.00%) reserved <span class="hljs-keyword">for</span> the super userFirst data block=0Maximum filesystem blocks=41943040013 block groups32768 blocks per group, 32768 fragments per group7888 inodes per groupSuperblock backups stored on blocks:         32768, 98304, 163840, 229376, 294912Allocating group tables: <span class="hljs-keyword">done</span>                            Writing inode tables: <span class="hljs-keyword">done</span>                            Creating journal (8192 blocks): <span class="hljs-keyword">done</span>Writing superblocks and filesystem accounting information: <span class="hljs-keyword">done</span></code></pre><p><strong>挂载使用；</strong></p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># mount /dev/vg_test/lv_test /mnt</span>[root@localhost ~]<span class="hljs-comment"># mount</span>/dev/mapper/vg_test-lv_test on /mnt <span class="hljs-built_in">type</span> ext4 (rw,relatime,seclabel,data=ordered)</code></pre><h1 id="五、LVM-在线扩展"><a href="#五、LVM-在线扩展" class="headerlink" title="五、LVM 在线扩展"></a>五、LVM 在线扩展</h1><p>先在 lv_test（/mnt） 下写入数据，测试在线扩展</p><pre><code class="hljs bash">[root@localhost mnt]<span class="hljs-comment"># touch hello_lvm</span>[root@localhost mnt]<span class="hljs-comment"># ls</span>hello_lvm</code></pre><p><font color=red>扩容 lv 分两种情况，第一是在 vg 容量还有的情况下，也就是Free PE Size 够用情况下。第二是在 vg 不够用，得先扩容 vg 的情况</font></p><h2 id="5-1-在-vg-下直接扩容"><a href="#5-1-在-vg-下直接扩容" class="headerlink" title="5.1 在 vg 下直接扩容"></a>5.1 在 vg 下直接扩容</h2><pre><code class="hljs bash"><span class="hljs-comment">#查看 vg 还剩27个 pe</span> [root@localhost ~]<span class="hljs-comment"># vgdisplay </span>  Free  PE / Size       27 / 432.00 MiB<span class="hljs-comment">#现在 lv 大小</span> [root@localhost ~]<span class="hljs-comment">#lvs</span>  LV      VG      Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert                                                    lv_test vg_test -wi-ao----   1.56g   <span class="hljs-comment">#lv 再扩容 20 个 pe，所以要 -l 120，之前给了 100，再扩容加上20，则120</span>[root@localhost ~]<span class="hljs-comment"># lvextend -l 120 /dev/vg_test/lv_test </span>  Size of logical volume vg_test/lv_test changed from 1.56 GiB (100 extents) to &lt;1.88 GiB (120 extents).  Logical volume vg_test/lv_test successfully resized.<span class="hljs-comment">#查看实际的磁盘容量，发现并没改变</span>[root@localhost ~]<span class="hljs-comment"># df -Th</span>Filesystem                  Type      Size  Used Avail Use% Mounted on/dev/mapper/vg_test-lv_test ext4      1.6G  4.7M  1.5G   1% /mnt<span class="hljs-comment">#需要对文件系统进行扩容</span>[root@localhost ~]<span class="hljs-comment"># resize2fs /dev/vg_test/lv_test </span>resize2fs 1.42.9 (28-Dec-2013)Filesystem at /dev/vg_test/lv_test is mounted on /mnt; on-line resizing requiredold_desc_blocks = 1, new_desc_blocks = 1The filesystem on /dev/vg_test/lv_test is now 491520 blocks long.[root@localhost ~]<span class="hljs-comment"># df -Th</span>Filesystem                  Type      Size  Used Avail Use% Mounted on/dev/mapper/vg_test-lv_test ext4      1.9G  4.7M  1.8G   1% /mnt</code></pre><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul><li>resize2fs /dev/vg_test/lv_test　　＃更新文件系统的大小，即激活</li><li>resize2fs -f　/dev/vg_test/lv_test　500M　＃强制设置大小</li><li>dump2fs /dev/vgtest/lvtest　　＃查看ext系列文件系统</li></ul><h2 id="5-2-vg-不够用情况，扩容-lv"><a href="#5-2-vg-不够用情况，扩容-lv" class="headerlink" title="5.2 vg 不够用情况，扩容 lv"></a>5.2 vg 不够用情况，扩容 lv</h2><p><strong>vg 空间不够，需先扩展 vg，扩展 vg 就是往 vg 中加 pv</strong></p><p>刚好开始创建 pv 时，多创建了个 sdc，将 pv sdc 加入到 vg_test 里面：</p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># pvs</span>  PV         VG      Fmt  Attr PSize   PFree    /dev/sdb   vg_test lvm2 a--    1.98g 112.00m  /dev/sdc           lvm2 ---    2.00g   2.00g[root@localhost ~]<span class="hljs-comment"># vgextend vg_test /dev/sdc </span>  Volume group <span class="hljs-string">&quot;vg_test&quot;</span> successfully extended[root@localhost ~]<span class="hljs-comment"># vgextend vg_test /dev/sdc </span>  Volume group <span class="hljs-string">&quot;vg_test&quot;</span> successfully extended[root@localhost ~]<span class="hljs-comment"># vgdisplay </span>  --- Volume group ---  VG Name               vg_test  System ID               Format                lvm2  Metadata Areas        2  Metadata Sequence No  4  VG Access             <span class="hljs-built_in">read</span>/write  VG Status             resizable  MAX LV                0  Cur LV                1  Open LV               1  Max PV                0  Cur PV                2  Act PV                2  VG Size               &lt;3.97 GiB  PE Size               16.00 MiB  Total PE              254  Alloc PE / Size       120 / &lt;1.88 GiB  Free  PE / Size       134 / 2.09 GiB          &lt;-----可用容量变多了  VG UUID               Oge6D2-KPLh-RqNA-cRJ8-mc1y-0rkC-aoXmVt<span class="hljs-comment">#将 pe 数量扩容到 220个</span>[root@localhost ~]<span class="hljs-comment"># lvextend -l 220 /dev/vg_test/lv_test </span>  Size of logical volume vg_test/lv_test changed from &lt;1.88 GiB (120 extents) to &lt;3.44 GiB (220 extents).  Logical volume vg_test/lv_test successfully resized.[root@localhost ~]<span class="hljs-comment"># resize2fs /dev/vg_test/lv_test </span>resize2fs 1.42.9 (28-Dec-2013)Filesystem at /dev/vg_test/lv_test is mounted on /mnt; on-line resizing requiredold_desc_blocks = 1, new_desc_blocks = 1The filesystem on /dev/vg_test/lv_test is now 901120 blocks long.[root@localhost ~]<span class="hljs-comment"># df -Th</span>Filesystem                  Type      Size  Used Avail Use% Mounted on/dev/mapper/vg_test-lv_test ext4      3.4G  6.3M  3.2G   1% /mnt<span class="hljs-comment">#查看数据是否还存在</span>[root@localhost ~]<span class="hljs-comment"># ll /mnt/</span>-rw-r--r--. 1 root root     0 Aug 29 15:55 hello_lvm</code></pre><h1 id="六、LVM-缩减"><a href="#六、LVM-缩减" class="headerlink" title="六、LVM 缩减"></a>六、LVM 缩减</h1><p>LVM 的缩减需要卸载文件系统–<code>[root@localhost ~]# umount /mnt/</code></p><p><strong>缩减操作：</strong></p><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># lvs</span>  LV      VG      Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert  root    centos  -wi-ao---- &lt;17.00g                                                      swap    centos  -wi-ao----   2.00g                                                      lv_test vg_test -wi-a-----  &lt;3.44g                                                    [root@localhost ~]<span class="hljs-comment"># resize2fs /dev/vg_test/lv_test 2G</span>resize2fs 1.42.9 (28-Dec-2013)Please run <span class="hljs-string">&#x27;e2fsck -f /dev/vg_test/lv_test&#x27;</span> first.<span class="hljs-comment">#需要进行文件系统检测</span>[root@localhost ~]<span class="hljs-comment"># e2fsck -f /dev/vg_test/lv_test </span>e2fsck 1.42.9 (28-Dec-2013)Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary information/dev/vg_test/lv_test: 12/220864 files (8.3% non-contiguous), 23666/901120 blocks[root@localhost ~]<span class="hljs-comment"># resize2fs /dev/vg_test/lv_test 2G</span>resize2fs 1.42.9 (28-Dec-2013)Resizing the filesystem on /dev/vg_test/lv_test to 524288 (4k) blocks.The filesystem on /dev/vg_test/lv_test is now 524288 blocks long.[root@localhost ~]<span class="hljs-comment"># lvs</span>  LV      VG      Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert                                                   lv_test vg_test -wi-a-----  &lt;3.44g                                                    [root@localhost ~]<span class="hljs-comment"># lvreduce -l 150 /dev/vg_test/lv_test </span>  WARNING: Reducing active logical volume to 2.34 GiB.  THIS MAY DESTROY YOUR DATA (filesystem etc.)Do you really want to reduce vg_test/lv_test? [y/n]: y  Size of logical volume vg_test/lv_test changed from &lt;3.44 GiB (220 extents) to 2.34 GiB (150 extents).  Logical volume vg_test/lv_test successfully resized.[root@localhost ~]<span class="hljs-comment"># lvs</span>  LV      VG      Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert  root    centos  -wi-ao---- &lt;17.00g                                                      swap    centos  -wi-ao----   2.00g                                                      lv_test vg_test -wi-a-----   2.34g                                                    [root@localhost ~]<span class="hljs-comment"># mount /dev/vg_test/lv_test /mnt</span>[root@localhost ~]<span class="hljs-comment"># df -Th</span>Filesystem                  Type      Size  Used Avail Use% Mounted ondevtmpfs                    devtmpfs  908M     0  908M   0% /devtmpfs                       tmpfs     919M     0  919M   0% /dev/shmtmpfs                       tmpfs     919M  8.6M  911M   1% /runtmpfs                       tmpfs     919M     0  919M   0% /sys/fs/cgroup/dev/mapper/centos-root     xfs        17G  2.4G   15G  14% //dev/sda1                   xfs      1014M  211M  804M  21% /boottmpfs                       tmpfs     184M     0  184M   0% /run/user/0/dev/mapper/vg_test-lv_test ext4      2.0G  4.7M  1.9G   1% /mnt<span class="hljs-comment">#查看测试问价</span>[root@localhost ~]<span class="hljs-comment"># ll /mnt/</span>total 16-rw-r--r--. 1 root root     0 Aug 29 15:55 hello_lvm</code></pre><h1 id="七、删除LVM"><a href="#七、删除LVM" class="headerlink" title="七、删除LVM"></a>七、删除LVM</h1><p>要彻底的来移除LVM的话，需要把创建的步骤反过来操作。</p><ol><li>卸载 文件系统</li><li>删除lv</li><li>删除vg</li><li>删除pv</li></ol><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># umount /mnt</span>[root@localhost ~]<span class="hljs-comment"># lvremove /dev/vg_test/lv_test </span>Do you really want to remove active logical volume vg_test/lv_test? [y/n]: y  Logical volume <span class="hljs-string">&quot;lv_test&quot;</span> successfully removed[root@localhost ~]<span class="hljs-comment"># vgremove /dev/vg_test</span>  Volume group <span class="hljs-string">&quot;vg_test&quot;</span> successfully removed[root@localhost ~]<span class="hljs-comment"># pvremove /dev/sdb /dev/sdc</span>  Labels on physical volume <span class="hljs-string">&quot;/dev/sdb&quot;</span> successfully wiped.  Labels on physical volume <span class="hljs-string">&quot;/dev/sdc&quot;</span> successfully wiped.</code></pre><h1 id="八、快照卷"><a href="#八、快照卷" class="headerlink" title="八、快照卷"></a>八、快照卷</h1><p>TODO…</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS 7 更改网卡名称</title>
    <link href="/2020/03/02/linux_change_ifname/"/>
    <url>/2020/03/02/linux_change_ifname/</url>
    
    <content type="html"><![CDATA[<p>Redhat 7 官方文档介绍命名规则</p><p>CentOS 7 默认网卡名大多为：ens，已经不是我们熟悉的 eth ，从centos7开始，网卡命名会根据固件，拓扑结构和位置信息来确定。</p><hr><h1 id="一、修改步骤"><a href="#一、修改步骤" class="headerlink" title="一、修改步骤"></a>一、修改步骤</h1><h2 id="1-1-编辑网卡的配置文件"><a href="#1-1-编辑网卡的配置文件" class="headerlink" title="1.1 编辑网卡的配置文件"></a>1.1 编辑网卡的配置文件</h2><pre><code class="hljs bash">[root@<span class="hljs-built_in">test</span> ~]<span class="hljs-comment"># vi /etc/sysconfig/network-scripts/ifcfg-ens18</span>NAME=eth0           &lt;--- 改为想要的名称，如 eth0，下同DEVICE=eth0</code></pre><h2 id="1-2-重命名网卡配置文件"><a href="#1-2-重命名网卡配置文件" class="headerlink" title="1.2 重命名网卡配置文件"></a>1.2 重命名网卡配置文件</h2><pre><code class="hljs bash">[root@localhost network-scripts]<span class="hljs-comment"># mv ifcfg-ens18 ifcfg-eth0</span></code></pre><h2 id="1-3-修改内核参数配置文件"><a href="#1-3-修改内核参数配置文件" class="headerlink" title="1.3 修改内核参数配置文件"></a>1.3 修改内核参数配置文件</h2><p><code>vi /etc/default/grub</code> ，添加红色框内内容，禁用 CentOS7 上的命名规则</p><p><img src="/img/linux_change_ifname/linux_change_ifname_1.jpg"></p><h2 id="1-4-执行命令"><a href="#1-4-执行命令" class="headerlink" title="1.4 执行命令"></a>1.4 执行命令</h2><p><code>grub2-mkconfig -o /boot/grub2/grub.cfg</code> 来重新生成 grub 配置并更新内核参数。重启设备可生效</p><h2 id="1-5-创建网卡接口命名规则"><a href="#1-5-创建网卡接口命名规则" class="headerlink" title="1.5 创建网卡接口命名规则"></a>1.5 创建网卡接口命名规则</h2><p><code>vim /etc/udev/rules.d/70-persistent-ipoib.rules</code></p><p>添加内容如下一行：</p><p><code>UBSYSTEM==&quot;net&quot;,ACTION==&quot;add&quot;,DRIVERS==&quot;?&quot;,ATTR&#123;address&#125;==&quot;&quot;,ATTR&#123;type&#125;==&quot;1&quot;,KERNEL==&quot;eth*&quot;,NAME=&quot;eth0&quot;</code></p><p>这时重启再添加网卡其名称就会自动变成eth1、eth2 … 依次类推。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内核及系统日志分析</title>
    <link href="/2020/02/18/kernel_sys_log_cat/"/>
    <url>/2020/02/18/kernel_sys_log_cat/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-由系统服务-rsyslogd-统一管理"><a href="#一、-由系统服务-rsyslogd-统一管理" class="headerlink" title="一、 由系统服务 rsyslogd 统一管理"></a>一、 由系统服务 rsyslogd 统一管理</h1><ul><li>软件包：rsyslogd-x.x.x_0.x86_64</li><li>主要程序：/sbin/rsyslogd</li><li>配置文件：/etc/rsyslog.conf</li></ul><h1 id="二、-日志消息级别"><a href="#二、-日志消息级别" class="headerlink" title="二、 日志消息级别"></a>二、 日志消息级别</h1><ul><li>0 EMERG （紧急）：导致主机系统不可用的情况</li><li>1 ALERT（警告）：必须马上采取措施解决的问题</li><li>2 CRIT（严重）：比较严重的情况</li><li>3 ERR（错误）：运行出现错误</li><li>4 WARNING（提醒）：可能会影响系统功能的时间</li><li>5 NOTICE（注意）：不会影响系统但是值得注意</li><li>6 INFO（信息）：一般信息</li><li>7 DEBUG（调试）：程序或系统调试信息等</li></ul><h1 id="三、-syslog-服务"><a href="#三、-syslog-服务" class="headerlink" title="三、 syslog 服务"></a>三、 syslog 服务</h1><h2 id="3-1-syslogd"><a href="#3-1-syslogd" class="headerlink" title="3.1 syslogd"></a>3.1 syslogd</h2><p>系统，非内核产生的信息</p><h2 id="3-2-klogd"><a href="#3-2-klogd" class="headerlink" title="3.2 klogd"></a>3.2 klogd</h2><p>内核，专门负责记录内核产生的日志信息</p><h1 id="四、-日志记录"><a href="#四、-日志记录" class="headerlink" title="四、 日志记录"></a>四、 日志记录</h1><h2 id="4-1-dmesg"><a href="#4-1-dmesg" class="headerlink" title="4.1 dmesg"></a>4.1 dmesg</h2><p>设备启动：</p><p>kernel 启动 日志输出到 –&gt; 物理终端（/dev/console） 产生日志 –&gt; /var/log/dmesg</p><h3 id="查看-dmesg-日志"><a href="#查看-dmesg-日志" class="headerlink" title="查看 dmesg 日志"></a>查看 dmesg 日志</h3><ul><li>#dmesg</li><li>cat /var/log/dmesg</li></ul><h2 id="4-2-系统标准错误日志信息"><a href="#4-2-系统标准错误日志信息" class="headerlink" title="4.2 系统标准错误日志信息"></a>4.2 系统标准错误日志信息</h2><p><code>/var/log/messages</code>：系统标准错误日志信息，非内核产生引导信息，各子系统产生的信息</p><pre><code class="hljs shell">[root@localhost ~]# tail -f /var/log/messagesJul 19 06:06:33 localhost ModemManager[905]: &lt;warn&gt; Couldn&#x27;t find support for device at &#x27;/sys/devices..&#x27;</code></pre><table><thead><tr><th align="center">Jul 19 06:06:33</th><th align="center">localhost</th><th align="center">ModemManager[905]</th><th align="center">&lt;warn&gt;</th><th align="center">Couldn’t find</th></tr></thead><tbody><tr><td align="center">时间戳</td><td align="center">主机名</td><td align="center">子系统</td><td align="center">消息级别</td><td align="center">消息字段内容</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 文件系统的选择</title>
    <link href="/2020/02/11/linux_fs/"/>
    <url>/2020/02/11/linux_fs/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h1><ul><li>ext2：linux 下标准文件系统，无日志记录功能。</li><li>ext3：在 ext2 基础上增加了日志记录功能，仅支持32000个子目录。</li><li>exit4：ext4 的后续版本，linux 2.6.28 内核开始支持。无限子目录支持，快速 fsck。</li><li>xfs：高性能文件系统，linux3.10 内核开始默认支持。</li></ul><p><img src="/img/linux_fs/linux.jpg"></p><h2 id="查看-linux-内核版本"><a href="#查看-linux-内核版本" class="headerlink" title="查看 linux 内核版本"></a>查看 linux 内核版本</h2><pre><code class="hljs bash">[root@blog ~]<span class="hljs-comment"># uname -a</span>Linux blog 3.10.0-1127.el7.x86_64 <span class="hljs-comment">#1 SMP Tue Mar 31 23:36:51 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></code></pre><h3 id="redhat-centos-查看具体版本号"><a href="#redhat-centos-查看具体版本号" class="headerlink" title="redhat/centos 查看具体版本号"></a>redhat/centos 查看具体版本号</h3><pre><code class="hljs bash">[root@blog ~]<span class="hljs-comment"># cat /etc/redhat-release </span>CentOS Linux release 7.8.2003 (Core)</code></pre><h2 id="文件系统选择"><a href="#文件系统选择" class="headerlink" title="文件系统选择"></a>文件系统选择</h2><p>ext4：适用于<strong>读</strong>操作频繁，同时<strong>小文件</strong>众多的业务</p><p>xfs：适用于<strong>写</strong>操作频繁业务</p><p>ext3：适用于对性能要求不高、数据安全要求不高的业务</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redhat/CentOS 7 单用户修改 root 密码</title>
    <link href="/2019/11/01/linux_change_pw/"/>
    <url>/2019/11/01/linux_change_pw/</url>
    
    <content type="html"><![CDATA[<h1 id="修改步骤"><a href="#修改步骤" class="headerlink" title="修改步骤"></a>修改步骤</h1><ol><li><p>重启系统，在 Grub Boot Loader 倒计时读秒结束前，按下任意键</p></li><li><p>选择第一项，并按下 e 键，编辑</p></li></ol><p><img src="/img/linux_change_pw/linux_change_pw_1.jpg"></p><ol start="3"><li>进入编辑界面后，找到 linux16 开头的行，通过 Ctrl + e 可以快速定位到行末，空格键后输入 rd.break</li></ol><p><img src="/img/linux_change_pw/linux_change_pw_2.jpg"></p><ol start="4"><li>编辑好后，按下 Ctrl + x，引导系统，系统将启动到临时内核 shell 界面，输入以下指令即可修改密码</li></ol><p><img src="/img/linux_change_pw/linux_change_pw_3.jpg"></p><p><strong><font color=red>注意：修改密码后，首次重启时间将会比较长，因为系统将对所有文件进行 SeLinux 打标，请勿在打标过程中手动强制重启，否则系统将会永久性损坏导致无法开机。</font></strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 运维故障排查与系统调优技巧</title>
    <link href="/2019/10/24/linux_install_tips_and_fault_detect/"/>
    <url>/2019/10/24/linux_install_tips_and_fault_detect/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-排障"><a href="#一、-排障" class="headerlink" title="一、 排障"></a>一、 排障</h1><h2 id="1-1-排障要点"><a href="#1-1-排障要点" class="headerlink" title="1.1 排障要点"></a>1.1 排障要点</h2><ol><li>确定问题故障特征</li><li>重现故障</li><li>使用工具收集进一步信息</li><li>排除不可能的原因</li><li>定位故障：从简单的问题入手；一次尝试一中方式</li></ol><h2 id="1-2-常见故障"><a href="#1-2-常见故障" class="headerlink" title="1.2 常见故障"></a>1.2 常见故障</h2><ul><li>管理员密码忘记</li><li>系统无法正常启动<ul><li><ol><li>grub 损坏 （MBR损坏、grub 配置文件丢失）</li></ol></li><li><ol start="2"><li>系统初始化故障（某文件系统无法正常挂载、驱动不兼容）</li></ol></li><li><ol start="3"><li>服务故障</li></ol></li><li><ol start="4"><li>用户无法登陆系统（密码是否正确、bash程序是否故障）</li></ol></li></ul></li><li>命令无法运行</li><li>编译过程无法继续（开发环境缺少基本组件）</li></ul><h3 id="1-2-1-MBR-grub-损坏"><a href="#1-2-1-MBR-grub-损坏" class="headerlink" title="1.2.1 MBR/grub 损坏"></a>1.2.1 MBR/grub 损坏</h3><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>将 mbr 分区手动损坏</p><pre><code class="hljs bahs">#先备份 mbr 分区[root@test ~]# dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;root&#x2F;mbr.backup count&#x3D;1 bs&#x3D;5121+0 records in1+0 records out512 bytes (512 B) copied, 0.000588373 s, 870 kB&#x2F;s#往 mbr 写入200 bytes 空数据1+0 records in1+0 records out200 bytes (200 B) copied, 0.000351164 s, 570 kB&#x2F;s#同步到磁盘[root@test ~]# sync#重新启动，系统无法进入</code></pre><p><strong>解决办法：</strong></p><p>使用紧急救援模式：使用完整的系统安装光盘</p><ul><li>boot:linux rescue<ul><li>/mnt/sysimage</li></ul></li><li>chroot /mnt/sysroot</li></ul><pre><code class="hljs bash">sh-4.2<span class="hljs-comment"># chroot /mnt/sysimage</span>sh-4.2<span class="hljs-comment"># grub2-install /dev/vda</span>Installing <span class="hljs-keyword">for</span> i386-pc platform.Installation finished. No error reported.sh-4.2<span class="hljs-comment"># exit</span>sh-4.2<span class="hljs-comment"># reboot</span></code></pre><p>TODO….</p><h3 id="1-2-2"><a href="#1-2-2" class="headerlink" title="1.2.2"></a>1.2.2</h3><h1 id="更改主机名（hostname）"><a href="#更改主机名（hostname）" class="headerlink" title="更改主机名（hostname）"></a>更改主机名（hostname）</h1><p>在更改主机名时将主机名添加至 <code>/etc/hosts</code>下，做个映射</p><p><code>127.0.0.1        hostname</code> </p><p>这样能够避免后续安装应用所出现的问题</p><a id="more"></a><h1 id="SSH-设置"><a href="#SSH-设置" class="headerlink" title="SSH 设置"></a>SSH 设置</h1><p>ssh 配置文件路径，修改配置文件前记得备份文件</p><p><code>cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak</code></p><p><code>/etc/ssh/sshd_config</code></p><h2 id="关闭-GSSAPI-验证，可以提高-ssh-连接速度"><a href="#关闭-GSSAPI-验证，可以提高-ssh-连接速度" class="headerlink" title="关闭 GSSAPI 验证，可以提高 ssh 连接速度"></a>关闭 GSSAPI 验证，可以提高 ssh 连接速度</h2><p> <code>GSSAPIAuthentication no</code></p><h2 id="不使用-DNS-反查，可以提高-ssh-连接速度"><a href="#不使用-DNS-反查，可以提高-ssh-连接速度" class="headerlink" title="不使用 DNS 反查，可以提高 ssh 连接速度"></a>不使用 DNS 反查，可以提高 ssh 连接速度</h2><p> <code>UseDNS no</code></p><h1 id="yum-设置"><a href="#yum-设置" class="headerlink" title="yum 设置"></a>yum 设置</h1><h2 id="常用-yum-源"><a href="#常用-yum-源" class="headerlink" title="常用 yum 源"></a>常用 yum 源</h2><ul><li>epel源：<a href="https://fedoraproject.org/wiki/EPEL">https://fedoraproject.org/wiki/EPEL</a> </li><li>repoforge 源：<a href="http://repoforge.org/use/">http://repoforge.org/use/</a> </li></ul><h1 id="排障关注点"><a href="#排障关注点" class="headerlink" title="排障关注点"></a>排障关注点</h1><ul><li>/var/log/messages    #应用日志查询</li><li>/var/log/secure         #登录日志查询</li><li>dmesg                        #系统日志查询</li><li>/var/tmp 、/tmp       #容易攻击点查询</li><li>crontab -l 、/etc/crontab    #计划任务查询（经常攻击对象）</li></ul><h2 id="dmesg-命令、文件"><a href="#dmesg-命令、文件" class="headerlink" title="dmesg 命令、文件"></a>dmesg 命令、文件</h2><p>直接输出当前最新的系统日志。</p><p>系统每次开机将日志保存到<code>/var/log/dmesg</code></p><p>旧的日志会保存到<code>/var/log/dmesg.old</code></p><h2 id="secure-文件"><a href="#secure-文件" class="headerlink" title="secure 文件"></a>secure 文件</h2><p>ssh 登录日志</p><p>可以通过过滤查看登录成功的日志</p><p><code>tail -1000 /var/log/secure |grep Accepted</code></p><h2 id="temp-文件夹（-var-tmp-、-tmp-）"><a href="#temp-文件夹（-var-tmp-、-tmp-）" class="headerlink" title="temp 文件夹（/var/tmp 、/tmp ）"></a>temp 文件夹（/var/tmp 、/tmp ）</h2><p>通过<code>ls -al</code>查看 temp 文件是否有异常文件</p><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>通过<code>crontab -l</code>查看是否有异常的计划任务</p><p>系统计划任务配置文件在<code>/ect/crontab</code>，目录<code>/etc/cron.*/</code>里放的脚本科自动执行，也要检查</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 系统性能分析标准</title>
    <link href="/2019/09/17/linux_performance_analysis/"/>
    <url>/2019/09/17/linux_performance_analysis/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">影响性能因素</th><th align="center">评判标准</th><th align="center">评判标准</th><th align="center">评判标准</th></tr></thead><tbody><tr><td align="center"></td><td align="center">好</td><td align="center">坏</td><td align="center">糟糕</td></tr><tr><td align="center">CPU</td><td align="center">user% + sys% &lt; 70%</td><td align="center">user% + sys% = 85%</td><td align="center">user% + sys% &gt;= 90%</td></tr><tr><td align="center">内存</td><td align="center">Swap In(si) &amp; Out(so)=0</td><td align="center">Per CPU with 10 page/s</td><td align="center">more Swap In &amp;Swap Out</td></tr><tr><td align="center">磁盘</td><td align="center">iowait% &lt; 20%</td><td align="center">iowait% = 35%</td><td align="center">iowait% &gt;= 50%</td></tr></tbody></table><h3 id="其中"><a href="#其中" class="headerlink" title="其中"></a>其中</h3><p>%user：表示 CPU 处在用户模式下的时间百分比。<br>%sys：表示 CPU 处在系统模式下的时间百分比。<br>%iowait：表示 CPU 等待输入输出完成时间的百分比。<br>swap in：即si，表示虚拟内存的页导入，即从SWAP DISK 交换到 RAM。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 系统权限不正常导致系统无法启动</title>
    <link href="/2019/08/17/linux_sys_root_bad/"/>
    <url>/2019/08/17/linux_sys_root_bad/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="系统卡在登录界面，debug-模式显示多项-FAILED"><a href="#系统卡在登录界面，debug-模式显示多项-FAILED" class="headerlink" title="系统卡在登录界面，debug 模式显示多项 [FAILED]"></a>系统卡在登录界面，debug 模式显示多项 [FAILED]</h2><p><img src="/img/linux_sys_root_bad/linux_sys_root_bad_1.jpg"></p><a id="more"></a><h1 id="告警信息"><a href="#告警信息" class="headerlink" title="告警信息"></a>告警信息</h1><h2 id="1-远程ssh普通用户能够登入，但是无法切换-root-用户"><a href="#1-远程ssh普通用户能够登入，但是无法切换-root-用户" class="headerlink" title="1 远程ssh普通用户能够登入，但是无法切换 root 用户"></a>1 远程ssh普通用户能够登入，但是无法切换 root 用户</h2><pre><code class="hljs routeros">[user@location~]$ sudo su -sudo: unknow user:rootsudo: unable <span class="hljs-keyword">to</span> initialize<span class="hljs-built_in"> policy </span>plugin</code></pre><h2 id="2-普通用户下使用-ps-ef-查看用户进程-UID-显示为-ixdba"><a href="#2-普通用户下使用-ps-ef-查看用户进程-UID-显示为-ixdba" class="headerlink" title="2 普通用户下使用 ps -ef 查看用户进程 UID 显示为 ixdba"></a>2 普通用户下使用 ps -ef 查看用户进程 UID 显示为 ixdba</h2><p><img src="/img/linux_sys_root_bad/linux_sys_root_bad_2.jpg"></p><p>正常为：</p><p><img src="/img/linux_sys_root_bad/linux_sys_root_bad_3.jpg"></p><h1 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h1><h2 id="1-查看-etc-passwd"><a href="#1-查看-etc-passwd" class="headerlink" title="1 查看 /etc/passwd"></a>1 查看 /etc/passwd</h2><p>发现 <code>root:x:0:0:root:/root:/bin/bash</code>-&gt; <code>ixdba:x:0:0:root:/root:/bin/bash</code></p><h2 id="2-将-root-用户名改回"><a href="#2-将-root-用户名改回" class="headerlink" title="2 将 root 用户名改回"></a>2 将 root 用户名改回</h2><p>进单用户模式，修改  /etc/passwd <code>ixdba:x:0:0:root:/root:/bin/bash</code>-&gt; <code>root:x:0:0:root:/root:/bin/bash</code></p><h1 id="根因"><a href="#根因" class="headerlink" title="根因"></a>根因</h1><p>root 用户被改成其他名称，如本例中的 ixdba。</p><p>服务在启动过程中，需要 root 用户名及 root 组来授权（root，root），修改后，服务找不到 root 用户，无法得到授权，所以很多服务系统无法启动。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>将 root用户名称改回 root，避免修改 root 用户名。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 系统资源 ulimit 设置不正确导致无法登录</title>
    <link href="/2019/07/15/linux_ulimit_bad/"/>
    <url>/2019/07/15/linux_ulimit_bad/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="本地及远程-ssh-无法登录"><a href="#本地及远程-ssh-无法登录" class="headerlink" title="本地及远程 ssh 无法登录"></a>本地及远程 ssh 无法登录</h2><p>ssh登录有显示 last login，但是会闪断，重连。</p><p>本地登录为一直重复输入用户名密码。</p><a id="more"></a><h1 id="告警信息"><a href="#告警信息" class="headerlink" title="告警信息"></a>告警信息</h1><p>进入单用户模式，查看登录日志 <code>tail -f /var/log/secure</code></p><p><img src="/img/linux_ulimit_bad/linux_ulimit_bad_1.jpg"></p><p>关键信息</p><p>error: PAM: pam_open_session(): Permission denied</p><p>pam_limits(sshd:session): Could not set limit for ‘nofile’: Operation not permitted</p><h1 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h1><p>查看 ulimit 配置是否异常：<code>ulimit -a</code></p><pre><code class="hljs gradle">[user@localhost~]# cat <span class="hljs-regexp">/etc/</span>security/limits.conf |<span class="hljs-keyword">grep</span> -v <span class="hljs-string">&quot;#&quot;</span></code></pre><p>查看 ulimit 配置<code> /etc/security/limits.conf</code> <code>/etc/security/limits.d/*.conf</code></p><pre><code class="hljs yaml">[<span class="hljs-string">user@localhost~</span>]<span class="hljs-comment"># cat /etc/security/limits.d/20-nproc.conf </span><span class="hljs-comment"># Default limit for number of user&#x27;s processes to prevent</span><span class="hljs-comment"># accidental fork bombs.</span><span class="hljs-comment"># See rhbz #432903 for reasoning.</span><span class="hljs-string">*</span>          <span class="hljs-string">soft</span>    <span class="hljs-string">nproc</span>     <span class="hljs-number">4096</span><span class="hljs-string">root</span>       <span class="hljs-string">soft</span>    <span class="hljs-string">nproc</span>     <span class="hljs-string">unlimited</span><span class="hljs-string">*</span>          <span class="hljs-string">soft</span>    <span class="hljs-string">nofile</span>    <span class="hljs-number">65536000</span><span class="hljs-string">*</span>          <span class="hljs-string">hard</span>    <span class="hljs-string">nofile</span>    <span class="hljs-number">65536000</span></code></pre><p>将 nofile 数值改小到 65536</p><h1 id="根因"><a href="#根因" class="headerlink" title="根因"></a>根因</h1><p>nofile 数值设置太大导致溢出，无权限设置过大  Could not set limit for ‘nofile’: Operation not permitted</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>无法登录情况，需要进入单用户模式查看系统配置是否正确：<br>如：/root/.bash_profile<br>本例中，设置资源配置文件 <code> /etc/security/limits.conf</code> <code>/etc/security/limits.d/*.conf</code> nofile 设置过大溢出，导致系统无法分配 open files 权限，无法登陆。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MegaRAID卡无法清除VD ( Discard Cache) 创建raid</title>
    <link href="/2019/06/21/MegaRAID_not_clear_raid/"/>
    <url>/2019/06/21/MegaRAID_not_clear_raid/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="1-开机提示VD丢失"><a href="#1-开机提示VD丢失" class="headerlink" title="1.开机提示VD丢失"></a>1.开机提示VD丢失</h2><p><img src="/img/megaraid/VD_lost_1.png"></p><h2 id="2-点击discard-cache无效，无法清除VD，点清除后还是提示有丢失的vd"><a href="#2-点击discard-cache无效，无法清除VD，点清除后还是提示有丢失的vd" class="headerlink" title="2.点击discard cache无效，无法清除VD，点清除后还是提示有丢失的vd"></a>2.点击discard cache无效，无法清除VD，点清除后还是提示有丢失的vd</h2><p><img src="/img/megaraid/VD_lost_2.png"><img src="/img/megaraid/VD_lost_3.png"></p><a id="more"></a><h2 id="3-创建raid报错，无法正常创建raid配置"><a href="#3-创建raid报错，无法正常创建raid配置" class="headerlink" title="3.创建raid报错，无法正常创建raid配置"></a>3.创建raid报错，无法正常创建raid配置</h2><p><img src="/img/megaraid/VD_lost_4.png"></p><h1 id="告警信息"><a href="#告警信息" class="headerlink" title="告警信息"></a>告警信息</h1><p>you cannot perform that operation because the contronller has preserved cache.you must either discard the preserved cache by going to the manage preserved cache operation or import the virtual drives that have preserved cache</p><h1 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h1><p>硬核处理过程：<br>服务器下电，把阵列卡电池拔出放电</p><p>或者<br>1、下载tookit工具引导进去tookit命令行</p><p>linux: ~ #./storcli64 -help | grep -i preserved<br>storcli /cx show preservedcache<br>storcli /cx/vx delete preservedcache[force]</p><p>1../storcli64 /c0 show preservedcache</p><p>可以看到是哪个VD有preservedcache</p><p>2.根据上面的命令查到的VD编号，例如VD：0，执行：</p><p>./storcli64 /c0/v0 delete preservedcache force</p><p>清除完成后到raid卡的webbios里把boot error handling恢复原来的设置</p><h1 id="根因"><a href="#根因" class="headerlink" title="根因"></a>根因</h1><p>RAID卡Cache中存在数据，重启服务器或者更换硬盘后，Cache中的数据无法写到硬盘中，导致出现上述问题。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>Cache 数据的保护，一般都依赖于镜像与电池 ( 或者是 UPS)，要是discard cache无效，可以试着拔出阵列卡电池试试。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unexpected inconsistency run fsck 处理报告</title>
    <link href="/2018/10/20/Linux_RUN_fsck/"/>
    <url>/2018/10/20/Linux_RUN_fsck/</url>
    
    <content type="html"><![CDATA[<h1 id="1、故障摘要"><a href="#1、故障摘要" class="headerlink" title="1、故障摘要"></a>1、故障摘要</h1><p>机器意外宕机重启，出现报错，无法进入系统，如图</p><p><img src="/img/linux_fsck/Linux_1.png"></p><h1 id="2、故障具体情况"><a href="#2、故障具体情况" class="headerlink" title="2、故障具体情况"></a>2、故障具体情况</h1><p>提示按CTRL+D继续，按了CTRL+D会重启，再次回到这个界面。<br><img src="/img/linux_fsck/Linux_2.png"></p><pre><code>Give root passwd for maintenance</code></pre><p>根据提示输入密码进行维护。</p><h1 id="3、故障分析及处理"><a href="#3、故障分析及处理" class="headerlink" title="3、故障分析及处理"></a>3、故障分析及处理</h1><p>正确输入密码后，进入到维护模式。<br><img src="/img/linux_fsck/Linux_3.png"><br>在修复模式下，键入命令<code>fsck –y</code>（后面可加其报错目录，每个报错目录都不相同）<br><img src="/img/linux_fsck/Linux_4.png"><br>输入后，系统会检测修复硬盘，检测修复时间根据硬盘里数据多少而定，最后检测完毕。输入reboot重启。<br>一般情况下重启完毕就可以进入登陆界面。</p><h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>fsck的命令的几个使用方法</p><p>指令：fsck</p><p>使用权限 : 超级使用者</p><p>使用方式 : fsck [-sACVRP] [-t fstype] [–] [fsck-options] filesys […]</p><p>说明 ： 检查与修复 Linux 档案系统，可以同时检查一个或多个 Linux 档案系统</p><p>参数 ：</p><p>filesys ： device 名称(eg./dev/sda1)，mount 点 (eg. / 或 /usr)</p><p>-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数</p><p>-s : 依序一个一个地执行 fsck 的指令来检查</p><p>-A : 对/etc/fstab 中所有列出来的 partition 做检查</p><p>-C : 显示完整的检查进度</p><p>-d : 列印 e2fsck 的 debug 结果</p><p>-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行</p><p>-R : 同时有 -A 条件时，省略 / 不检查</p><p>-V : 详细显示模式</p><p>-a : 如果检查有错则自动修复</p><p>-r : 如果检查有错则由使用者回答是否修复</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Cookbook Note</title>
    <link href="/2018/02/26/python_cookbook_note/"/>
    <url>/2018/02/26/python_cookbook_note/</url>
    
    <content type="html"><![CDATA[<h1 id="1、数据结构和算法"><a href="#1、数据结构和算法" class="headerlink" title="1、数据结构和算法"></a>1、数据结构和算法</h1><h2 id="1-1-将不用的变量使用任意变量名去占位，然后丢弃，取其想要的部分"><a href="#1-1-将不用的变量使用任意变量名去占位，然后丢弃，取其想要的部分" class="headerlink" title="1.1 将不用的变量使用任意变量名去占位，然后丢弃，取其想要的部分"></a>1.1 将不用的变量使用任意变量名去占位，然后丢弃，取其想要的部分</h2><pre><code class="hljs python">data = [<span class="hljs-string">&#x27;ACME&#x27;</span>,<span class="hljs-number">50</span>,<span class="hljs-number">91.1</span>,(<span class="hljs-number">2018</span>, <span class="hljs-number">2</span>, <span class="hljs-number">26</span>)]_,shares,price,_ = dataprint(shares)&gt;&gt;&gt;<span class="hljs-number">50</span></code></pre><h2 id="1-2-星号解压语法在字符串操作"><a href="#1-2-星号解压语法在字符串操作" class="headerlink" title="1.2 星号解压语法在字符串操作"></a>1.2 星号解压语法在字符串操作</h2><pre><code class="hljs python">line = <span class="hljs-string">&#x27;nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false&#x27;</span>uname,*fields,homedir,sh = line.split(<span class="hljs-string">&#x27;:&#x27;</span>)                         print(uname)                                                       print(homedir)    &gt;&gt;&gt;nobody&gt;&gt;&gt;/var/empty</code></pre><h2 id="1-3-当要解压一写元素后丢弃它们，不能使用-的时候，可以使用普通废弃名称，比如-或ign-ignore"><a href="#1-3-当要解压一写元素后丢弃它们，不能使用-的时候，可以使用普通废弃名称，比如-或ign-ignore" class="headerlink" title="1.3 当要解压一写元素后丢弃它们，不能使用*的时候，可以使用普通废弃名称，比如_或ign(ignore)"></a>1.3 当要解压一写元素后丢弃它们，不能使用*的时候，可以使用普通废弃名称，比如_或ign(ignore)</h2><pre><code class="hljs python">c = [(<span class="hljs-number">2</span>,<span class="hljs-number">16</span>,<span class="hljs-number">2018</span>),<span class="hljs-string">&#x27;星期一&#x27;</span>,<span class="hljs-string">&#x27;晴&#x27;</span>]   (_,_,d),e,f = c               print(d)                      <span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2018</span></code></pre><h2 id="1-4-使用heapq模块来查找最大或最小的N个元素列表"><a href="#1-4-使用heapq模块来查找最大或最小的N个元素列表" class="headerlink" title="1.4 使用heapq模块来查找最大或最小的N个元素列表"></a>1.4 使用heapq模块来查找最大或最小的N个元素列表</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq                         nums = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">21</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">63</span>,<span class="hljs-number">-14</span>]   <span class="hljs-comment">#打印出最大或最小的3个元素 </span>print(heapq.nlargest(<span class="hljs-number">3</span>,nums))        print(heapq.nsmallest(<span class="hljs-number">3</span>,nums))&gt;&gt;&gt;[<span class="hljs-number">63</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>]&gt;&gt;&gt;[<span class="hljs-number">-14</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么写出一手漂亮的代码-转载（菜鸟学Python）</title>
    <link href="/2018/02/08/How_to_code_Python/"/>
    <url>/2018/02/08/How_to_code_Python/</url>
    
    <content type="html"><![CDATA[<blockquote><p>菜鸟学Python的第138篇原创文章</p></blockquote><h1 id="1-打印index"><a href="#1-打印index" class="headerlink" title="1.打印index"></a>1.打印index</h1><p>对于一个列表，或者说一个序列我们经常需要打印它的index,一般传统的做法或者说比较low的写法：</p><pre><code class="hljs python"><span class="hljs-comment"># Bad way</span>cities = [<span class="hljs-string">&#x27;Shanghai&#x27;</span>,<span class="hljs-string">&#x27;Beijing&#x27;</span>,<span class="hljs-string">&#x27;Shenzhen&#x27;</span>,<span class="hljs-string">&#x27;Chengdu&#x27;</span>]i = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> cities:    print(i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;--&gt;&#x27;</span>,c)    i += <span class="hljs-number">1</span>&gt;&gt;&gt;1 --&gt; Shanghai2 --&gt; Beijing3 --&gt; Shenzhen4 --&gt; Chengdu</code></pre><p>优雅写法是多用<strong>enumerate</strong></p><pre><code class="hljs python"><span class="hljs-comment"># Good way</span><span class="hljs-keyword">for</span> i ,city <span class="hljs-keyword">in</span> enumerate(cities):    print(i + <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;--&gt;&#x27;</span>,city)&gt;&gt;&gt;1 --&gt; Shanghai2 --&gt; Beijing3 --&gt; Shenzhen4 --&gt; Chengdu</code></pre><h2 id="Python内置enumerate-函数"><a href="#Python内置enumerate-函数" class="headerlink" title="Python内置enumerate()函数"></a>Python内置enumerate()函数</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>enumerate(sequence, [start=0])</code></p><ul><li>sequence – 一个序列、迭代器或其他支持迭代对象。</li><li>start – 下标起始位置。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回 enumerate(枚举) 对象。</p><h1 id="2-两个序列的循环"><a href="#2-两个序列的循环" class="headerlink" title="2.两个序列的循环"></a>2.两个序列的循环</h1><p>我们会经常对两个序列进行计算或者处理，比较low的方法是用下标去循环处理：</p><pre><code class="hljs python">names = [<span class="hljs-string">&#x27;leo&#x27;</span>,<span class="hljs-string">&#x27;jack&#x27;</span>,<span class="hljs-string">&#x27;john&#x27;</span>,<span class="hljs-string">&#x27;james&#x27;</span>]colors = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;yellow&#x27;</span>]<span class="hljs-comment"># Bad way</span>n = min(len(names),len(colors))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):    print(names[i],<span class="hljs-string">&#x27;--&gt;&#x27;</span>,colors[i])&gt;&gt;&gt;leo --&gt; redjack --&gt; greenjohn --&gt; bluejames --&gt; yellow</code></pre><p>更优雅一点的方法:用<strong>zip</strong>轻松搞定:</p><pre><code class="hljs python">names = [<span class="hljs-string">&#x27;leo&#x27;</span>,<span class="hljs-string">&#x27;jack&#x27;</span>,<span class="hljs-string">&#x27;john&#x27;</span>,<span class="hljs-string">&#x27;james&#x27;</span>]colors = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;yellow&#x27;</span>]<span class="hljs-comment"># Good way</span><span class="hljs-keyword">for</span> name ,color <span class="hljs-keyword">in</span> zip(names,colors):    print(name,<span class="hljs-string">&#x27;--&gt;&#x27;</span>,color)&gt;&gt;&gt;leo --&gt; redjack --&gt; greenjohn --&gt; bluejames --&gt; yellow</code></pre><h1 id="3-变换变量"><a href="#3-变换变量" class="headerlink" title="3.变换变量"></a>3.变换变量</h1><p>多个变量之间的交换，相信很多有c,c++语言基础的同学对这个再熟悉不过了，比如我们经典的冒泡排序，就会用这一招，看看比较传统的做法先:</p><pre><code class="hljs python">x = <span class="hljs-number">1</span>y = <span class="hljs-number">2</span><span class="hljs-comment"># Bad way</span>print(<span class="hljs-string">&#x27;&gt;&gt;Before:x=&#123;&#125;,y=&#123;&#125;&#x27;</span>.format(x,y))tmp = yy = xx = tmpprint(<span class="hljs-string">&#x27;&gt;&gt;After:x=&#123;&#125;,y=&#123;&#125;&#x27;</span>.format(x,y))&gt;&gt;&gt;&gt;&gt;Before:x=<span class="hljs-number">1</span>,y=<span class="hljs-number">2</span>&gt;&gt;After:x=<span class="hljs-number">2</span>,y=<span class="hljs-number">1</span></code></pre><p>更优雅的做法是：</p><pre><code class="hljs python">x = <span class="hljs-number">1</span>y = <span class="hljs-number">2</span><span class="hljs-comment"># Good way</span>print(<span class="hljs-string">&#x27;&gt;&gt;Before:x=&#123;&#125;,y=&#123;&#125;&#x27;</span>.format(x,y))x,y = y,xprint(<span class="hljs-string">&#x27;&gt;&gt;After:x=&#123;&#125;,y=&#123;&#125;&#x27;</span>.format(x,y))&gt;&gt;&gt;&gt;&gt;Before:x=<span class="hljs-number">1</span>,y=<span class="hljs-number">2</span>&gt;&gt;After:x=<span class="hljs-number">2</span>,y=<span class="hljs-number">1</span></code></pre><h1 id="4-字典的读取"><a href="#4-字典的读取" class="headerlink" title="4.字典的读取"></a>4.字典的读取</h1><p>字典是我们经常使用的数据结构，对于字典的访问和读取，如果我们的读取的字典的key为空怎么办，一般我们需要一个缺省值,菜鸟的写法:</p><pre><code class="hljs python">students=&#123;    <span class="hljs-string">&#x27;LILI&#x27;</span>:<span class="hljs-number">18</span>,    <span class="hljs-string">&#x27;Sam&#x27;</span>:<span class="hljs-number">25</span>&#125;<span class="hljs-comment">#Bad way</span><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Susan&#x27;</span> <span class="hljs-keyword">in</span> students:    student = students[<span class="hljs-string">&#x27;Susan&#x27;</span>]<span class="hljs-keyword">else</span>:    student=<span class="hljs-string">&#x27;unknow&#x27;</span>print(<span class="hljs-string">&#x27;Susan is &#123;&#125; years old&#x27;</span>.format(student))&gt;&gt;&gt;Susan <span class="hljs-keyword">is</span> unknow years old</code></pre><p>比较优雅的做法是:</p><pre><code class="hljs python">students=&#123;    <span class="hljs-string">&#x27;LILI&#x27;</span>:<span class="hljs-number">18</span>,    <span class="hljs-string">&#x27;Sam&#x27;</span>:<span class="hljs-number">25</span>&#125;<span class="hljs-comment"># Good way</span>student = students.get(<span class="hljs-string">&#x27;Susan&#x27;</span>,<span class="hljs-string">&#x27;unknow&#x27;</span>)print(<span class="hljs-string">&#x27;Susan is &#123;&#125; years old&#x27;</span>.format(student))</code></pre><p>巧妙的利用了字典get的用法，如果字典里面没有Susan这个key,则用unknow来表示缺省值！</p><h1 id="5-文件读取查找"><a href="#5-文件读取查找" class="headerlink" title="5.文件读取查找"></a>5.文件读取查找</h1><p>通常来说，我们要打开一个文件，然后对文件的内容进行循环读取和处理，菜鸟的写法如下：</p><pre><code class="hljs python"><span class="hljs-comment">#Bad way</span>f = open(<span class="hljs-string">&#x27;data.txt&#x27;</span>)<span class="hljs-keyword">try</span>:    text = f.read()    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> text.split(<span class="hljs-string">&#x27;\n&#x27;</span>):        print(line)<span class="hljs-keyword">finally</span>:    f.close()</code></pre><p>更优雅的写法：</p><pre><code class="hljs python"><span class="hljs-comment">#Good way</span><span class="hljs-keyword">with</span> open(<span class="hljs-string">&#x27;data.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:        print(line.strip(<span class="hljs-string">&#x27;\n&#x27;</span>))</code></pre><h1 id="6-循环查找"><a href="#6-循环查找" class="headerlink" title="6.循环查找"></a>6.循环查找</h1><p>我们经常会在一个大的循环中作搜索业务，比如从一个文件中搜索关键字，比如从文件名列表中查找一些特殊的文件名，想当然的写法如下：</p><pre><code class="hljs python">target_letter = <span class="hljs-string">&#x27;d&#x27;</span>letters = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<span class="hljs-comment">#Bad way</span>found = <span class="hljs-literal">False</span><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> letters:    <span class="hljs-keyword">if</span> letter == target_letter:        print(<span class="hljs-string">&#x27;Found&#x27;</span>)        found = <span class="hljs-literal">True</span>        <span class="hljs-keyword">break</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found:    print(<span class="hljs-string">&#x27;Not found&#x27;</span>)&gt;&gt;&gt;Not found</code></pre><p>更优雅的写法：</p><pre><code class="hljs python">target_letter = <span class="hljs-string">&#x27;d&#x27;</span>letters = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<span class="hljs-comment">#Good way</span><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> letters:    <span class="hljs-keyword">if</span> letter == target_letter:        print(<span class="hljs-string">&#x27;Found&#x27;</span>)        <span class="hljs-keyword">break</span><span class="hljs-keyword">else</span>:    print(<span class="hljs-string">&#x27;Not found&#x27;</span>)&gt;&gt;&gt;Not found</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python操作MySQL数据库</title>
    <link href="/2018/01/25/Python_MySQL/"/>
    <url>/2018/01/25/Python_MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="Python3连接MySQL数据库"><a href="#Python3连接MySQL数据库" class="headerlink" title="Python3连接MySQL数据库"></a>Python3连接MySQL数据库</h1><p>使用Python3的<strong>PyMySQL</strong>库连接MySQL数据库，实现简单的增删改查。</p><h2 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h2><p>PyMySQL是在Python3中用于连接MySQL服务器的一个库。（Python2使用的是mysqldb。）</p><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p><strong>实例：</strong>连接test数据库</p><pre><code class="hljs javascript">#encoding=utf-8<span class="hljs-keyword">import</span> pymysql# 打开数据库连接&quot;localhost&quot;:本地服务器,&quot;root&quot;:用户名,&quot;666666&quot;:密码,&quot;test&quot;:数据库名db = pymysql.connect(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;666666&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>)# 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor()# 使用 execute()  方法执行 SQL 查询cursor.execute(<span class="hljs-string">&quot;SELECT VERSION()&quot;</span>)# 使用 fetchone() 方法获取单条数据.data = cursor.fetchone()print(<span class="hljs-string">&quot;Database version: %s &quot;</span> %data)# 关闭数据库db.close()</code></pre><p>输出的结果为：<code>Database version: 5.6.39 </code></p><h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><p><strong>实例：</strong>用**execute()**方法来为数据库创建表</p><pre><code class="hljs javascript"># encoding=utf-8<span class="hljs-keyword">import</span> pymysql# 打开数据库连接&quot;localhost&quot;:本地服务器,&quot;root&quot;:用户名,&quot;666666&quot;:密码,&quot;test&quot;:数据库名db = pymysql.connect(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;666666&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>)# 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor()# 使用 execute() 方法执行 SQL，如果表存在则删除cursor.execute(<span class="hljs-string">&quot;DROP TABLE IF EXISTS testPyMySQL_tbl&quot;</span>)sql = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;CREATE TABLE testPyMySQL_tbl(</span><span class="hljs-string">         FIRST_NAME  CHAR(20) NOT NULL,</span><span class="hljs-string">         LAST_NAME  CHAR(20),</span><span class="hljs-string">         AGE INT,  </span><span class="hljs-string">         SEX CHAR(1),</span><span class="hljs-string">         INCOME FLOAT)&quot;</span><span class="hljs-string">&quot;&quot;</span>cursor.execute(sql)# 关闭数据库连接db.close()</code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p><strong>实例：</strong>向数据表testPyMySQL_tbl插入数据：</p><pre><code class="hljs javascript">#!<span class="hljs-regexp">/usr/</span>bin/python3#encoding=utf-8#使用执行 SQL INSERT 语句向表 testPyMySQL_tbl 插入记录：<span class="hljs-keyword">import</span> pymysql# 打开数据库连接db = pymysql.connect(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;666666&quot;</span>,<span class="hljs-string">&quot;test&quot;</span> )# 使用cursor()方法获取操作游标cursor = db.cursor()# SQL 插入语句sql = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;INSERT INTO testPyMySQL_tbl(FIRST_NAME,</span><span class="hljs-string">         LAST_NAME, AGE, SEX, INCOME)</span><span class="hljs-string">         VALUES (&#x27;SAO&#x27;, &#x27;A&#x27;, 25, &#x27;M&#x27;, 10000)&quot;</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">try</span>:   # 执行sql语句   cursor.execute(sql)   # 提交到数据库执行   db.commit()except:   # 如果发生错误则回滚   db.rollback()# 关闭数据库连接db.close()</code></pre><h2 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h2><p>Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。</p><ul><li><strong>fetchone()</strong>: 该方法获取下一个查询结果集。结果集是一个对象</li><li><strong>fetchall()</strong>: 接收全部的返回结果行.</li><li><strong>rowcount</strong>: 这是一个只读属性，并返回执行execute()方法后影响的行数。</li></ul><p><strong>实例：</strong>查询testPyMySQL_tbl表中工资大于1000的所有数据：</p><pre><code class="hljs javascript">mysql&gt; SELECT * FROM testPyMySQL_tbl;+------------+-----------+------+------+--------+| FIRST_NAME | LAST_NAME | AGE  | SEX  | INCOME |+------------+-----------+------+------+--------+| SAO        | A         |   <span class="hljs-number">25</span> | M    |  <span class="hljs-number">10000</span> || SAO        | B         |   <span class="hljs-number">25</span> | M    |  <span class="hljs-number">10000</span> || SAO        | C         |   <span class="hljs-number">25</span> | M    |  <span class="hljs-number">10000</span> || SAO        | D         |   <span class="hljs-number">25</span> | M    |  <span class="hljs-number">10000</span> || SAO        | F         |   <span class="hljs-number">25</span> | M    |    <span class="hljs-number">500</span> || SAO        | G         |   <span class="hljs-number">25</span> | M    |   <span class="hljs-number">1000</span> || SAO        | H         |   <span class="hljs-number">25</span> | M    |   <span class="hljs-number">1100</span> |+------------+-----------+------+------+--------+<span class="hljs-number">7</span> rows <span class="hljs-keyword">in</span> set (<span class="hljs-number">0.00</span> sec)# encoding=utf-8<span class="hljs-keyword">import</span> pymysql# 打开数据库连接db = pymysql.connect(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;666666&quot;</span>,<span class="hljs-string">&quot;test&quot;</span> )# 使用cursor()方法获取操作游标cursor = db.cursor()# SQL 查询语句sql = <span class="hljs-string">&quot;SELECT * FROM testPyMySQL_tbl \</span><span class="hljs-string">       WHERE INCOME &gt; &#x27;%d&#x27;&quot;</span> % (<span class="hljs-number">1000</span>)<span class="hljs-keyword">try</span>:   # 执行SQL语句   cursor.execute(sql)   # 获取所有记录列表   results = cursor.fetchall()   <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> results:      fname = row[<span class="hljs-number">0</span>]      lname = row[<span class="hljs-number">1</span>]      age = row[<span class="hljs-number">2</span>]      sex = row[<span class="hljs-number">3</span>]      income = row[<span class="hljs-number">4</span>]       # 打印结果      print (<span class="hljs-string">&quot;fname=%s,lname=%s,age=%d,sex=%s,income=%d&quot;</span> % \             (fname, lname, age, sex, income ))except:   print (<span class="hljs-string">&quot;Error: unable to fetch data&quot;</span>)# 关闭数据库连接db.close()</code></pre><p>结果：<br>fname=SAO,lname=A,age=25,sex=M,income=10000<br>fname=SAO,lname=B,age=25,sex=M,income=10000<br>fname=SAO,lname=C,age=25,sex=M,income=10000<br>fname=SAO,lname=D,age=25,sex=M,income=10000<br>fname=SAO,lname=H,age=25,sex=M,income=1100</p><h2 id="数据库更新操作"><a href="#数据库更新操作" class="headerlink" title="数据库更新操作"></a>数据库更新操作</h2><p><strong>实例：</strong>#更新操作用于更新数据表的的数据，以下实例将 testPyMySQL_tbl表中的 SEX 为 ‘M’的AGE 字段递增1：</p><pre><code class="hljs javascript">#encoding=utf-8<span class="hljs-keyword">import</span> pymysql# 打开数据库连接db = pymysql.connect(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;666666&quot;</span>,<span class="hljs-string">&quot;test&quot;</span> )# 使用cursor()方法获取操作游标cursor = db.cursor()# SQL 更新语句sql = <span class="hljs-string">&quot;UPDATE testPyMySQL_tbl SET AGE = AGE + 1 WHERE SEX = &#x27;%c&#x27;&quot;</span> % (<span class="hljs-string">&#x27;M&#x27;</span>)<span class="hljs-keyword">try</span>:   # 执行SQL语句   cursor.execute(sql)   # 提交到数据库执行   db.commit()except:   # 发生错误时回滚   db.rollback()# 关闭数据库连接db.close()</code></pre><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除表中的数值<br><strong>实例：</strong>删除表中AGE小于18的所有数据：</p><pre><code class="hljs javascript">mysql&gt; SELECT * FROM testPyMySQL_tbl;+------------+-----------+------+------+--------+| FIRST_NAME | LAST_NAME | AGE  | SEX  | INCOME |+------------+-----------+------+------+--------+| SAO        | A         |   <span class="hljs-number">16</span> | M    |  <span class="hljs-number">10000</span> || SAO        | B         |   <span class="hljs-number">27</span> | M    |  <span class="hljs-number">10000</span> || SAO        | C         |   <span class="hljs-number">18</span> | M    |  <span class="hljs-number">10000</span> || SAO        | D         |   <span class="hljs-number">15</span> | M    |  <span class="hljs-number">10000</span> || SAO        | F         |   <span class="hljs-number">27</span> | M    |    <span class="hljs-number">500</span> || SAO        | G         |   <span class="hljs-number">27</span> | M    |   <span class="hljs-number">1000</span> || SAO        | H         |   <span class="hljs-number">17</span> | M    |   <span class="hljs-number">1100</span> |+------------+-----------+------+------+--------+<span class="hljs-number">7</span> rows <span class="hljs-keyword">in</span> set (<span class="hljs-number">0.00</span> sec)# encoding=utf-8<span class="hljs-keyword">import</span> pymysql# 打开数据库连接db = pymysql.connect(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;666666&quot;</span>,<span class="hljs-string">&quot;test&quot;</span> )# 使用cursor()方法获取操作游标cursor = db.cursor()# SQL 删除语句sql = <span class="hljs-string">&quot;DELETE FROM testPyMySQL_tbl WHERE AGE &lt; &#x27;%d&#x27;&quot;</span> % (<span class="hljs-number">18</span>)<span class="hljs-keyword">try</span>:   # 执行SQL语句   cursor.execute(sql)   # 提交修改   db.commit()except:   # 发生错误时回滚   db.rollback()# 关闭连接db.close()mysql&gt; SELECT * FROM testPyMySQL_tbl;+------------+-----------+------+------+--------+| FIRST_NAME | LAST_NAME | AGE  | SEX  | INCOME |+------------+-----------+------+------+--------+| SAO        | B         |   <span class="hljs-number">27</span> | M    |  <span class="hljs-number">10000</span> || SAO        | C         |   <span class="hljs-number">18</span> | M    |  <span class="hljs-number">10000</span> || SAO        | F         |   <span class="hljs-number">27</span> | M    |    <span class="hljs-number">500</span> || SAO        | G         |   <span class="hljs-number">27</span> | M    |   <span class="hljs-number">1000</span> |+------------+-----------+------+------+--------+<span class="hljs-number">4</span> rows <span class="hljs-keyword">in</span> set (<span class="hljs-number">0.00</span> sec)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL从入门到删库跑路</title>
    <link href="/2018/01/19/MySQL/"/>
    <url>/2018/01/19/MySQL/</url>
    
    <content type="html"><![CDATA[<p>Mysql是最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p><a id="more"></a><h1 id="一、什么是数据库？"><a href="#一、什么是数据库？" class="headerlink" title="一、什么是数据库？"></a>一、什么是数据库？</h1><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。<br>RDBMS即关系数据库管理系统(Relational Database Management System)的特点：</p><ul><li>数据以表格的形式出现</li><li>每行为各种记录名称</li><li>每列为记录名称所对应的数据域</li><li>许多的行和列组成一张表单</li><li>若干的表单组成database</li></ul><h1 id="二、RDBMS-术语"><a href="#二、RDBMS-术语" class="headerlink" title="二、RDBMS 术语"></a>二、RDBMS 术语</h1><ul><li>数据库: 数据库是一些关联表的集合。.</li><li>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li>列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li><li>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li><li>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li><li>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li><li>外键：外键用于关联两个表。</li><li>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li><li>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li><li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li></ul><h1 id="三、使用MySQL-Client执行简单的SQL命令"><a href="#三、使用MySQL-Client执行简单的SQL命令" class="headerlink" title="三、使用MySQL Client执行简单的SQL命令"></a>三、使用MySQL Client执行简单的SQL命令</h1><p>连接到MySQL服务器上，在MAC上，可以先到<strong>系统偏好设置</strong>里将MySQL服务打开：<br><img src="/img/mysql/start_MySQL.png"><br><img src="/img/mysql/start_MySQL2.png"></p><p>在终端输入命令：</p><pre><code class="hljs sql">ecarry:~ ecarry$ mysql -u root -p</code></pre><blockquote><p>其中 -u为用户，后面紧跟root，意为以root账户登录， -p为密码</p></blockquote><pre><code class="hljs sql">ecarry:~ ecarry$ mysql -u root -pEnter password: mysql&gt;</code></pre><h1 id="四、更改密码"><a href="#四、更改密码" class="headerlink" title="四、更改密码"></a>四、更改密码</h1><p>老版本的MySQL安装成功后，默认的root用户和密码为空，可以使用命令来创建root用户和密码：</p><blockquote><p>我使用MySQL的版本是5.6.39，可以用<code>mysql --version</code>命令来查看当前版本</p></blockquote><pre><code class="hljs sql">ecarry:~ ecarry$ mysql <span class="hljs-comment">--version</span>mysql  Ver 14.14 Distrib 5.6.39, for macos10.13 (x86_64) using  EditLine wrapper</code></pre><p>使用<code>mysqladmin -u root password &quot;new_password&quot;</code>来更改密码:</p><pre><code class="hljs sql">ecarry:~ ecarry$ mysqladmin -u root password new_password</code></pre><h1 id="五、基本操作"><a href="#五、基本操作" class="headerlink" title="五、基本操作"></a>五、基本操作</h1><h2 id="5-1-MySQL用户设置"><a href="#5-1-MySQL用户设置" class="headerlink" title="5.1 MySQL用户设置"></a>5.1 MySQL用户设置</h2><p>添加MySQL用户，在mysql数据库中的user表添加新用户即可。<br>下面实例将添加用户名为guest，密码为guest123，权限可进行<strong>SELECT</strong>,<strong>INSERT</strong>和<strong>UPDATE</strong>操作权限：</p><pre><code class="hljs sql">mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup <span class="hljs-keyword">with</span> -A<span class="hljs-keyword">Database</span> <span class="hljs-keyword">changed</span>mysql&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span>    -&gt; (host,<span class="hljs-keyword">user</span>,<span class="hljs-keyword">password</span>,    -&gt; select_priv,insert_priv,update_priv)    -&gt; <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-string">&#x27;guest&#x27;</span>,    -&gt; <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">&#x27;guest123&#x27;</span>),<span class="hljs-string">&#x27;Y&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>);Query OK, 1 row affected, 3 warnings (0.00 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT host,user,password FROM user WHERE user = &#x27;guest&#x27;;+<span class="hljs-comment">-----------+-------+-------------------------------------------+</span>| host      | user  | password                                  |+<span class="hljs-comment">-----------+-------+-------------------------------------------+</span>| localhost | guest | *F1573429579994EEA4459170FDAC55DF96C4BBE6 |+<span class="hljs-comment">-----------+-------+-------------------------------------------+</span>1 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>在添加用户时，请注意使用MySQL提供的PASSWORD()函数来对密码进行加密，可以在后面看到密码为：*F1573429579994EEA4459170FDAC55DF96C4BBE6</p><p><strong>注意：</strong>在MySQL5.7中user表的password换成了authentication_string。<br><strong>注意：</strong><code>FLUSH PRIVILEGES</code>语句，这个命令执行后会重新载入授权表。不使用这个命令，将无法使用新创建的用户来连接MySQL服务器，除非重启MySQL服务器。<br>在创建用户时，可以给用户指定权限，在对应权限列中，在插入语句中设置为’Y’即可。</p><p><strong>用户权限表：</strong></p><ul><li>SELECT_PRIV：选择数据</li><li>INSERT_PRIV：插入数据</li><li>UPDATE_PRIV：修改现有数据</li><li>DELETE_PRIV：删除现有数据</li><li>CREATE_PRIV：创建新的数据库和表</li><li>DROP_PRIV：删除现有数据库和表</li><li>RELOAD_PRIV：执行刷新和重新加载MySQL所用各种内部缓存的特定命令，包括日志，权限，主机，查询和表</li><li>SHUTDOWN_PRIV：关闭MySQL服务器</li><li>PROCESS_PRIV：可以通过SHOW PROCESSLIST命令查看其它用户的进程</li><li>FILE_PRIV：执行SELECT INTO OUTFILE 和LOADDATA INFILE命令</li><li>GRANT_PRIV：将已经授予给该用户自己的权限再授予其它用户。</li><li>REFERENCES_PRIV</li><li>INDEX_PRIV：创建和删除表索引</li><li>ALTER_PRIV：重命名和修改表结构</li></ul><h3 id="5-1-1-管理MySQL的命令"><a href="#5-1-1-管理MySQL的命令" class="headerlink" title="5.1.1 管理MySQL的命令"></a>5.1.1 管理MySQL的命令</h3><p> <strong>SHOW DATABASES</strong><br>列出MySQL数据库管理系统的数据库列表：</p><pre><code class="hljs sql">mysql&gt; SHOW DATABASES;+<span class="hljs-comment">--------------------+</span>| Database           |+<span class="hljs-comment">--------------------+</span>| information_schema || test               |+<span class="hljs-comment">--------------------+</span>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p> <strong>USE 数据库名</strong><br>选择要操作的MySQL数据库，使用这命令后所有mysql命令都只针对该数据库。</p><pre><code class="hljs sql">mysql&gt; USE test;Database changed</code></pre><p> <strong>SHOW TABLES</strong><br>显示指定数据库的所有表，使用该命令前需要使用USE命令来选择要操作的数据库。</p><pre><code class="hljs sql">mysql&gt; USE mysql;Database changedmysql&gt; SHOW TABLES;+<span class="hljs-comment">---------------------------+</span>| Tables_in_mysql           |+<span class="hljs-comment">---------------------------+</span>| columns_priv              || db                        || event                     || time_zone_transition_type || user                      |+<span class="hljs-comment">---------------------------+</span>28 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p> <strong>SHOW COLUMNS FROM 数据表</strong><br>显示数据表的属性，属性类型，主键信息，是否为NULL，默认值等 其他信息。</p><pre><code class="hljs sql">mysql&gt; SHOW COLUMNS FROM user;+<span class="hljs-comment">------------------------+-----------------------------------+------+-----+-----------------------+-------+</span>| Field                  | Type                              | Null | Key | Default               | Extra |+<span class="hljs-comment">------------------------+-----------------------------------+------+-----+-----------------------+-------+</span>| Host                   | char(60)                          | NO   | PRI |                       |       || User                   | char(16)                          | NO   | PRI |                       |       || Password               | char(41)                          | NO   |     |                       |       || Select_priv            | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || ssl_type               | enum(&#x27;&#x27;,&#x27;ANY&#x27;,&#x27;X509&#x27;,&#x27;SPECIFIED&#x27;) | NO   |     |                       |       || x509_subject           | blob                              | NO   |     | NULL                  |       || max_user_connections   | int(11) unsigned                  | NO   |     | 0                     |       || plugin                 | char(64)                          | YES  |     | mysql_native_password |       || authentication_string  | text                              | YES  |     | NULL                  |       || password_expired       | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       |+<span class="hljs-comment">------------------------+-----------------------------------+------+-----+-----------------------+-------+</span>43 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p> <strong>SHOW INDES FROM 数据表</strong><br>显示数据表的详细索引信息，包括PRIMARY KEY（主键）。</p><pre><code class="hljs sql">mysql&gt; SHOW INDEX FROM user;+<span class="hljs-comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | <span class="hljs-keyword">Comment</span> | Index_comment |+<span class="hljs-comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>| <span class="hljs-keyword">user</span>  |          <span class="hljs-number">0</span> | PRIMARY  |            <span class="hljs-number">1</span> | Host        | A         |        <span class="hljs-literal">NULL</span> |     <span class="hljs-literal">NULL</span> | <span class="hljs-literal">NULL</span>   |      | BTREE      |         |               || <span class="hljs-keyword">user</span>  |          <span class="hljs-number">0</span> | PRIMARY  |            <span class="hljs-number">2</span> | <span class="hljs-keyword">User</span>        | A         |           <span class="hljs-number">7</span> |     <span class="hljs-literal">NULL</span> | <span class="hljs-literal">NULL</span>   |      | BTREE      |         |               |+<span class="hljs-comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><h2 id="5-2-MySQL创建数据库"><a href="#5-2-MySQL创建数据库" class="headerlink" title="5.2 MySQL创建数据库"></a>5.2 MySQL创建数据库</h2><p><strong>使用mysqladmin创建数据库：</strong></p><pre><code class="hljs sql">ecarry:~ ecarry$ mysqladmin -u root -p <span class="hljs-keyword">create</span> <span class="hljs-keyword">test</span>Enter <span class="hljs-keyword">password</span>:</code></pre><h2 id="5-3-MySQL删除数据库"><a href="#5-3-MySQL删除数据库" class="headerlink" title="5.3 MySQL删除数据库"></a>5.3 MySQL删除数据库</h2><p> <strong>使用mysqladmin删除数据库：</strong></p><pre><code class="hljs sql">ecarry:~ ecarry$ mysqladmin -u root -p <span class="hljs-keyword">drop</span> <span class="hljs-keyword">test</span>Enter <span class="hljs-keyword">password</span>:Dropping the <span class="hljs-keyword">database</span> <span class="hljs-keyword">is</span> potentially a very bad thing <span class="hljs-keyword">to</span> do.<span class="hljs-keyword">Any</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">stored</span> <span class="hljs-keyword">in</span> the <span class="hljs-keyword">database</span> will be destroyed.<span class="hljs-keyword">Do</span> you really want <span class="hljs-keyword">to</span> <span class="hljs-keyword">drop</span> the <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-keyword">database</span> [y/N] y<span class="hljs-keyword">Database</span> <span class="hljs-string">&quot;test&quot;</span> dropped</code></pre><h2 id="5-4-MySQL数据类型"><a href="#5-4-MySQL数据类型" class="headerlink" title="5.4 MySQL数据类型"></a>5.4 MySQL数据类型</h2><p>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串（字符）类型。</p><p> <strong>数值类型</strong></p><p>MySQL支持所有标准SQL数值数据类型。<br>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。<br>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。<br>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。<br>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p><table><thead><tr><th>类型</th><th align="center">大小</th><th align="center">范围（有符号）</th><th align="center">范围（无符号）</th><th align="center">用途</th></tr></thead><tbody><tr><td>TINYINT</td><td align="center">1字节</td><td align="center">(-128，127)</td><td align="center">(0，255)</td><td align="center">小整数值</td></tr><tr><td>SMALLINT</td><td align="center">2字节</td><td align="center">(-32 768，32 767)</td><td align="center">(0，65 535)</td><td align="center">大整数值</td></tr><tr><td>MEDIUMINT</td><td align="center">3字节</td><td align="center">(-8 388 608，8 388 607)</td><td align="center">(0，16 777 215)</td><td align="center">大整数值</td></tr><tr><td>INT或INTEGER</td><td align="center">4字节</td><td align="center">(-2 147 483 648，<br>2 147 483 647)</td><td align="center">(0，4 294 967 295)</td><td align="center">大整数值</td></tr><tr><td>BIGINT</td><td align="center">8字节</td><td align="center">(-9 233 372 036 854 775 808，<br>9 223 372 036 854 775 807)</td><td align="center">(0，18 446 744 073 709 551 615)</td><td align="center">极大整数值</td></tr><tr><td>FLOAT</td><td align="center">4字节</td><td align="center">(-3.402 823 466 E+38，<br>-1.175 494 351 E-38)，0，(1.175 494 351 E-38，<br>3.402 823 466 351 E+38)</td><td align="center">0，(1.175 494 351 E-38，<br>3.402 823 466 E+38)</td><td align="center">单精度/浮点数值</td></tr><tr><td>DOUBLE</td><td align="center">8字节</td><td align="center">(-1.797 693 134 862 315 7 E+308，<br>-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，<br>1.797 693 134 862 315 7 E+308)</td><td align="center">0，(2.225 073 858 507 201 4 E-308，<br>1.797 693 134 862 315 7 E+308)</td><td align="center">双精度/浮点数值</td></tr><tr><td>DECIMAL</td><td align="center">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="center">依赖于M和D的值</td><td align="center">依赖于M和D的值</td><td align="center">小数值</td></tr></tbody></table><p> <strong>日期和时间类型</strong></p><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。<br>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。<br>TIMESTAMP类型有专有的自动更新特性。</p><table><thead><tr><th>类型</th><th align="center">大小(字节）</th><th align="center">范围</th><th align="center">格式</th><th align="center">用途</th></tr></thead><tbody><tr><td>DATE</td><td align="center">3</td><td align="center">1000-01-01<br>9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">日期值</td></tr><tr><td>TIME</td><td align="center">3</td><td align="center">-838:59:59’/‘838:59:59</td><td align="center">HH:MM:SS</td><td align="center">时间值或持续时间</td></tr><tr><td>YEAR</td><td align="center">1</td><td align="center">1901/2155</td><td align="center">YYYY</td><td align="center">年份值</td></tr><tr><td>DATETIME</td><td align="center">8</td><td align="center">1000-01-01 00:00:00<br>9999-12-31 23:59:59</td><td align="center">YYYY-MM-DD<br>HH:MM:SS</td><td align="center">混合日期和<br>时间值</td></tr><tr><td>TIMESTAMP</td><td align="center">4</td><td align="center">1970-01-01 00:00:00/2038</td><td align="center">YYYYMMDD<br>HHMMSS</td><td align="center">混合日期和时间值<br>时间戳</td></tr></tbody></table><p> <strong>字符串类型</strong></p><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。</p><table><thead><tr><th>类型</th><th align="center">大小(字节）</th><th align="center">用途</th></tr></thead><tbody><tr><td>CHAR</td><td align="center">0-255</td><td align="center">定长字符串</td></tr><tr><td>VARCHAR</td><td align="center">0-65535</td><td align="center">变长字符串</td></tr><tr><td>TINYBLOB</td><td align="center">0-255</td><td align="center">不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td align="center">0-255</td><td align="center">短文本字符串</td></tr><tr><td>BLOB</td><td align="center">0-65 535</td><td align="center">二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td align="center">0-65 535</td><td align="center">长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td align="center">0-16 777 215</td><td align="center">二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td align="center">0-16 777 215</td><td align="center">中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td align="center">0-4 294 967 295</td><td align="center">二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td align="center">0-4 294 967 295</td><td align="center">极大文本数据</td></tr></tbody></table><ul><li>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</li><li>BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</li><li>BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。</li><li>有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。</li></ul><h2 id="5-5-MySQL创建数据表"><a href="#5-5-MySQL创建数据表" class="headerlink" title="5.5 MySQL创建数据表"></a>5.5 MySQL创建数据表</h2><p>创建MySQL数据表需要以下信息：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><p><strong>语法</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name (column_name column_type);</code></pre><p>下面通过实例在test数据库中创建数据表test_tbl：</p><pre><code class="hljs sql">mysql&gt; USE test;Database changedmysql&gt; SHOW TABLES;Empty <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test_tbl(    -&gt; <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,    -&gt; <span class="hljs-keyword">name</span> <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    -&gt; age <span class="hljs-built_in">int</span>(<span class="hljs-number">9</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    -&gt; sex <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    -&gt; submission_date <span class="hljs-built_in">DATE</span>,    -&gt; PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-keyword">id</span>));Query OK, 0 rows affected (0.03 sec)</code></pre><p>创建成功后，可以通过命令来查看表结构：</p><pre><code class="hljs sql">mysql&gt; SHOW TABLES;+<span class="hljs-comment">----------------+</span>| Tables_in_test |+<span class="hljs-comment">----------------+</span>| test_tbl       |+<span class="hljs-comment">----------------+</span>1 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">desc</span> test_tbl;+<span class="hljs-comment">-----------------+----------+------+-----+---------+----------------+</span>| Field           | Type     | Null | Key | Default | Extra          |+<span class="hljs-comment">-----------------+----------+------+-----+---------+----------------+</span>| id              | int(11)  | NO   | PRI | NULL    | auto_increment || name            | char(20) | NO   |     | NULL    |                || age             | int(9)   | NO   |     | NULL    |                || sex             | char(2)  | NO   |     | NULL    |                || submission_date | date     | YES  |     | NULL    |                |+<span class="hljs-comment">-----------------+----------+------+-----+---------+----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h2 id="5-6-MySQL删除数据表"><a href="#5-6-MySQL删除数据表" class="headerlink" title="5.6 MySQL删除数据表"></a>5.6 MySQL删除数据表</h2><p><strong>语法</strong><br><code>DROP TABLE 数据表名</code></p><pre><code class="hljs sql">mysql&gt; USE test;Database changedmysql&gt; SHOW TABLES;+<span class="hljs-comment">----------------+</span>| Tables_in_test |+<span class="hljs-comment">----------------+</span>| test_tbl       |+<span class="hljs-comment">----------------+</span>1 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> test_tbl;Query OK, 0 rows affected (0.8 sec)mysql&gt; SHOW TABLES;Empty <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><h2 id="5-7-MySQL插入数据"><a href="#5-7-MySQL插入数据" class="headerlink" title="5.7 MySQL插入数据"></a>5.7 MySQL插入数据</h2><p>MySQL 表中使用 <strong>INSERT INTO</strong> SQL语句来插入数据。</p><p><strong>实例</strong><br>向test_tbl插入数据：</p><pre><code class="hljs sql">mysql&gt; INSERT INTO test_tbl    -&gt; (name,age,sex,submission_date)    -&gt; VALUES    -&gt; (&quot;pangzi W&quot;,&quot;25&quot;,&quot;M&quot;,NOW());Query OK, 1 row affected, 1 warning (0.00 sec)mysql&gt; SELECT * FROM test_tbl;+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>| id | name     | age | sex | submission_date |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>|  1 | pangzi W |  25 | M   | 2018-01-22      |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>1 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><ul><li>没有提供id的数据，因为该字段我们在创建表的时候已经设置它为 AUTO_INCREMENT(自动增加) 属性，该字段会自动递增而不需要我们去设置。</li><li>NOW() 是一个 MySQL 函数，该函数返回日期和时间。</li></ul><h2 id="5-8-MySQL查询数据"><a href="#5-8-MySQL查询数据" class="headerlink" title="5.8 MySQL查询数据"></a>5.8 MySQL查询数据</h2><p>MySQL 数据库使用SQL SELECT语句来查询数据。<br><strong>语法</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name,column_name<span class="hljs-keyword">FROM</span> table_name[<span class="hljs-keyword">WHERE</span> Clause][<span class="hljs-keyword">LIMIT</span> N][ <span class="hljs-keyword">OFFSET</span> M]</code></pre><ul><li>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li><li>SELECT 命令可以读取一条或者多条记录。</li><li>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</li><li>你可以使用 WHERE 语句来包含任何条件。</li><li>你可以使用 LIMIT 属性来设定返回的记录数。</li><li>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</li></ul><p><strong>实例</strong><br>返回数据表所有数据：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM bili;+<span class="hljs-comment">----------+----------+---------+--------+----------+--------+--------+</span>| aid      | view     | danmaku | reply  | favorite | coin   | share  |+<span class="hljs-comment">----------+----------+---------+--------+----------+--------+--------+</span>|        0 |        0 |       0 |      0 |        0 |      0 |      0 ||        2 |       -1 |    1866 |   4888 |     1604 |    480 |   1292 ||        7 |  1158359 |   22770 |  23613 |     9991 |   2189 |    538 ||        9 |  1237494 |    5025 |   4858 |    10015 |    994 |    833 ||       11 |   168711 |    2087 |   2499 |     1336 |    165 |     33 ||       12 |   495352 |    1392 |   2501 |     3743 |    357 |    310 ||       16 |   108035 |    1492 |   1144 |      874 |     81 |     36 ||       20 |   157311 |    3833 |   1788 |     3347 |    361 |    104 ||       23 |       -1 |   40371 |   9711 |    29289 |   2570 |   4562 ||       24 |   196740 |    5105 |    855 |     2897 |    296 |    124 ||       25 |    62049 |     931 |    448 |      726 |     56 |     32 ||       26 |    86121 |    2166 |    574 |     1800 |    252 |    124 ||       28 |    54482 |    1474 |    627 |      396 |     49 |     17 ||       31 |    60681 |    1375 |    457 |      306 |     14 |     24 |+<span class="hljs-comment">----------+----------+---------+--------+----------+--------+--------+</span>14 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h2 id="5-9-MySQL-WHERE子句"><a href="#5-9-MySQL-WHERE子句" class="headerlink" title="5.9 MySQL WHERE子句"></a>5.9 MySQL WHERE子句</h2><p>有条件的选取数据，将WHERE子句添加到SELECT语句中。<br><strong>语法</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> field1, field2,...fieldN <span class="hljs-keyword">FROM</span> table_name1, table_name2...[<span class="hljs-keyword">WHERE</span> condition1 [<span class="hljs-keyword">AND</span> [<span class="hljs-keyword">OR</span>]] condition2.....</code></pre><ul><li>查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以使用 AND 或者 OR 指定一个或多个条件。</li><li>WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</li><li>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li></ul><p><strong>实例</strong><br>搜索数据表中的属性为女性数据：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM test_tbl;+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>| id | name     | age | sex | submission_date |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>|  1 | pangzi W |  25 | M   | 2018-01-22      ||  2 | san A    |  25 | M   | 2018-01-22      ||  3 | sao A    |  24 | M   | 2018-01-22      ||  4 | juju GOU |  26 | M   | 2018-01-22      ||  5 | li XIAO  |  23 | W   | 2018-01-22      ||  6 | nv JI    |  18 | W   | 2018-01-22      |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>6 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">FROM</span> test_tbl <span class="hljs-keyword">WHERE</span> sex = <span class="hljs-string">&#x27;W&#x27;</span>;+<span class="hljs-comment">----+---------+-----+-----+-----------------+</span>| id | name    | age | sex | submission_date |+<span class="hljs-comment">----+---------+-----+-----+-----------------+</span>|  5 | li XIAO |  23 | W   | 2018-01-22      ||  6 | nv JI   |  18 | W   | 2018-01-22      |+<span class="hljs-comment">----+---------+-----+-----+-----------------+</span>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><h2 id="5-10-MySQL-UPDATE查询"><a href="#5-10-MySQL-UPDATE查询" class="headerlink" title="5.10 MySQL UPDATE查询"></a>5.10 MySQL UPDATE查询</h2><p>如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL UPDATE 命令来操作。.<br><strong>语法</strong></p><p>以下是 UPDATE 命令修改 MySQL 数据表数据的通用 SQL 语法：</p><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name <span class="hljs-keyword">SET</span> field1=<span class="hljs-keyword">new</span>-value1, field2=<span class="hljs-keyword">new</span>-value2[<span class="hljs-keyword">WHERE</span> Clause]</code></pre><ul><li>你可以同时更新一个或多个字段。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以在一个单独表中同时更新数据。</li></ul><p><strong>实例</strong></p><p>更新test_tbl数据表id为1的name数据：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM test_tbl;+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>| id | name     | age | sex | submission_date |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>|  1 | pangzi W |  25 | M   | 2018-01-22      ||  2 | san A    |  25 | M   | 2018-01-22      ||  3 | sao A    |  24 | M   | 2018-01-22      ||  4 | juju GOU |  26 | M   | 2018-01-22      ||  5 | li XIAO  |  23 | W   | 2018-01-22      ||  6 | nv JI    |  18 | W   | 2018-01-22      |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>6 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">UPDATE</span> test_tbl <span class="hljs-keyword">SET</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;nv JI&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span>;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; SELECT * FROM test_tbl;+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>| id | name     | age | sex | submission_date |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>|  1 | nv JI    |  25 | M   | 2018-01-22      ||  2 | san A    |  25 | M   | 2018-01-22      ||  3 | sao A    |  24 | M   | 2018-01-22      ||  4 | juju GOU |  26 | M   | 2018-01-22      ||  5 | li XIAO  |  23 | W   | 2018-01-22      ||  6 | nv JI    |  18 | W   | 2018-01-22      |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>6 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h2 id="5-11-MySQL-DELETE语句"><a href="#5-11-MySQL-DELETE语句" class="headerlink" title="5.11 MySQL DELETE语句"></a>5.11 MySQL DELETE语句</h2><p><strong>语法</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name [<span class="hljs-keyword">WHERE</span> Clause]</code></pre><ul><li>如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</li><li>你可以在 WHERE 子句中指定任何条件</li><li>您可以在单个表中一次性删除记录。</li></ul><p><strong>实例</strong></p><p>删除test_tbl数据表id=5的数据：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM test_tbl;+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>| id | name     | age | sex | submission_date |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>|  1 | pangzi W |  25 | M   | 2018-01-22      ||  2 | san A    |  25 | M   | 2018-01-22      ||  3 | sao A    |  24 | M   | 2018-01-22      ||  4 | juju GOU |  26 | M   | 2018-01-22      ||  5 | li XIAO  |  23 | W   | 2018-01-22      ||  6 | nv JI    |  18 | W   | 2018-01-22      |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>6 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> test_tbl <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">5</span>;Query OK, 1 row affected (0.00 sec)mysql&gt; SELECT * FROM test_tbl;+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>| id | name     | age | sex | submission_date |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>|  1 | pangzi W |  25 | M   | 2018-01-22      ||  2 | san A    |  25 | M   | 2018-01-22      ||  3 | sao A    |  24 | M   | 2018-01-22      ||  4 | juju GOU |  26 | M   | 2018-01-22      ||  6 | nv JI    |  18 | W   | 2018-01-22      |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h2 id="5-12-MySQL-LIKE子句"><a href="#5-12-MySQL-LIKE子句" class="headerlink" title="5.12 MySQL LIKE子句"></a>5.12 MySQL LIKE子句</h2><p>WHERE 子句中可以使用等号 <code>=</code> 来设定获取数据的条件，如 “url = ‘<a href="http://www.google.com&/#39;&quot;%E3%80%82">www.google.com&#39;&quot;。</a><br>但是有时候我们需要获取 url 字段含有 “com” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。</p><p><strong>语法</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> field1, field2,...fieldN <span class="hljs-keyword">FROM</span> table_name<span class="hljs-keyword">WHERE</span> field1 <span class="hljs-keyword">LIKE</span> condition1 [<span class="hljs-keyword">AND</span> [<span class="hljs-keyword">OR</span>]] filed2 = <span class="hljs-string">&#x27;somevalue&#x27;</span></code></pre><ul><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以在 WHERE 子句中使用LIKE子句。</li><li>你可以使用LIKE子句代替等号 =。</li><li>LIKE 通常与 % 一同使用，类似于一个元字符的搜索。</li><li>你可以使用 AND 或者 OR 指定一个或多个条件。</li><li>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</li></ul><p><strong>实例</strong><br>查找url数据表中所有含.com的地址：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM url;+<span class="hljs-comment">----+----------------+</span>| id | url_list       |+<span class="hljs-comment">----+----------------+</span>|  1 | www.baidu.com  ||  2 | www.google.com ||  3 | ecarry.cc      ||  4 | weibo.com      ||  5 | www.google.cn  |+<span class="hljs-comment">----+----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">url</span> <span class="hljs-keyword">WHERE</span> url_list <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%com&#x27;</span>;+<span class="hljs-comment">----+----------------+</span>| id | url_list       |+<span class="hljs-comment">----+----------------+</span>|  1 | www.baidu.com  ||  2 | www.google.com ||  4 | weibo.com      |+<span class="hljs-comment">----+----------------+</span>3 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h2 id="5-13-MySQL-UNION操作符"><a href="#5-13-MySQL-UNION操作符" class="headerlink" title="5.13 MySQL UNION操作符"></a>5.13 MySQL UNION操作符</h2><p><strong>描述</strong></p><p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p><p><strong>语法</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> expression1, expression2, ... expression_n<span class="hljs-keyword">FROM</span> <span class="hljs-keyword">tables</span>[<span class="hljs-keyword">WHERE</span> conditions]<span class="hljs-keyword">UNION</span> [<span class="hljs-keyword">ALL</span> | <span class="hljs-keyword">DISTINCT</span>]<span class="hljs-keyword">SELECT</span> expression1, expression2, ... expression_n<span class="hljs-keyword">FROM</span> <span class="hljs-keyword">tables</span>[<span class="hljs-keyword">WHERE</span> conditions];</code></pre><ul><li><strong>expression1, expression2, … expression_n</strong>: 要检索的列。</li><li><strong>tables</strong>: 要检索的数据表。</li><li><strong>WHERE conditions</strong>: 可选， 检索条件。</li><li><strong>DISTINCT</strong>: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li><li><strong>ALL</strong>: 可选，返回所有结果集，包含重复数据。</li></ul><p><strong>实例</strong></p><p>下面是选自 “Websites” 表的数据：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM Websites;+<span class="hljs-comment">----+--------------+---------------------------+-------+---------+</span>| id | name         | url                       | alexa | country |+<span class="hljs-comment">----+--------------+---------------------------+-------+---------+</span>| 1  | Google       | https://www.google.cm/    | 1     | USA     || 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      || 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      || 4  | 微博          | http://weibo.com/         | 20    | CN      || 5  | Facebook     | https://www.facebook.com/ | 3     | USA     || 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND      |+<span class="hljs-comment">----+---------------+---------------------------+-------+---------+</span></code></pre><p>下面是 “apps” APP 的数据：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM apps;+<span class="hljs-comment">----+------------+-------------------------+---------+</span>| id | app_name   | url                     | country |+<span class="hljs-comment">----+------------+-------------------------+---------+</span>|  1 | QQ APP     | http://im.qq.com/       | CN      ||  2 | 微博 APP   | http://weibo.com/        | CN      ||  3 | 淘宝 APP   | https://www.taobao.com/  | CN      |+<span class="hljs-comment">----+------------+-------------------------+---------+</span>3 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h3 id="5-13-1-SQL-UNION-实例"><a href="#5-13-1-SQL-UNION-实例" class="headerlink" title="5.13.1 SQL UNION 实例"></a>5.13.1 SQL UNION 实例</h3><p>下面的 SQL 语句从 “Websites” 和 “apps” 表中选取所有不同的country（只有不同的值）：</p><pre><code class="hljs sql">mysql&gt; SELECT country FROM Websites    -&gt; UNION    -&gt; SELECT country FROM apps    -&gt; ORDER BY country;+<span class="hljs-comment">---------+</span>| country |+<span class="hljs-comment">---------+</span>| CN      || IND     || USA     |+<span class="hljs-comment">---------+  </span>3 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p><strong>注释：</strong>UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！</p><h3 id="5-13-2-SQL-UNION-ALL-实例"><a href="#5-13-2-SQL-UNION-ALL-实例" class="headerlink" title="5.13.2 SQL UNION ALL 实例"></a>5.13.2 SQL UNION ALL 实例</h3><p>下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的country（也有重复的值）：</p><pre><code class="hljs sql">mysql&gt; SELECT country FROM Websites    -&gt; UNION ALL    -&gt; SELECT country FROM apps    -&gt; ORDER BY country;+<span class="hljs-comment">---------+</span>| country |+<span class="hljs-comment">---------+</span>| CN      || CN      || CN      || CN      || CN      || IND     || USA     || USA     || USA     |+<span class="hljs-comment">---------+  </span>3 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h3 id="5-13-3-带有-WHERE-的-SQL-UNION-ALL"><a href="#5-13-3-带有-WHERE-的-SQL-UNION-ALL" class="headerlink" title="5.13.3 带有 WHERE 的 SQL UNION ALL"></a>5.13.3 带有 WHERE 的 SQL UNION ALL</h3><p>下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的中国(CN)的数据（也有重复的值）：</p><pre><code class="hljs sql">mysql&gt; SELECT country,name FROM Websites    -&gt; WHERE country=&#x27;CN&#x27;    -&gt; UNION ALL    -&gt; SELECT country,app_name FROM apps    -&gt; WHERE country=&#x27;CN&#x27;    -&gt; ORDER BY country;+<span class="hljs-comment">---------+--------------+</span>| country |    name      |+<span class="hljs-comment">---------+--------------+</span>| CN      |   淘宝        || CN      |   QQ APP     || CN      |   菜鸟        || CN      |   微博 APP    || CN      |   微博        || CN      |   淘宝 APP    |+<span class="hljs-comment">---------+--------------+  </span>6 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h2 id="5-14-MySQL排序"><a href="#5-14-MySQL排序" class="headerlink" title="5.14 MySQL排序"></a>5.14 MySQL排序</h2><p>我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。<br>如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 ORDER BY 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。</p><p><strong>语法</strong></p><p>以下是 SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> field1, field2,...fieldN table_name1, table_name2...<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> field1, [field2...] [<span class="hljs-keyword">ASC</span> [<span class="hljs-keyword">DESC</span>]]</code></pre><ul><li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li><li>你可以设定多个字段来排序。</li><li>你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。</li><li>你可以添加 WHERE…LIKE 子句来设置条件。</li></ul><p><strong>实例</strong></p><p>演示<strong>test_tbl</strong>数据表</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM test_tbl;+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>| id | name     | age | sex | submission_date |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>|  1 | pangzi W |  25 | M   | 2018-01-22      ||  2 | san A    |  25 | M   | 2018-01-22      ||  3 | sao A    |  24 | M   | 2018-01-22      ||  4 | juju GOU |  26 | M   | 2018-01-22      ||  6 | nv JI    |  18 | W   | 2018-01-22      |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>将<strong>test_tbl</strong>通过<strong>age</strong>升序排列：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM test_tbl ORDER BY age ASC;+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>| id | name     | age | sex | submission_date |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>|  6 | nv JI    |  18 | W   | 2018-01-22      ||  3 | sao A    |  24 | M   | 2018-01-22      ||  1 | pangzi W |  25 | M   | 2018-01-22      ||  2 | san A    |  25 | M   | 2018-01-22      ||  4 | juju GOU |  26 | M   | 2018-01-22      |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><p>将<strong>test_tbl</strong>通过<strong>age</strong>降序排列：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM test_tbl ORDER BY age DESC;+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>| id | name     | age | sex | submission_date |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>|  4 | juju GOU |  26 | M   | 2018-01-22      ||  1 | pangzi W |  25 | M   | 2018-01-22      ||  2 | san A    |  25 | M   | 2018-01-22      ||  3 | sao A    |  24 | M   | 2018-01-22      ||  6 | nv JI    |  18 | W   | 2018-01-22      |+<span class="hljs-comment">----+----------+-----+-----+-----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h2 id="5-15-MySQL-GROUP-BY语句（分组）"><a href="#5-15-MySQL-GROUP-BY语句（分组）" class="headerlink" title="5.15 MySQL GROUP BY语句（分组）"></a>5.15 MySQL GROUP BY语句（分组）</h2><p>GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 <strong>COUNT, SUM, AVG</strong>等函数。</p><p><strong>语法</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name, <span class="hljs-keyword">function</span>(column_name)<span class="hljs-keyword">FROM</span> table_name<span class="hljs-keyword">WHERE</span> column_name <span class="hljs-keyword">operator</span> <span class="hljs-keyword">value</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column_name;</code></pre><p><strong>实例</strong></p><p>对employee_tbl数据表进行分组：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM employee_tbl;+<span class="hljs-comment">----+--------+---------------------+--------+</span>| id | name   | date                | singin |+<span class="hljs-comment">----+--------+---------------------+--------+</span>|  1 | 小明 | 2016-04-22 15:25:33 |      1 ||  2 | 小王 | 2016-04-20 15:25:47 |      3 ||  3 | 小丽 | 2016-04-19 15:26:02 |      2 ||  4 | 小王 | 2016-04-07 15:26:14 |      4 ||  5 | 小明 | 2016-04-11 15:26:40 |      4 ||  6 | 小明 | 2016-04-04 15:26:54 |      2 |+<span class="hljs-comment">----+--------+---------------------+--------+</span>6 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录：</p><pre><code class="hljs sql">mysql&gt; SELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;+<span class="hljs-comment">--------+----------+</span>| name   | COUNT(*) |+<span class="hljs-comment">--------+----------+</span>| 小丽 |        1 || 小明 |        3 || 小王 |        2 |+<span class="hljs-comment">--------+----------+</span>3 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><h3 id="5-15-1-使用-WITH-ROLLUP"><a href="#5-15-1-使用-WITH-ROLLUP" class="headerlink" title="5.15.1 使用 WITH ROLLUP"></a>5.15.1 使用 WITH ROLLUP</h3><p>WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。</p><p>例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数：</p><pre><code class="hljs sql">mysql&gt; SELECT name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;+<span class="hljs-comment">--------+--------------+</span>| name   | singin_count |+<span class="hljs-comment">--------+--------------+</span>| 小丽 |            2 || 小明 |            7 || 小王 |            7 || NULL   |           16 |+<span class="hljs-comment">--------+--------------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><blockquote><p>其中记录 NULL 表示所有人的登录次数。</p></blockquote><p>我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：<code>select coalesce(a,b,c);</code><br>参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。<br>以下实例中如果名字为空我们使用总数代替：</p><pre><code class="hljs sql">mysql&gt; SELECT coalesce(name, &#x27;总数&#x27;), SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;+<span class="hljs-comment">--------------------------+--------------+</span>| coalesce(name, &#x27;总数&#x27;) | singin_count |+<span class="hljs-comment">--------------------------+--------------+</span>| 小丽                   |            2 || 小明                   |            7 || 小王                   |            7 || 总数                   |           16 |+<span class="hljs-comment">--------------------------+--------------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><h2 id="5-16-MySQL连接的使用"><a href="#5-16-MySQL连接的使用" class="headerlink" title="5.16 MySQL连接的使用"></a>5.16 MySQL连接的使用</h2><p>在MySQL中，可以使用JOIN在两个或多个表中查询数据。<br>可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。<br>JOIN 按照功能大致分为如下三类：</p><ul><li><strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</li><li><strong>LEFT JOIN（左连接）</strong>：获取左表所有记录，即使右表没有对应匹配的记录。</li><li><strong>RIGHT JOIN（右连接）</strong>： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li></ul><p><strong>实例：</strong>使用菜鸟教程数据库</p><pre><code class="hljs sql">mysql&gt; use RUNOOB;Database changedmysql&gt; SELECT * FROM tcount_tbl;+<span class="hljs-comment">---------------+--------------+</span>| runoob_author | runoob_count |+<span class="hljs-comment">---------------+--------------+</span>| 菜鸟教程  | 10           || RUNOOB.COM    | 20           || Google        | 22           |+<span class="hljs-comment">---------------+--------------+</span>3 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec) mysql&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> runoob_tbl;+<span class="hljs-comment">-----------+---------------+---------------+-----------------+</span>| runoob_id | runoob_title  | runoob_author | submission_date |+<span class="hljs-comment">-----------+---------------+---------------+-----------------+</span>| 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12              || 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12              || 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01         || 4         | 学习 sql | RUNOOB.COM    | 2016-03-06         || 5         | 学习 C      | FK            | 2017-04-05         |+<span class="hljs-comment">-----------+---------------+---------------+-----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><h3 id="5-16-1-MySQL-INNER-JOIN"><a href="#5-16-1-MySQL-INNER-JOIN" class="headerlink" title="5.16.1 MySQL INNER JOIN"></a>5.16.1 MySQL INNER JOIN</h3><p>使用MySQL的INNER JOIN(也可以省略 INNER 使用 JOIN，效果一样)来连接以上两张表来读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值：</p><pre><code class="hljs sql">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;+<span class="hljs-comment">-------------+-----------------+----------------+</span>| a.runoob_id | a.runoob_author | b.runoob_count |+<span class="hljs-comment">-------------+-----------------+----------------+</span>| 1           | 菜鸟教程    | 10             || 2           | 菜鸟教程    | 10             || 3           | RUNOOB.COM      | 20             || 4           | RUNOOB.COM      | 20             |+<span class="hljs-comment">-------------+-----------------+----------------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>等价于使用** WHERE子句**：</p><pre><code class="hljs sql">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;+<span class="hljs-comment">-------------+-----------------+----------------+</span>| a.runoob_id | a.runoob_author | b.runoob_count |+<span class="hljs-comment">-------------+-----------------+----------------+</span>| 1           | 菜鸟教程    | 10             || 2           | 菜鸟教程    | 10             || 3           | RUNOOB.COM      | 20             || 4           | RUNOOB.COM      | 20             |+<span class="hljs-comment">-------------+-----------------+----------------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><p><img src="/img/mysql/img_innerjoin.gif"></p><h3 id="5-16-2-MySQL-LEFT-JOIN"><a href="#5-16-2-MySQL-LEFT-JOIN" class="headerlink" title="5.16.2 MySQL LEFT JOIN"></a>5.16.2 MySQL LEFT JOIN</h3><p>MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</p><pre><code class="hljs sql">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;+<span class="hljs-comment">-------------+-----------------+----------------+</span>| a.runoob_id | a.runoob_author | b.runoob_count |+<span class="hljs-comment">-------------+-----------------+----------------+</span>| 1           | 菜鸟教程    | 10             || 2           | 菜鸟教程    | 10             || 3           | RUNOOB.COM      | 20             || 4           | RUNOOB.COM      | 20             || 5           | FK              | NULL           |+<span class="hljs-comment">-------------+-----------------+----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><p><img src="/img/mysql/img_leftjoin.gif"></p><h3 id="5-16-3-MySQL-RIGHT-JOIN"><a href="#5-16-3-MySQL-RIGHT-JOIN" class="headerlink" title="5.16.3 MySQL RIGHT JOIN"></a>5.16.3 MySQL RIGHT JOIN</h3><p>MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据。</p><pre><code class="hljs sql">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;+<span class="hljs-comment">-------------+-----------------+----------------+</span>| a.runoob_id | a.runoob_author | b.runoob_count |+<span class="hljs-comment">-------------+-----------------+----------------+</span>| 1           | 菜鸟教程    | 10             || 2           | 菜鸟教程    | 10             || 3           | RUNOOB.COM      | 20             || 4           | RUNOOB.COM      | 20             || NULL        | NULL            | 22             |+<span class="hljs-comment">-------------+-----------------+----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><p><img src="/img/mysql/img_rightjoin.gif"></p><h2 id="5-17-MySQL-NULL值处理"><a href="#5-17-MySQL-NULL值处理" class="headerlink" title="5.17 MySQL NULL值处理"></a>5.17 MySQL NULL值处理</h2><p>MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。<br>为了处理这种情况，MySQL提供了三大运算符:</p><ul><li><strong>IS NULL</strong>: 当列的值是 NULL,此运算符返回 true。</li><li><strong>IS NOT NULL</strong>: 当列的值不为 NULL, 运算符返回 true。</li><li><strong>&lt;=&gt;</strong>: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。</li></ul><p>关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。<br>在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。<br>MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。</p><p><strong>实例</strong></p><p>在数据库test中创建数据表test_NULL含有两列name，age，在age中插入NULL值。</p><pre><code class="hljs sql">mysql&gt; CREATE TABLE test_NULL( name CHAR(10) NOT NULL, age INT);Query OK, 0 rows affected (0.02 sec)mysql&gt; desc test_NULL;+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| Field | Type     | Null | Key | Default | Extra |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| name  | char(10) | NO   |     | NULL    |       || age   | int(11)  | YES  |     | NULL    |       |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_NULL( <span class="hljs-keyword">name</span>,age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;LILI&#x27;</span>,<span class="hljs-number">20</span>);Query OK, 1 row affected (0.00 sec)mysql&gt; INSERT INTO test_NULL( name,age) VALUES (&#x27;LALA&#x27;,NULL);Query OK, 1 row affected (0.00 sec)mysql&gt; INSERT INTO test_NULL( name,age) VALUES (&#x27;FEIFEI&#x27;,NULL);Query OK, 1 row affected (0.00 sec)mysql&gt; INSERT INTO test_NULL( name,age) VALUES (&#x27;JIJI&#x27;,NULL);Query OK, 1 row affected (0.00 sec)mysql&gt; INSERT INTO test_NULL( name,age) VALUES (&#x27;GEGE&#x27;,25);Query OK, 1 row affected (0.00 sec)mysql&gt; SELECT * FROM test_NULL;+<span class="hljs-comment">--------+------+</span>| name   | age  |+<span class="hljs-comment">--------+------+</span>| LILI   |   20 || LALA   | NULL || FEIFEI | NULL || JIJI   | NULL || GEGE   |   25 |+<span class="hljs-comment">--------+------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>使用SELECT,WHERE查询NULL值用**=<strong>和</strong>！=**运算符是不起作用的：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM test_NULL WHERE age=NULL;Empty <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_NULL <span class="hljs-keyword">WHERE</span> age!=<span class="hljs-literal">NULL</span>;Empty <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>要查询表中age列为是否为NULL值的，必须使用<strong>IS NULL</strong>和<strong>IS NOT NULL</strong> ：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM test_NULL WHERE age is NULL;+<span class="hljs-comment">--------+------+</span>| name   | age  |+<span class="hljs-comment">--------+------+</span>| LALA   | NULL || FEIFEI | NULL || JIJI   | NULL |+<span class="hljs-comment">--------+------+</span>3 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_NULL <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">is</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;+<span class="hljs-comment">------+------+</span>| name | age  |+<span class="hljs-comment">------+------+</span>| LILI |   20 || GEGE |   25 |+<span class="hljs-comment">------+------+</span>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h2 id="5-18-MySQL正则表达式"><a href="#5-18-MySQL正则表达式" class="headerlink" title="5.18 MySQL正则表达式"></a>5.18 MySQL正则表达式</h2><p>下表中的正则模式可应用于 REGEXP 操作符中。</p><table><thead><tr><th align="center">模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，<br> ^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td align="center">$</td><td align="center">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，<br> $也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td align="center">.</td><td align="center">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，<br>请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td align="center">[…]</td><td align="center">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td align="center">[^…]</td><td align="center">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td></tr><tr><td align="center">p1/p2/p3</td><td align="center">匹配 p1 或 p2 或 p3。例如，’z/food’ 能匹配 “z” 或 “food”。<br>‘(z/f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td align="center">*</td><td align="center">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="center">+</td><td align="center">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，<br>但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="center">{n}</td><td align="center">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，<br>但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="center">{n,m}</td><td align="center">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td></tr></tbody></table><p><strong>实例</strong></p><p>在数据表name中查找名字时：<br>查找name字段中以‘st’为开头的所有数据：</p><pre><code class="hljs sql">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^st&#x27;;</code></pre><p>查找name字段中以‘ok’结尾的所有数据：</p><pre><code class="hljs sql">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;ok$&#x27;;</code></pre><p>查找name字段中包含‘mar’字符串的所有数据：</p><pre><code class="hljs sql">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;mar&#x27;;</code></pre><p>查找name字段中以元音字符开头或以‘ok’字符串结尾的所有数据：</p><pre><code class="hljs sql">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^[aeiou]|ok$&#x27;;</code></pre><h2 id="5-19-MySQL-ALTER命令"><a href="#5-19-MySQL-ALTER命令" class="headerlink" title="5.19 MySQL ALTER命令"></a>5.19 MySQL ALTER命令</h2><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。<br>先创建一张表testalter_tbl：</p><pre><code class="hljs sql">mysql&gt; CREATE TABLE testalter_tbl(i INT, C CHAR(10));Query OK, 0 rows affected (0.02 sec)mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| Field | Type     | Null | Key | Default | Extra |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| i     | int(11)  | YES  |     | NULL    |       || C     | char(10) | YES  |     | NULL    |       |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h3 id="5-19-1-删除，添加或修改字段"><a href="#5-19-1-删除，添加或修改字段" class="headerlink" title="5.19.1 删除，添加或修改字段"></a>5.19.1 删除，添加或修改字段</h3><ol><li>使用ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</li></ol><pre><code class="hljs sql">mysql&gt; ALTER TABLE testalter_tbl DROP i;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| Field | Type     | Null | Key | Default | Extra |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| C     | char(10) | YES  |     | NULL    |       |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>1 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p><strong>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</strong></p><ol start="2"><li>使用 ADD 子句来向表 testalter_tbl 中添加 i 字段，并定义数据类型:</li></ol><pre><code class="hljs sql">mysql&gt; ALTER TABLE testalter_tbl ADD i INT;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| Field | Type     | Null | Key | Default | Extra |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| C     | char(10) | YES  |     | NULL    |       || i     | int(11)  | YES  |     | NULL    |       |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>2 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>执行以上命令后，i 字段会自动添加到数据表字段的末尾。</p><ol start="3"><li>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）:</li></ol><pre><code class="hljs sql">mysql&gt; ALTER TABLE testalter_tbl ADD a INT FIRST;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| Field | Type     | Null | Key | Default | Extra |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| a     | int(11)  | YES  |     | NULL    |       || C     | char(10) | YES  |     | NULL    |       || i     | int(11)  | YES  |     | NULL    |       |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>3 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> testalter_tbl <span class="hljs-keyword">ADD</span> b <span class="hljs-built_in">INT</span> <span class="hljs-keyword">AFTER</span> a;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| Field | Type     | Null | Key | Default | Extra |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>| a     | int(11)  | YES  |     | NULL    |       || b     | int(11)  | YES  |     | NULL    |       || C     | char(10) | YES  |     | NULL    |       || i     | int(11)  | YES  |     | NULL    |       |+<span class="hljs-comment">-------+----------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h3 id="5-19-2-修改字段类型及名称"><a href="#5-19-2-修改字段类型及名称" class="headerlink" title="5.19.2 修改字段类型及名称"></a>5.19.2 修改字段类型及名称</h3><p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p><p><strong>实例：</strong>把字段 c 的类型从 CHAR(10) 改为 CHAR(1)，可以执行以下命令:</p><pre><code class="hljs sql">mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(1);Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>| Field | Type    | Null | Key | Default | Extra |+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>| a     | int(11) | YES  |     | NULL    |       || b     | int(11) | YES  |     | NULL    |       || c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | NULL    |       |+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。<br><strong>实例：</strong>将字段i改为j并将数据类型改为BIGINT，再将BIGINT改为INT。</p><pre><code class="hljs sql">mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>| Field | Type    | Null | Key | Default | Extra |+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>| a     | int(11) | YES  |     | NULL    |       || b     | int(11) | YES  |     | NULL    |       || c     | char(1) | YES  |     | NULL    |       || i     | int(11) | YES  |     | NULL    |       |+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> testalter_tbl <span class="hljs-keyword">CHANGE</span> i j <span class="hljs-built_in">BIGINT</span>;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| Field | Type       | Null | Key | Default | Extra |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| a     | int(11)    | YES  |     | NULL    |       || b     | int(11)    | YES  |     | NULL    |       || c     | char(1)    | YES  |     | NULL    |       || j     | bigint(20) | YES  |     | NULL    |       |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)mysql&gt; <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> testalter_tbl <span class="hljs-keyword">CHANGE</span> j j <span class="hljs-built_in">INT</span>;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>| Field | Type    | Null | Key | Default | Extra |+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>| a     | int(11) | YES  |     | NULL    |       || b     | int(11) | YES  |     | NULL    |       || c     | char(1) | YES  |     | NULL    |       || j     | int(11) | YES  |     | NULL    |       |+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h3 id="5-19-3-ALTER-TABLE-对-Null-值和默认值的影响"><a href="#5-19-3-ALTER-TABLE-对-Null-值和默认值的影响" class="headerlink" title="5.19.3 ALTER TABLE 对 Null 值和默认值的影响"></a>5.19.3 ALTER TABLE 对 Null 值和默认值的影响</h3><p>当你修改字段时，你可以指定是否包含值或者是否设置默认值。<br><strong>实例：</strong>指定字段 j 为 NOT NULL 且默认值为100 。</p><pre><code class="hljs sql">mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>| Field | Type    | Null | Key | Default | Extra |+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>| a     | int(11) | YES  |     | NULL    |       || b     | int(11) | YES  |     | NULL    |       || c     | char(1) | YES  |     | NULL    |       || j     | int(11) | YES  |     | NULL    |       |+<span class="hljs-comment">-------+---------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql&gt; <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> testalter_tbl    -&gt; <span class="hljs-keyword">MODIFY</span> j <span class="hljs-built_in">BIGINT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">100</span>;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| Field | Type       | Null | Key | Default | Extra |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| a     | int(11)    | YES  |     | NULL    |       || b     | int(11)    | YES  |     | NULL    |       || c     | char(1)    | YES  |     | NULL    |       || j     | bigint(20) | NO   |     | 100     |       |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre><p>如果不设置默认值，MySQL会自动设置该字段默认为 NULL。</p><h3 id="5-19-4-修改字段默认值"><a href="#5-19-4-修改字段默认值" class="headerlink" title="5.19.4 修改字段默认值"></a>5.19.4 修改字段默认值</h3><p>以使用 ALTER 来修改字段的默认值。<br><strong>实例：</strong></p><pre><code class="hljs sql">mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| Field | Type       | Null | Key | Default | Extra |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| a     | int(11)    | YES  |     | NULL    |       || b     | int(11)    | YES  |     | NULL    |       || c     | char(1)    | YES  |     | NULL    |       || j     | bigint(20) | NO   |     | 100     |       |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)mysql&gt; <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> testalter_tbl <span class="hljs-keyword">ALTER</span> a <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1000</span>;Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| Field | Type       | Null | Key | Default | Extra |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| a     | int(11)    | YES  |     | 1000    |       || b     | int(11)    | YES  |     | NULL    |       || c     | char(1)    | YES  |     | NULL    |       || j     | bigint(20) | NO   |     | 100     |       |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>使用 ALTER 命令及 DROP子句来删除字段的默认值。<br><strong>实例：</strong></p><pre><code class="hljs sql">mysql&gt; ALTER TABLE testalter_tbl ALTER j DROP DEFAULT;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW COLUMNS FROM testalter_tbl;+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| Field | Type       | Null | Key | Default | Extra |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>| a     | int(11)    | YES  |     | 1000    |       || b     | int(11)    | YES  |     | NULL    |       || c     | char(1)    | YES  |     | NULL    |       || j     | bigint(20) | NO   |     | NULL    |       |+<span class="hljs-comment">-------+------------+------+-----+---------+-------+</span>4 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h3 id="5-19-5-修改数据表类型"><a href="#5-19-5-修改数据表类型" class="headerlink" title="5.19.5 修改数据表类型"></a>5.19.5 修改数据表类型</h3><p>使用 ALTER 命令及 TYPE 子句修改数据表类型，将数据表testalter_tbl的类型改为MYSAM：<br><strong>注意：</strong>查看数据表类型可以使用 SHOW TABLE STATUS 语句。</p><pre><code class="hljs sql">mysql&gt; SHOW TABLE STATUS LIKE &#x27;testalter_tbl&#x27;\G;*************************** 1. row ***************************           Name: testalter_tbl         Engine: InnoDB        Version: 10     Row_format: Compact           Rows: 0 Avg_row_length: 0    Data_length: 16384Max_data_length: 0   Index_length: 0      Data_free: 0 Auto_increment: NULL    Create_time: 2018-01-24 11:06:35    Update_time: NULL     Check_time: NULL      Collation: latin1_swedish_ci       <span class="hljs-keyword">Checksum</span>: <span class="hljs-literal">NULL</span> Create_options:         <span class="hljs-keyword">Comment</span>: <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)mysql&gt; <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> testalter_tbl <span class="hljs-keyword">ENGINE</span>=MYISAM;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; SHOW TABLE STATUS LIKE &#x27;testalter_tbl&#x27;\G;*************************** 1. row ***************************           Name: testalter_tbl         Engine: MyISAM        Version: 10     Row_format: Fixed           Rows: 0 Avg_row_length: 0    Data_length: 0Max_data_length: 5066549580791807   Index_length: 1024      Data_free: 0 Auto_increment: NULL    Create_time: 2018-01-24 11:17:33    Update_time: 2018-01-24 11:17:33     Check_time: NULL      Collation: latin1_swedish_ci       <span class="hljs-keyword">Checksum</span>: <span class="hljs-literal">NULL</span> Create_options:         <span class="hljs-keyword">Comment</span>: <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre><h3 id="5-19-6-修改表名"><a href="#5-19-6-修改表名" class="headerlink" title="5.19.6 修改表名"></a>5.19.6 修改表名</h3><p>如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。<br><strong>实例：</strong>修改表test_NULL为testnull_tbl:</p><pre><code class="hljs sql">mysql&gt; ALTER TABLE test_NULL RENAME TO testnull_tbl;Query OK, 0 rows affected (0.01 sec)mysql&gt; SHOW TABLES;+<span class="hljs-comment">----------------+</span>| Tables_in_test |+<span class="hljs-comment">----------------+</span>| bili           || test_tbl       || testalter_tbl  || testnull_tbl   || url            |+<span class="hljs-comment">----------------+</span>5 rows in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SUN M4000故障处理报告</title>
    <link href="/2017/02/22/SUN_M4000/"/>
    <url>/2017/02/22/SUN_M4000/</url>
    
    <content type="html"><![CDATA[<h1 id="１、故障摘要"><a href="#１、故障摘要" class="headerlink" title="１、故障摘要"></a>１、故障摘要</h1><p>发现M4000内存告警,原有64G内存，现在只识别32G</p><a id="more"></a><p><img src="/img/sun/SUN_M4000_DOWN.png"></p><h1 id="2、故障具体情况"><a href="#2、故障具体情况" class="headerlink" title="2、故障具体情况"></a>2、故障具体情况</h1><pre><code>XSCF&gt; showstatus </code></pre><p>错误日志</p><pre><code class="hljs bash">    MBU_A Status:Normal;        MEMB<span class="hljs-comment">#0 Status:Normal;</span>*           MEM<span class="hljs-comment">#0B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#1B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#2B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#3B Status:Deconfigured;</span>        MEMB<span class="hljs-comment">#1 Status:Normal;</span>*           MEM<span class="hljs-comment">#0B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#1B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#2B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#3B Status:Deconfigured;</span>        MEMB<span class="hljs-comment">#2 Status:Normal;</span>*           MEM<span class="hljs-comment">#0B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#1B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#2B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#3B Status:Deconfigured;</span>        MEMB<span class="hljs-comment">#3 Status:Normal;</span>*           MEM<span class="hljs-comment">#0B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#1B Status:Faulted;</span>*           MEM<span class="hljs-comment">#2B Status:Deconfigured;</span>*           MEM<span class="hljs-comment">#3B Status:Deconfigured;</span></code></pre><p>定位内存位置：</p><p>发现MEMA上的内存都为正常，内存MEMB上的内存报错，MEMB#3上的MEM#1B的状态为Faulted，说明这根内存损坏，其他内存受其影响导致降级。<br>(图是M5000机器)<br><img src="/img/sun/m5000_mem.png"></p><h1 id="3、故障分析及处理"><a href="#3、故障分析及处理" class="headerlink" title="3、故障分析及处理"></a>3、故障分析及处理</h1><ol><li><p>先将机器下电</p><p> XSCF&gt; shutdown -g0 -y<br>确认电源已关闭</p><p> XSCF&gt; poweroff -a<br>或者 <code>XSCF&gt;poweroff -d 00</code>关闭电源</p></li><li><p>根据上图找到内存具体位置</p></li><li><p>更换状态为Faulted的内存</p></li><li><p>重新上电，查看机器状态</p></li></ol><pre><code class="hljs bash">XSCF&gt; poweron -d 00XSCF&gt; showstatusNo failures found <span class="hljs-keyword">in</span> System Initialization.</code></pre><p>5.查看所有内存是否识别到</p><pre><code class="hljs bash">XSCF&gt; showhardconf</code></pre><h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>1.更换内存，必须先将机器下电。</p><p>2.由于机器太重（~80kg），需要多人配合。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
