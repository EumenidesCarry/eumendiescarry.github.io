

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="ECarry">
  <meta name="keywords" content="">
  <title>Shell 从入门到精通 - ECarry的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false},"toc":{"enable":false,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>ECarry's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/photo/">
                <i class="iconfont icon-images"></i>
                相册
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://w.wallhaven.cc/full/od/wallhaven-odq7dl.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Shell 从入门到精通">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-28 17:13" pubdate>
        2020年9月28日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      50.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      731
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Shell 从入门到精通</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2020年11月19日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><hr>
<h5 id="关于本文档"><a href="#关于本文档" class="headerlink" title="关于本文档"></a>关于本文档</h5><table>
<thead>
<tr>
<th>文档名称</th>
<th>Shell 从入门到精通</th>
</tr>
</thead>
<tbody><tr>
<td>作者信息</td>
<td>李振良（阿良），微信：init 1024</td>
</tr>
<tr>
<td>官方网站</td>
<td><a target="_blank" rel="noopener" href="http://www.ctnrs.com/">http://www.ctnrs.com</a></td>
</tr>
<tr>
<td>技术博客</td>
<td><a target="_blank" rel="noopener" href="http://blog.51cto.com/lizhenliang">http://blog.51cto.com/lizhenliang</a></td>
</tr>
<tr>
<td>最后更新时间</td>
<td>2019 - 2 - 1</td>
</tr>
</tbody></table>
<h5 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h5><p>熟悉 Linux 系统常用命令与工具，掌握 Shell 脚本语言语法结构，能独立编写 Shell 脚本，完成自动化运维常规任务，提高工作效率，为以后学习其他语言打下坚实的基础。</p>
<p>目标人群</p>
<p>运维工程师、开发工程师、Linux 系统爱好者或已经具备其他编程语言的人群。</p>
<h1 id="一、-Shell-基础知识"><a href="#一、-Shell-基础知识" class="headerlink" title="一、 Shell 基础知识"></a>一、 Shell 基础知识</h1><h2 id="1-1-Shell-简介"><a href="#1-1-Shell-简介" class="headerlink" title="1.1 Shell 简介"></a>1.1 Shell 简介</h2><p>Shell 是一个 C 语言编写的脚本语言，它是用户与 Linux 的桥梁，用户输入命令交给 Shell 处理，Shell 将相应的操作传递给内核（Kernel），内核把处理的结果输出给用户。<br>下面是流程示意图：</p>
<p><img src="/img/linux_shell/linux_shell_1.jpg" srcset="/img/loading.gif"></p>
<p>Shell 既然是工作在 Linux 内核之上，那我们也有必要了解下 Linux 相关知识。<br>Linux 是一套免费试用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>1983 年 9 月 27 日，Richard Stallman（理查德 - 马修 - 斯托曼）发起 GNU 计划，它的目标是创建一套完全自由的操作系统。为保证 GNU 软件可以自由的使用、复制、修改和发布，所有的 GNU 软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，GNU 通用公共许可证（GNU General Plubic License，GPL），说白了就是不能做商业用途。</p>
<p>GNU 是 “GNU is Not Unix” 的递归缩写。UNIX 是一种广泛使用的商业操作系统的名称。1985 年，Richard Stallman 又创立了自由软件基金会（Free Software Foundation，FSF）来为 GNU 计划提供技术、法律以及财政支持。</p>
<p>1990 年，GNU 计划开发主要项目有 Emacs（文本编辑器）、GCC（GNU Compiler Collection，GNU 编译器集合）、Bash 等，GCC 是一套 GNU 开发的编程语言编译器。还有开发一些 UNIX 系统的程序库和工具。</p>
<p>1991 年，Linuxs Torvalds（林纳斯 - 托瓦兹）开发出了与 UNIX 兼容的 Linux 操作系统内核并在 GPL 条款下发布。</p>
<p>1992 年，Linux 与其他 GUN 软件结合，完全自由的 GUN/Linux 操作系统正式诞生，简称 Linux。</p>
<p>1995 年 1 月，Bob Young 创办 ACC 公司，以 GNU/Linux 为核心，开发出了 RedHat Linux 商业版。</p>
<p>Linux 基本思想有两点：第一，<strong>一切都是文件</strong>；第二，<strong>每个软件都有确定的用途</strong>。与 Unix 思想十分相近。</p>
<h2 id="1-2-Shell-基本分两大类"><a href="#1-2-Shell-基本分两大类" class="headerlink" title="1.2 Shell 基本分两大类"></a>1.2 Shell 基本分两大类</h2><h3 id="1-2-1-图形界面-Shell（GUI-Shell）"><a href="#1-2-1-图形界面-Shell（GUI-Shell）" class="headerlink" title="1.2.1 图形界面 Shell（GUI Shell）"></a>1.2.1 图形界面 Shell（GUI Shell）</h3><p>GUI 为 Unix 或者类 Unix 操作系统构造一个功能完善、操作简单以及界面友好的桌面环境。主流桌面环境有 KDE，Gnome 等。</p>
<h3 id="1-2-2-命令行界面-Shell（CLI-Shell）"><a href="#1-2-2-命令行界面-Shell（CLI-Shell）" class="headerlink" title="1.2.2 命令行界面 Shell（CLI Shell）"></a>1.2.2 命令行界面 Shell（CLI Shell）</h3><p>CLI 是在用户提示符下键入可执行指令的界面，用户通过键盘输入指令，完成一系列操作。</p>
<p>在 Linux 系统上主流的 CLI 实现是 Bash，是许多 Linux 发行版默认的 Shell。还有许多 Unix 上 Shell，例如 <strong>tcsh、csh、ash、bsh、ksh</strong> 等。</p>
<h2 id="1-3-第一个-Shell-脚本"><a href="#1-3-第一个-Shell-脚本" class="headerlink" title="1.3 第一个 Shell 脚本"></a>1.3 第一个 Shell 脚本</h2><p>本教程主要讲解在大多 Linux 发行版下默认 Bash Shell。Linux 系统是 RedHat 下的 CentOS 操作系统，完全免费。与其商业版 RHEL（Red Hat Enterprise Linux）出自同样的源代码，不同的是 CentOS 并不包含封闭源代码软件和售后支持。</p>
<p>用 vi 打开 test.sh，编写：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># vi test.sh</span>
<span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello world!&quot;</span></code></pre>

<p>第一行指定解释器，第二行打印 Hello world！<br>写好后，开始执行，执行 Shell 脚本有三种方法：</p>
<p><strong>方法 1</strong> ：直接用 bash 解释器执行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># bash test.sh</span>
Hello world!</code></pre>

<p>当前终端会新生成一个子 bash 去执行脚本。</p>
<p><strong>方法 2</strong> ：添加可执行权限</p>
<pre><code class="hljs bash"><span class="hljs-comment"># ll test.sh</span>

- rw-r--r--. 1 root root 32 Aug 18 01:07 test.sh
<span class="hljs-comment"># chmod +x test.sh</span>
<span class="hljs-comment"># ./test.sh</span>
- bash: ./test.sh: Permission denied
<span class="hljs-comment"># chmod +x test.sh</span>
<span class="hljs-comment"># ./test.sh # ./ 在当前目录</span>
Hello world!</code></pre>

<p>这种方式默认根据脚本第一行指定的解释器处理，如果没写以当前默认 Shell 解释器执行。</p>
<p><strong>方法 3</strong>：source 命令执行，以当前默认 Shell 解释器执行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># source test.sh</span>
Hello world!</code></pre>

<h2 id="1-4-Shell-变量"><a href="#1-4-Shell-变量" class="headerlink" title="1.4 Shell 变量"></a>1.4 Shell 变量</h2><h3 id="1-4-1-系统变量"><a href="#1-4-1-系统变量" class="headerlink" title="1.4.1 系统变量"></a>1.4.1 系统变量</h3><p>在命令行提示符直接执行 env、set 查看系统或环境变量。env 显示用户环境变量，set 显示 Shell 预先定义好的变量以及用户变量。可以通过 export 导出成用户变量。</p>
<p>一些写 Shell 脚本时常用的系统变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$SHELL</td>
<td>默认 Shell</td>
</tr>
<tr>
<td>$HOME</td>
<td>当前用户家目录</td>
</tr>
<tr>
<td>$IFS</td>
<td>内部字段分隔符</td>
</tr>
<tr>
<td>$LANG</td>
<td>默认语言</td>
</tr>
<tr>
<td>$PATH</td>
<td>默认可执行程序路径</td>
</tr>
<tr>
<td>$PWD</td>
<td>当前目录</td>
</tr>
<tr>
<td>$UID</td>
<td>当前用户 ID</td>
</tr>
<tr>
<td>$USER</td>
<td>当前用户</td>
</tr>
<tr>
<td>$HISTSIZE</td>
<td>历史命令大小，可通过 HISTTIMEFORMAT 变量设置命令执行时间</td>
</tr>
<tr>
<td>$RANDOM</td>
<td>随机生成一个 0 至 32767 的整数</td>
</tr>
<tr>
<td>$HOSTNAME</td>
<td>主机名</td>
</tr>
</tbody></table>
<h3 id="1-4-2-普通变量与临时环境变量"><a href="#1-4-2-普通变量与临时环境变量" class="headerlink" title="1.4.2 普通变量与临时环境变量"></a>1.4.2 普通变量与临时环境变量</h3><p><strong>普通变量定义</strong>：VAR=value</p>
<p><strong>临时环境变量定义</strong>：export VAR=value</p>
<p><strong>变量引用</strong>：$VAR</p>
<p>下面看下他们之间区别：</p>
<p>Shell 进程的环境变量作用域是 Shell 进程，当 export 导入到系统变量时，则作用域是 Shell 进程及其 Shell 子进程。</p>
<p><img src="/img/linux_shell/linux_shell_2.jpg" srcset="/img/loading.gif"></p>
<p><img src="/img/linux_shell/linux_shell_3.jpg" srcset="/img/loading.gif"></p>
<p>ps axjf 输出的第一列是 PPID（父进程 ID），第二列是 PID（子进程 ID）<br>当 SSH 连接 Shell 时，当前终端 PPID（-bash）是 sshd 守护程序的 PID（root@pts/0），因此在当前终端下的所有进程的 PPID 都是 -bash 的 PID，比如执行命令、运行脚本。<br>所以当在 -bash 下设置的变量，只在 -bash 进程下有效，而 -bash 下的子进程 bash 是无效的，当 export 后才有效。</p>
<p>进一步说明：再重新连接 SSH，去除上面定义的变量测试下</p>
<p><img src="/img/linux_shell/linux_shell_4.jpg" srcset="/img/loading.gif"></p>
<p>所以在当前 shell 定义的变量一定要 export，否则在写脚本时，会引用不到。</p>
<p>还需要注意的是退出终端后，所有用户定义的变量都会清除。</p>
<p>在 <code>/etc/profile</code> 下定义的变量就是这个原理，后面有章节会讲解 Linux 常用变量文件。</p>
<h3 id="1-4-3-位置变量"><a href="#1-4-3-位置变量" class="headerlink" title="1.4.3 位置变量"></a>1.4.3 位置变量</h3><p>位置变量指的是函数或脚本后跟的第 n 个参数。</p>
<p>$1-$n，需要注意的是从第 10 个开始要用花括号调用，例如 ${10}</p>
<p>shift 可对位置变量控制，例如：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1: <span class="hljs-variable">$1</span>&quot;</span>
<span class="hljs-built_in">shift</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2: <span class="hljs-variable">$2</span>&quot;</span>
<span class="hljs-built_in">shift</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;3: <span class="hljs-variable">$3</span>&quot;</span>
<span class="hljs-comment"># bash test.sh a b c</span>
1: a
2: c
3:</code></pre>

<p>每执行一次 shift 命令，位置变量个数就会减一，而变量值则提前一位。shift n，可设置向前移动 n 位。</p>
<h3 id="1-4-4-特殊变量"><a href="#1-4-4-特殊变量" class="headerlink" title="1.4.4 特殊变量"></a>1.4.4 特殊变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>脚本自身名字</td>
</tr>
<tr>
<td>$?</td>
<td>返回上一条命令是否执行成功， 0 为执行成功，非 0 则为执行失败</td>
</tr>
<tr>
<td>$#</td>
<td>位置参数总数</td>
</tr>
<tr>
<td>$*</td>
<td>所有的位置参数被看做一个字符串</td>
</tr>
<tr>
<td>$@</td>
<td>每个位置参数被看做独立的字符串</td>
</tr>
<tr>
<td>$$</td>
<td>当前进程 PID</td>
</tr>
<tr>
<td>$!</td>
<td>上一条运行后台进程的 PID</td>
</tr>
</tbody></table>
<h2 id="1-5-变量引用"><a href="#1-5-变量引用" class="headerlink" title="1.5 变量引用"></a>1.5 变量引用</h2><table>
<thead>
<tr>
<th>赋值运算符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>变量赋值</td>
</tr>
<tr>
<td>+=</td>
<td>两个变量相加</td>
</tr>
</tbody></table>
<h3 id="1-5-1-自定义变量与引用"><a href="#1-5-1-自定义变量与引用" class="headerlink" title="1.5.1 自定义变量与引用"></a>1.5.1 自定义变量与引用</h3><pre><code class="hljs bash"><span class="hljs-comment"># VAR=123</span>
<span class="hljs-comment"># echo $VAR</span>
123
<span class="hljs-comment"># VAR+=456</span>
<span class="hljs-comment"># echo $VAR</span>
123456</code></pre>

<p>Shell 中所有变量引用使用 $ 符，后跟变量名。<br>有时个别特殊字符会影响正常引用，那么需要使用 ${VAR}，例如：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># VAR=123</span>
<span class="hljs-comment"># echo $VAR</span>
123
<span class="hljs-comment"># echo $VAR_  # Shell 允许 VAR_为变量名，所以此引用认为这是一个有效的变量名，故此返回空</span>

<span class="hljs-comment"># echo $&#123;VAR&#125;</span>
123</code></pre>

<p>还有时候变量名与其他字符串紧碍着，也会误认为是整个变量：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo $VAR456</span>

<span class="hljs-comment"># echo $&#123;VAR&#125;456</span>
123456</code></pre>

<h3 id="1-5-2-将命令结果作为变量值"><a href="#1-5-2-将命令结果作为变量值" class="headerlink" title="1.5.2 将命令结果作为变量值"></a>1.5.2 将命令结果作为变量值</h3><pre><code class="hljs bash"><span class="hljs-comment"># VAR=`echo 123`</span>
<span class="hljs-comment"># echo $VAR</span>
123
<span class="hljs-comment"># VAR=$(echo 123)</span>
<span class="hljs-comment"># echo $VAR</span>
123</code></pre>

<p>这里的反撇号等效于 $()，都是用于执行 Shell 命令。</p>
<h2 id="1-6-双引号和单引号"><a href="#1-6-双引号和单引号" class="headerlink" title="1.6 双引号和单引号"></a>1.6 双引号和单引号</h2><p>在变量赋值时，如果值有空格，Shell 会把空格后面的字符串解释为命令：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># VAR=1 2 3</span>
- bash: 2: <span class="hljs-built_in">command</span> not found
<span class="hljs-comment"># VAR=&quot;1 2 3&quot;</span>
<span class="hljs-comment"># echo $VAR</span>
1 2 3
<span class="hljs-comment"># VAR=&#x27;1 2 3&#x27;</span>
<span class="hljs-comment"># echo $VAR</span>
1 2 3</code></pre>

<p>看不出什么区别，再举个说明：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># N=3</span>
<span class="hljs-comment"># VAR=&quot;1 2 $N&quot;</span>
<span class="hljs-comment"># echo $VAR</span>
1 2 3

<span class="hljs-comment"># VAR=&#x27;1 2 $N&#x27;</span>
<span class="hljs-comment"># echo $VAR</span>
1 2 <span class="hljs-variable">$N</span></code></pre>

<p>单引号是告诉  Shell 忽略特殊字符，而双引号则解释特殊符号原有的意义，比如 $、！。</p>
<h2 id="1-7-注释"><a href="#1-7-注释" class="headerlink" title="1.7 注释"></a>1.7 注释</h2><p>Shell 注释也很简单，只要在每行前面加个 # 号，即表示 Shell 忽略解释。</p>
<h1 id="二、-Shell-字符串处理之"><a href="#二、-Shell-字符串处理之" class="headerlink" title="二、 Shell 字符串处理之 ${}"></a>二、 Shell 字符串处理之 ${}</h1><p>上一章节讲解了为什么用 ${} 引用变量，${} 还有一个重要的功能，就是文本处理，单行文本基本上可以满足你所有需求。</p>
<h2 id="2-1-获取字符串长度"><a href="#2-1-获取字符串长度" class="headerlink" title="2.1 获取字符串长度"></a>2.1 获取字符串长度</h2><pre><code class="hljs bash"><span class="hljs-comment"># VAR=&#x27;hello world!&#x27;</span>
<span class="hljs-comment"># echo $VAR</span>
hello world!
<span class="hljs-comment"># echo $&#123;#VAR&#125;</span>
12</code></pre>

<h2 id="2-2-字符串切片"><a href="#2-2-字符串切片" class="headerlink" title="2.2 字符串切片"></a>2.2 字符串切片</h2><p><strong>格式：</strong></p>
<ul>
<li>${parameter:offset}</li>
<li>${parameter:offset:length}</li>
</ul>
<p>截取从 offset 个字符开始，向后 length 个字符。</p>
<pre><code class="hljs bash">截取 hello 字符串：
<span class="hljs-comment"># VAR=&#x27;hello world!&#x27;</span>
<span class="hljs-comment"># echo $&#123;VAR:0:5&#125;</span>
hello
截取 wo 字符：
<span class="hljs-comment"># echo $&#123;VAR:6:2&#125;</span>
wo
截取 world! 字符串：
<span class="hljs-comment"># echo $&#123;VAR:5&#125;</span>
world!
截取最后一个字符：
<span class="hljs-comment"># echo $&#123;VAR:(-1)&#125;</span>
!
截取最后二个字符：
<span class="hljs-comment"># echo $&#123;VAR:(-2)&#125;</span>
d!
截取从倒数第 3 个字符后的 2 个字符：
<span class="hljs-comment"># echo $&#123;VAR:(-3):2&#125;</span>
ld</code></pre>

<h2 id="2-3-替换字符串"><a href="#2-3-替换字符串" class="headerlink" title="2.3 替换字符串"></a>2.3 替换字符串</h2><p><strong>格式：</strong></p>
<ul>
<li>${parameter/pattern/string}</li>
</ul>
<pre><code class="hljs bash"><span class="hljs-comment"># VAR=&#x27;hello world world!&#x27;</span>
将第一个 world 字符串替换为 WORLD：
<span class="hljs-comment"># echo $&#123;VAR/world/WORLD&#125;</span>
hello WORLD world!
将全部 world 字符串替换为 WORLD：
<span class="hljs-comment"># echo $&#123;VAR//world/WORLD&#125;</span>
hello WORLD WORLD!
替换正则匹配为空：
<span class="hljs-comment"># VAR=123abc</span>
<span class="hljs-comment"># echo $&#123;VAR//[^0-9]/&#125;</span>
123
<span class="hljs-comment"># echo $&#123;VAR//[0-9]/&#125;</span>
abc</code></pre>

<p>patterm 前面开头一个正斜杠为只匹配第一个字符串，两个正斜杠为匹配所有字符。</p>
<h2 id="2-4-字符串截取"><a href="#2-4-字符串截取" class="headerlink" title="2.4 字符串截取"></a>2.4 字符串截取</h2><p><strong>格式：</strong></p>
<ul>
<li>${parameter#word}         # 删除匹配前缀</li>
<li>${parameter##word}</li>
<li>${parameter%word}         # 删除匹配后缀</li>
<li>${parameter%%word}</li>
<li>#   去掉左边，最短匹配模式，## 最长匹配模式。</li>
<li>%    去掉右边，最短匹配模式，%% 最长匹配模式。</li>
</ul>
<pre><code class="hljs bash"><span class="hljs-comment"># URL=&quot;http://www.baidu.com/baike/user.html&quot;</span>
以 // 为分隔符截取右边字符串：
<span class="hljs-comment"># echo $&#123;URL#*//&#125;</span>
http://www.baidu.com/baike/user.html
以 / 为分隔符截取右边字符串：
<span class="hljs-comment"># echo $&#123;URL##*/&#125;</span>
user.html
以 // 为分隔符截取左边字符串：
<span class="hljs-comment"># echo $&#123;URL%%//*&#125;</span>
http:
以 / 为分隔符截取左边字符串：
<span class="hljs-comment"># echo $&#123;URL%/*&#125;</span>
http://www.baidu.com/baike
以. 为分隔符截取左边：
<span class="hljs-comment"># echo $&#123;URL%.*&#125;</span>
http://www.baidu.com/baike/user
以. 为分隔符截取右边：
<span class="hljs-comment"># echo $&#123;URL##*.&#125;</span>
html</code></pre>

<h2 id="2-5-变量状态赋值"><a href="#2-5-变量状态赋值" class="headerlink" title="2.5 变量状态赋值"></a>2.5 变量状态赋值</h2><ul>
<li>${VAR:-string}   如果 VAR 变量为空则返回 string</li>
<li>${VAR:+string}   如果 VAR 变量不为空则返回 string</li>
<li>${VAR:=string}   如果 VAR 变量为空则重新赋值 VAR 变量值为 string</li>
<li>${VAR:?string}   如果 VAR 变量为空则将 string 输出到 stderr</li>
</ul>
<pre><code class="hljs bash">如果变量为空就返回 hello world!：
<span class="hljs-comment"># VAR=</span>
<span class="hljs-comment"># echo $&#123;VAR:-&#x27;hello world!&#x27;&#125;</span>
hello world!
如果变量不为空就返回 hello world!：
<span class="hljs-comment"># VAR=&quot;hello&quot;</span>
<span class="hljs-comment"># echo $&#123;VAR:+&#x27;hello world!&#x27;&#125;</span>
hello world!
如果变量为空就重新赋值：
<span class="hljs-comment"># VAR=</span>
<span class="hljs-comment"># echo $&#123;VAR:=hello&#125;</span>
hello
<span class="hljs-comment"># echo $VAR</span>
hello
如果变量为空就将信息输出 stderr：
<span class="hljs-comment"># VAR=</span>
<span class="hljs-comment"># echo $&#123;VAR:?value is null&#125;</span>

- bash: VAR: value is null</code></pre>

<p>${} 主要用途大概就这么多了，另外还可以获取数组元素，在后面章节会讲到。</p>
<h2 id="2-6-字符串颜色"><a href="#2-6-字符串颜色" class="headerlink" title="2.6 字符串颜色"></a>2.6 字符串颜色</h2><p>再介绍下字符串输出颜色，有时候关键地方需要醒目，颜色是最好的方式：</p>
<table>
<thead>
<tr>
<th>字体颜色</th>
<th>字体背景颜色</th>
<th>显示方式</th>
</tr>
</thead>
<tbody><tr>
<td>30 ：黑</td>
<td>40：黑</td>
<td>0 ：终端默认设置</td>
</tr>
<tr>
<td>31 ：红</td>
<td>41：深红</td>
<td>1 ：高亮显示</td>
</tr>
<tr>
<td>32 ：绿</td>
<td>42：绿</td>
<td>4 ：下划线</td>
</tr>
<tr>
<td>33 ：黄</td>
<td>43：黄色</td>
<td>5 ：闪烁</td>
</tr>
<tr>
<td>34 ：蓝色</td>
<td>44：蓝色</td>
<td>7 ：反白显示</td>
</tr>
<tr>
<td>35 ：紫色</td>
<td>45：紫色</td>
<td>8 ：隐藏</td>
</tr>
<tr>
<td>36 ：深绿</td>
<td>46：深绿</td>
<td></td>
</tr>
<tr>
<td>37 ：白色</td>
<td>47：白色</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>\033[1;31;40m # 1 是显示方式，可选。31 是字体颜色。40m 是字体背景颜色。</td>
</tr>
<tr>
<td>\033[0m       # 恢复终端默认颜色，即取消颜色设置。</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># 字体颜色</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;31..37&#125;; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> - e <span class="hljs-string">&quot;\033[<span class="hljs-variable">$i</span>;40mHello world!\033[0m&quot;</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># 背景颜色</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;41..47&#125;; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> - e <span class="hljs-string">&quot;\033[47;<span class="hljs-variable">$&#123;i&#125;</span>mHello world!\033[0m&quot;</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># 显示方式</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..8&#125;; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> - e <span class="hljs-string">&quot;\033[<span class="hljs-variable">$i</span>;31;40mHello world!\033[0m&quot;</span>
<span class="hljs-keyword">done</span></code></pre>

<p><img src="/img/linux_shell/linux_shell_5.jpg" srcset="/img/loading.gif"></p>
<h1 id="三、-Shell-表达式与运算符"><a href="#三、-Shell-表达式与运算符" class="headerlink" title="三、 Shell 表达式与运算符"></a>三、 Shell 表达式与运算符</h1><h2 id="3-1-条件表达式"><a href="#3-1-条件表达式" class="headerlink" title="3.1 条件表达式"></a>3.1 条件表达式</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>[expression]</td>
<td>[ 1 -eq 1 ]</td>
</tr>
<tr>
<td>[[expression]]</td>
<td>[[ 1 -eq 1 ]]</td>
</tr>
<tr>
<td>test expression</td>
<td>test 1 -eq 1 , 等同于 []</td>
</tr>
</tbody></table>
<h2 id="3-2-整数比较符"><a href="#3-2-整数比较符" class="headerlink" title="3.2 整数比较符"></a>3.2 整数比较符</h2><table>
<thead>
<tr>
<th>比较符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>- eq，equal</td>
<td>等于</td>
<td>[1 -eq 1] 为 true</td>
</tr>
<tr>
<td>- ne，not equal</td>
<td>不等于</td>
<td>[1 -ne 1] 为 false</td>
</tr>
<tr>
<td>- gt，greater than</td>
<td>大于</td>
<td>[2 -gt 1] 为 true</td>
</tr>
<tr>
<td>- lt，lesser than</td>
<td>小于</td>
<td>[2 -lt 1] 为 false</td>
</tr>
<tr>
<td>- ge，greater or equal</td>
<td>大于或等于</td>
<td>[2 -ge 1] 为 true</td>
</tr>
<tr>
<td>- le，lesser or equal</td>
<td>小于或等于</td>
<td>[2 -le 1] 为 false</td>
</tr>
</tbody></table>
<h2 id="3-3-字符串比较符"><a href="#3-3-字符串比较符" class="headerlink" title="3.3 字符串比较符"></a>3.3 字符串比较符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>等于</td>
<td>[“a” == “a”] 为 true</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>[“a” != “a”] 为 false</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于，判断字符串时根据 <br>ASCII 码表顺序，不常用</td>
<td>在 [] 表达式中：[ 2 &gt; 1 ]为 true<br > 在 [[]] 表达式中：[[ 2 &gt; 1 ]]为 true<br > 在 (()) 表达式中：(( 3 &gt; 2 ))为 true</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于，判断字符串时根据 &lt; br&gt;ASCII 码表顺序，不常用</td>
<td>在 [] 表达式中：[ 2 &lt; 1 ]为 false<br > 在 [[]] 表达式中：[[ 2 &lt; 1 ]]为 false<br > 在 (()) 表达式中：(( 3 &lt; 2 ))为 false</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>在 (()) 表达式中：(( 3 &gt;= 2 ))为 true</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>在 (()) 表达式中：(( 3 &lt;= 2 ))为 false</td>
</tr>
<tr>
<td>- n</td>
<td>字符串长度不等于 0 为真</td>
<td>VAR1=1;VAR2=””<br>[ -n”$VAR1”] 为 true<br>[ -n”$VAR2” ] 为 false</td>
</tr>
<tr>
<td>- z</td>
<td>字符串长度等于 0 为真</td>
<td>VAR1=1;VAR2=””<br>[ -z”$VAR1”] 为 false<br>[ -z”$VAR2” ] 为 true</td>
</tr>
<tr>
<td>str</td>
<td>字符串存在为真</td>
<td>VAR1=1;VAR2=””<br>[ $VAR1 ] 为 true<br>[ $VAR2 ] 为 false</td>
</tr>
</tbody></table>
<p>需要注意的是，使用 -z 或 -n 判断字符串长度时，变量要加双引号。</p>
<p><strong>举例说明：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># [-z $a] &amp;&amp; echo yes || echo no</span>
yes
<span class="hljs-comment"># [-n $a] &amp;&amp; echo yes || echo no</span>
yes
<span class="hljs-comment"># 加了双引号才能正常判断是否为空</span>
<span class="hljs-comment"># [-z &quot;$a&quot;] &amp;&amp; echo yes || echo no</span>
yes
<span class="hljs-comment"># [-n &quot;$a&quot;] &amp;&amp; echo yes || echo no</span>
no
<span class="hljs-comment"># 使用了双中括号就不用了双引号</span>
<span class="hljs-comment"># [[-n $a]] &amp;&amp; echo yes || echo no</span>
no
<span class="hljs-comment"># [[-z $a]] &amp;&amp; echo yes || echo no</span>
yes</code></pre>

<h2 id="3-4-文件测试"><a href="#3-4-文件测试" class="headerlink" title="3.4 文件测试"></a>3.4 文件测试</h2><table>
<thead>
<tr>
<th>测试符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>- e</td>
<td>文件或目录存在为真</td>
<td>[-e path] path 存在为 true</td>
</tr>
<tr>
<td>- f</td>
<td>文件存在为真</td>
<td>[-f file_path] 文件存在为 true</td>
</tr>
<tr>
<td>- d</td>
<td>目录存在为真</td>
<td>[-d dir_path] 目录存在为 true</td>
</tr>
<tr>
<td>- r</td>
<td>有读权限为真</td>
<td>[-r file_path] file_path 有读权限为 true</td>
</tr>
<tr>
<td>- w</td>
<td>有写权限为真</td>
<td>[-w file_path] file_path 有写权限为 true</td>
</tr>
<tr>
<td>- x</td>
<td>有执行权限为真</td>
<td>[-x file_path] file_path 有执行权限为 true</td>
</tr>
<tr>
<td>- s</td>
<td>文件存在并且大小大于 0 为真</td>
<td>[-s file_path] file_path 存在并且大小大于 0 为 true</td>
</tr>
</tbody></table>
<h2 id="3-5-布尔运算符"><a href="#3-5-布尔运算符" class="headerlink" title="3.5 布尔运算符"></a>3.5 布尔运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非关系，条件结果取反</td>
<td>[! 1 -eq 2] 为 true</td>
</tr>
<tr>
<td>- a</td>
<td>和关系，在 [] 表达式中使用</td>
<td>[ 1 -eq 1 -a 2 -eq 2] 为 true</td>
</tr>
<tr>
<td>- o</td>
<td>或关系，在 [] 表达式中使用</td>
<td>[ 1 -eq 1 -o 2 -eq 1] 为 true</td>
</tr>
</tbody></table>
<h2 id="3-6-逻辑判断符"><a href="#3-6-逻辑判断符" class="headerlink" title="3.6 逻辑判断符"></a>3.6 逻辑判断符</h2><table>
<thead>
<tr>
<th>判断符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑和，在 [[]] 和(( ))表达式中 &lt; br &gt; 或判断表达式是否为真时使用</td>
<td>[[ 1 -eq 1 &amp;&amp; 2 -eq 2 ]]为 true<br>(( 1 == 1 &amp;&amp; 2 == 2 ))为 true<br>[ 1 -eq 1 ] &amp;&amp; echo yes 如果 &amp;&amp; 前 &lt; br &gt; 面表达式为 true 则执行后面的</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或，在 [[]] 和(( ))表达式中 &lt; br &gt; 或判断表达式是否为真时使用</td>
<td>[[ 1 -eq 1</td>
</tr>
</tbody></table>
<h2 id="3-7-整数运算"><a href="#3-7-整数运算" class="headerlink" title="3.7 整数运算"></a>3.7 整数运算</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>运算表达式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>$(())</td>
<td>$((1+1))</td>
</tr>
<tr>
<td>$[]</td>
<td>$[1+1]</td>
</tr>
</tbody></table>
<p>上面两个都不支持浮点运算。</p>
<p>$(()) 表达式还有一个用途，三目运算：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># 如果条件为真返回 1 ，否则返回 0</span>
<span class="hljs-comment"># echo $((1&lt;0))</span>
0
<span class="hljs-comment"># echo $((1&gt;0))</span>
1
指定输出数字：
<span class="hljs-comment"># echo $((1&gt;0?1:2))</span>
1
<span class="hljs-comment"># echo $((1&lt;0?1:2))</span>
2
注意：返回值不支持字符串</code></pre>

<h2 id="3-8-其他运算工具（let-expr-bc）"><a href="#3-8-其他运算工具（let-expr-bc）" class="headerlink" title="3.8 其他运算工具（let/expr/bc）"></a>3.8 其他运算工具（let/expr/bc）</h2><p>除了 Shell 本身的算数运算表达式，还有几个命令支持复杂的算数运算：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>let</td>
<td>赋值并运算，支持 ++、–</td>
<td>let VAR=(1+2)*3 ; echo $VAR<br>x=10 ; y=5<br>let x++;echo $x 每执行一次 x 加 1<br>let y–;echo $y 每执行一次 y 减 1<br>let x+=2 每执行一次 x 加 2<br>let x-=2 每执行一次 x 减 2</td>
</tr>
<tr>
<td>expr</td>
<td>乘法 \* 需要加反斜杠转义 \*</td>
<td>expr 1 \* 2 运算符两边必须有空格 <br>expr \( 1 + 2 \) \* 2 使用双括号时要转义</td>
</tr>
<tr>
<td>bc</td>
<td>计算器，支持浮点运算、平方等</td>
<td>bc 本身就是一个计算器，可直接输入命令，进入解释器。<br>echo 1 + 2 |bc 将管道符前面标准输出作为 bc 的标准输入 &lt; br&gt;echo “1.2+2” |bc<br>echo “10^10” |bc<br>echo ‘scale=2;10/3’ |bc 用 scale 保留两位小数点</td>
</tr>
</tbody></table>
<p>由于 Shell 不支持浮点数比较，可以借助 bc 来完成需求：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;1.2 &lt; 2&quot; |bc</span>
1
<span class="hljs-comment"># echo &quot;1.2 &gt; 2&quot; |bc</span>
0
<span class="hljs-comment"># echo &quot;1.2 == 2.2&quot; |bc</span>
0
<span class="hljs-comment"># echo &quot;1.2 != 2.2&quot; |bc</span>
1
看出规律了嘛？运算如果为真返回 1 ，否则返回 0 ，写一个例子：
<span class="hljs-comment"># [$(echo &quot;2.2&gt; 2&quot; |bc) -eq 1 ] &amp;&amp; echo yes || echo no</span>
yes
<span class="hljs-comment"># [$(echo &quot;2.2 &lt; 2&quot; |bc) -eq 1 ] &amp;&amp; echo yes || echo no</span>
no</code></pre>

<p>expr 还可以对字符串操作, 获取字符串长度：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># expr length &quot;string&quot;</span>
6
截取字符串：
<span class="hljs-comment"># expr substr &quot;string&quot; 4 6</span>
ing
获取字符在字符串中出现的位置：
<span class="hljs-comment"># expr index &quot;string&quot; str</span>
1
<span class="hljs-comment"># expr index &quot;string&quot; i</span>
4
获取字符串开始字符出现的长度：
<span class="hljs-comment"># expr match &quot;string&quot; s.*</span>
6
<span class="hljs-comment"># expr match &quot;string&quot; str</span>
3</code></pre>

<h2 id="3-9-Shell-括号用途总结"><a href="#3-9-Shell-括号用途总结" class="headerlink" title="3.9 Shell 括号用途总结"></a>3.9 Shell 括号用途总结</h2><p>看到这里，想一想里面所讲的小括号、中括号的用途，是不是有点懵逼了。那我们总结一下！</p>
<table>
<thead>
<tr>
<th>括号</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>()</td>
<td>用途 1 ：在运算中，先计算小括号里面的内容 &lt; br&gt; 用途 2 ：数组 &lt; br &gt; 用途 3 ：匹配分组</td>
</tr>
<tr>
<td>(())</td>
<td>用途 1 ：表达式，不支持 - eq 这类的运算符。不支持 - a 和 - o，支持 &lt;=、&gt;=、&lt;、&gt; 这类 &lt; br &gt; 比较符和 &amp;&amp;、||<br > 用途 2 ：C 语言风格的 for(())表达式</td>
</tr>
<tr>
<td>$( )</td>
<td>执行 Shell 命令，与反撇号等效</td>
</tr>
<tr>
<td>$(())</td>
<td>用途 1 ：简单算数运算 &lt; br &gt; 用途 2 ：支持三目运算符 $(( 表达式? 数字: 数字 ))</td>
</tr>
<tr>
<td>[ ]</td>
<td>条件表达式，里面不支持逻辑判断符</td>
</tr>
<tr>
<td>[[]]</td>
<td>条件表达式，里面不支持 - a 和 - o，不支持 &lt;= 和&gt;= 比较符，支持 - eq、&lt;、&gt; 这类比较 &lt; br &gt; 符。支持 =~ 模式匹配，也可以不用双引号也不会影响原意，比 [] 更加通用</td>
</tr>
<tr>
<td>$[ ]</td>
<td>简单算数运算</td>
</tr>
<tr>
<td>{}</td>
<td>对逗号（,）和点点（…）起作用，比如 touch {1,2} 创建 1 和 2 文件，touch<br>{1..3} 创建 1 、 2 和 3 文件</td>
</tr>
<tr>
<td>${}</td>
<td>用途 1 ：引用变量 &lt; br&gt; 用途 2 ：字符串处理</td>
</tr>
</tbody></table>
<h1 id="四、-Shell-流程控制"><a href="#四、-Shell-流程控制" class="headerlink" title="四、 Shell 流程控制"></a>四、 Shell 流程控制</h1><p>流程控制是改变程序运行顺序的指令。</p>
<h2 id="4-1-if-语句"><a href="#4-1-if-语句" class="headerlink" title="4.1 if 语句"></a>4.1 if 语句</h2><p>格式：<strong>if list; then list; [elif list; then list;] … [ else list; ] fi</strong></p>
<h3 id="4-1-1-单分支"><a href="#4-1-1-单分支" class="headerlink" title="4.1.1 单分支"></a>4.1.1 单分支</h3><pre><code class="hljs bash"><span class="hljs-keyword">if</span> 条件表达式; <span class="hljs-keyword">then</span>
命令
<span class="hljs-keyword">fi</span></code></pre>

<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
N=10
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -gt 5]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> yes
<span class="hljs-keyword">fi</span>
<span class="hljs-comment"># bash test.sh</span>
yes</code></pre>

<h3 id="4-1-2-双分支"><a href="#4-1-2-双分支" class="headerlink" title="4.1.2 双分支"></a>4.1.2 双分支</h3><pre><code class="hljs bash"><span class="hljs-keyword">if</span> 条件表达式; <span class="hljs-keyword">then</span>
命令
<span class="hljs-keyword">else</span>
命令
<span class="hljs-keyword">fi</span></code></pre>

<p><strong>示例 1 ：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
N=10
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -lt 5]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> yes
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> no
<span class="hljs-keyword">fi</span>
<span class="hljs-comment"># bash test.sh</span>
no</code></pre>

<p><strong>示例 2 ：判断 crond 进程是否运行</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
NAME=crond
NUM=$(ps -ef |grep <span class="hljs-variable">$NAME</span> |grep -vc grep)
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$NUM</span> -eq 1]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> running.&quot;</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> is not running!&quot;</span>
<span class="hljs-keyword">fi</span></code></pre>

<p><strong>示例 3 ：检查主机是否存活</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">if</span> ping -c 1 192.168.1. 1 &gt;/dev/null; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;OK.&quot;</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;NO!&quot;</span>
<span class="hljs-keyword">fi</span></code></pre>

<p>if 语句可以直接对命令状态进行判断，就省去了获取 $? 这一步！</p>
<h3 id="4-1-3-多分支"><a href="#4-1-3-多分支" class="headerlink" title="4.1.3 多分支"></a>4.1.3 多分支</h3><pre><code class="hljs bash"><span class="hljs-keyword">if</span> 条件表达式; <span class="hljs-keyword">then</span>
命令
<span class="hljs-keyword">elif</span> 条件表达式; <span class="hljs-keyword">then</span>
命令
<span class="hljs-keyword">else</span>
命令
<span class="hljs-keyword">fi</span></code></pre>

<p>当不确定条件符合哪一个时，就可以把已知条件判断写出来，做相应的处理。</p>
<p><strong>示例 1 ：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
N=<span class="hljs-variable">$1</span>
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -eq 3]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eq 3&quot;</span>
<span class="hljs-keyword">elif</span> [<span class="hljs-variable">$N</span> -eq 5]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eq 5&quot;</span>
<span class="hljs-keyword">elif</span> [<span class="hljs-variable">$N</span> -eq 8]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eq 8&quot;</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;no&quot;</span>
<span class="hljs-keyword">fi</span></code></pre>

<p>如果第一个条件符合就不再向下匹配。</p>
<p><strong>示例 2 ：根据 Linux 不同发行版使用不同的命令安装软件</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">if</span> [-e /etc/redhat-release]; <span class="hljs-keyword">then</span>
  yum install wget -y
<span class="hljs-keyword">elif</span> [$(cat /etc/issue |cut -d<span class="hljs-string">&#x27;&#x27;</span> -f 1) ==<span class="hljs-string">&quot;Ubuntu&quot;</span> ]; <span class="hljs-keyword">then</span>
  apt-get install wget -y
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;perating system does not support.&#x27;</span>
  <span class="hljs-built_in">exit</span>
<span class="hljs-keyword">fi</span></code></pre>

<h2 id="4-2-for-语句"><a href="#4-2-for-语句" class="headerlink" title="4.2 for 语句"></a>4.2 for 语句</h2><p>格式：<strong>for name [[ in [ word …] ] ; ] do list ; done</strong></p>
<pre><code class="hljs bash"><span class="hljs-keyword">for</span> 变量名 <span class="hljs-keyword">in</span> 取值列表; <span class="hljs-keyword">do</span>
命令
<span class="hljs-keyword">done</span></code></pre>

<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..3&#125;; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
1
2
3</code></pre>

<p>for 的语法也可以这么写：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; &#123; <span class="hljs-comment"># $@是将位置参数作为单个来处理</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
&#125;
<span class="hljs-comment"># bash test.sh 1 2 3</span>
1
2
3</code></pre>

<p>默认 for 循环的取值列表是以空白符分隔，也就是第一章讲系统变量里的 $IFS:</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 12 34; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
12
34</code></pre>

<p>如果想指定分隔符，可以重新赋值 $IFS 变量：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
OLD_IFS=<span class="hljs-variable">$IFS</span>
IFS=<span class="hljs-string">&quot;:&quot;</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(head -1 /etc/passwd); <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span>
IFS=<span class="hljs-variable">$OLD_IFS</span> <span class="hljs-comment"># 恢复默认值</span>
<span class="hljs-comment"># bash test.sh</span>
root
x
0
0
root
/root
/bin/bash</code></pre>

<p>for 循环还有一种 C 语言风格的语法，常用于计数、打印数字序列：</p>
<p><strong>for ((expr1 ; expr2 ; expr3)) ; do list ; done</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">for</span> ((i=1;i&lt;=5;i++)); <span class="hljs-keyword">do</span> <span class="hljs-comment"># 也可以 i--</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span></code></pre>

<p><strong>示例 1 ：检查多个主机是否存活</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> 192.168.1.&#123;1..254&#125;; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> ping -c 1 <span class="hljs-variable">$ip</span> &gt;/dev/null; <span class="hljs-keyword">then</span>
   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$ip</span> OK.&quot;</span>
  <span class="hljs-keyword">else</span>
   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$ip</span> NO!&quot;</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<p><strong>示例 2 ：检查多个域名是否可以访问</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
URL=<span class="hljs-string">&quot;www.baidu.com www.sina.com www.jd.com&quot;</span>
<span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> <span class="hljs-variable">$URL</span>; <span class="hljs-keyword">do</span>
  HTTP_CODE=$(curl -o /dev/null -s -w %&#123;http_code&#125; http://<span class="hljs-variable">$url</span>)
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -eq 200 -o <span class="hljs-variable">$HTTP_CODE</span> -eq 301]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$url</span> OK.&quot;</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$url</span> NO!&quot;</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="4-3-while-语句"><a href="#4-3-while-语句" class="headerlink" title="4.3 while 语句"></a>4.3 while 语句</h2><p>格式：<strong>while list; do list; done</strong></p>
<pre><code class="hljs bash"><span class="hljs-keyword">while</span> 条件表达式; <span class="hljs-keyword">do</span>
命令
<span class="hljs-keyword">done</span></code></pre>

<p><strong>示例 1 ：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
N=0
<span class="hljs-keyword">while</span> [<span class="hljs-variable">$N</span> -lt 5]; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">let</span> N++
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$N</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
1
2
3
4
5</code></pre>

<p>当条件表达式为 false 时，终止循环。</p>
<p><strong>示例 2 ：条件表达式为 true，将会产生死循环</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">while</span> [1 -eq 1]; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes&quot;</span>
<span class="hljs-keyword">done</span></code></pre>

<p>也可以条件表达式直接用 true：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes&quot;</span>
<span class="hljs-keyword">done</span></code></pre>

<p>还可以条件表达式用冒号，冒号在 Shell 中的意思是不做任何操作。但状态是 0 ，因此为 true：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">while</span> :; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes&quot;</span>
<span class="hljs-keyword">done</span></code></pre>

<p><strong>示例 3 ：逐行处理文本</strong></p>
<p>文本内容：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat a.txt</span>
a b c
1 2 3
x y z</code></pre>

<p>要想使用 while 循环逐行读取 a.txt 文件，有三种方式：</p>
<p><strong>方式 1 ：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
cat ./a.txt | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> LINE; <span class="hljs-keyword">do</span>
                <span class="hljs-built_in">echo</span> <span class="hljs-variable">$LINE</span>
<span class="hljs-keyword">done</span></code></pre>

<p><strong>方式 2 ：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> LINE; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$LINE</span>
<span class="hljs-keyword">done</span> &lt; ./a.txt</code></pre>

<p><strong>方式 3 ：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">exec</span> &lt; ./a.txt <span class="hljs-comment"># 读取文件作为标准输出</span>
<span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> LINE; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$LINE</span>
<span class="hljs-keyword">done</span></code></pre>

<p>与 while 关联的还有一个 until 语句，它与 while 不同之处在于，是当条件表达式为 false 时才循环，实际使用中比较少，这里不再讲解。</p>
<h2 id="4-4-break-和-continue-语句"><a href="#4-4-break-和-continue-语句" class="headerlink" title="4.4 break 和 continue 语句"></a>4.4 break 和 continue 语句</h2><ul>
<li>break    是终止循环。</li>
<li>continue 是跳出当前循环。</li>
</ul>
<p><strong>示例 1 ：在死循环中，满足条件终止循环</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
N=0
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">let</span> N++
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -eq 5]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">break</span>
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$N</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
1
2
3
4</code></pre>

<p>里面用了 <strong>if</strong> 判断，并用了 <strong>break</strong> 语句，它是跳出循环。与其关联的还有一个 <strong>continue</strong> 语句，它是跳出本次循环。</p>
<p><strong>示例 2 ：举例子说明 continue 用法</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
N=0
<span class="hljs-keyword">while</span> [<span class="hljs-variable">$N</span> -lt 5]; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">let</span> N++
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$N</span> -eq 3]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">continue</span>
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$N</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
1
2
4
5</code></pre>

<p>当变量 N 等于 3 时，continue 跳过了当前循环，没有执行下面的 echo。</p>
<p><strong>注意：continue 与 break 语句只能循环语句中使用。</strong></p>
<h2 id="4-5-case-语句"><a href="#4-5-case-语句" class="headerlink" title="4.5 case 语句"></a>4.5 case 语句</h2><p>case 语句一般用于选择性来执行对应部分块命令。</p>
<p>格式：<strong>case word in [[(] pattern [ | pattern ] … ) list ;; ] … esac</strong></p>
<pre><code class="hljs bash"><span class="hljs-keyword">case</span> 模式名 <span class="hljs-keyword">in</span>
  模式 1)
    命令
    ;;
  模式 2)
    命令
    ;;
  *)
    不符合以上模式执行的命令
<span class="hljs-keyword">esac</span></code></pre>

<p>每个模式必须以右括号结束，命令结尾以双分号结束。</p>
<p><strong>示例：根据位置参数匹配不同的模式</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>
  start)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;start.&quot;</span>
    ;;
  stop)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;stop.&quot;</span>
    ;;
  restart)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;restart.&quot;</span>
    ;;
  *)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$0</span> &#123;start|stop|restart&#125;&quot;</span>
<span class="hljs-keyword">esac</span>

<span class="hljs-comment"># bash test.sh</span>
Usage: test.sh &#123;start|stop|restart&#125;
<span class="hljs-comment"># bash test.sh start</span>
start.
<span class="hljs-comment"># bash test.sh stop</span>
stop.
<span class="hljs-comment"># bash test.sh restart</span>
restart.</code></pre>

<p>上面例子是不是有点眼熟，在 Linux 下有一部分服务启动脚本都是这么写的。</p>
<p>模式也支持正则，匹配哪个模式就执行那个：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>
  [0-9])
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;match number.&quot;</span>
    ;;
  [a-z])
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;match letter.&quot;</span>
    ;;
  <span class="hljs-string">&#x27;-h&#x27;</span>|<span class="hljs-string">&#x27;--help&#x27;</span>)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;help&quot;</span>
    ;;
  *)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Input error!&quot;</span>
    <span class="hljs-built_in">exit</span>
<span class="hljs-keyword">esac</span>

<span class="hljs-comment"># bash test.sh 1</span>
match number.
<span class="hljs-comment"># bash test.sh a</span>
match letter.
<span class="hljs-comment"># bash test.sh - h</span>
<span class="hljs-built_in">help</span>
<span class="hljs-comment"># bash test.sh --help</span>
<span class="hljs-built_in">help</span></code></pre>

<p>模式支持的正则有：*、?、[]、[.-.]、|。后面有章节单独讲解 Shell 正则表达式。</p>
<h2 id="4-6-select-语句"><a href="#4-6-select-语句" class="headerlink" title="4.6 select 语句"></a>4.6 select 语句</h2><p>select 是一个类似于 for 循环的语句。</p>
<p>格式：<strong>select name [in word] ; do list ; done</strong></p>
<pre><code class="hljs bash">select 变量 <span class="hljs-keyword">in</span> 选项 1 选项 2; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">break</span>
<span class="hljs-keyword">done</span></code></pre>

<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
select mysql_version <span class="hljs-keyword">in</span> 5.1 5.6; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$mysql_version</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
1) 5.1
2) 5.6
<span class="hljs-comment">#? 1</span>
5.1
<span class="hljs-comment">#? 2</span>
5.6</code></pre>

<p>用户输入编号会直接赋值给变量 mysql_version。作为菜单用的话，循环第二次后就不再显示菜单了，并不能满足需求。</p>
<p>在外面加个死循环，每次执行一次 select 就 break 一次，这样就能每次显示菜单了：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>
  select mysql_version <span class="hljs-keyword">in</span> 5.1 5.6; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$mysql_version</span>
    <span class="hljs-built_in">break</span>
  <span class="hljs-keyword">done</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
1) 5.1
2) 5.6
<span class="hljs-comment">#? 1</span>
5.1
1) 5.1
2) 5.6
<span class="hljs-comment">#? 2</span>
5.6
1) 5.1
2) 5.6</code></pre>

<p>如果再判断对用户输入的编号执行相应的命令，如果用 if 语句多分支的话要复杂许多，用 case 语句就简单多了：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
PS3=<span class="hljs-string">&quot;Select a number:&quot;</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>
  select mysql_version <span class="hljs-keyword">in</span> 5.1 5.6 quit; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">case</span> <span class="hljs-variable">$mysql_version</span> <span class="hljs-keyword">in</span>
      5.1)
        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;mysql 5.1&quot;</span>
        <span class="hljs-built_in">break</span>
        ;;
      5.6)
        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;mysql 5.6&quot;</span>
        <span class="hljs-built_in">break</span>
        ;;
      quit)
        <span class="hljs-built_in">exit</span>
        ;;
      *)
         <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Input error, Please enter again!&quot;</span>
      <span class="hljs-built_in">break</span>
    <span class="hljs-keyword">esac</span>
  <span class="hljs-keyword">done</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
1) 5.1
2) 5.6
3) quit
Select a number: 1
mysql 5.1
1) 5.1
2) 5.6
3) quit
Select a number: 2
mysql 5.6
1) 5.1
2) 5.6
3) quit
Select a number: 3</code></pre>

<p>如果不想用默认的提示符，可以通过重新赋值变量 PS3 来自定义。这下就比较完美了！</p>
<h1 id="五、-Shell-函数与数组"><a href="#五、-Shell-函数与数组" class="headerlink" title="五、 Shell 函数与数组"></a>五、 Shell 函数与数组</h1><h2 id="5-1-函数"><a href="#5-1-函数" class="headerlink" title="5.1 函数"></a>5.1 函数</h2><p><strong>格式：</strong></p>
<pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;
<span class="hljs-built_in">command</span>
&#125;</code></pre>

<p><strong>function</strong> 关键字可写，也可不写。</p>
<p><strong>示例 1 ：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a function.&quot;</span>
&#125;
func
<span class="hljs-comment"># bash test.sh</span>
This is a <span class="hljs-keyword">function</span>.</code></pre>

<p>Shell 函数很简单，函数名后跟双括号，再跟双大括号。通过函数名直接调用，不加小括号。</p>
<p><strong>示例 2 ：函数返回值</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;
  VAR=$((<span class="hljs-number">1</span>+<span class="hljs-number">1</span>))
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$VAR</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a function.&quot;</span>
&#125;
func
<span class="hljs-built_in">echo</span> $?
<span class="hljs-comment"># bash test.sh</span>
2</code></pre>

<p>return 在函数中定义状态返回值，返回并终止函数，但返回的只能是 0 - 255 的数字，类似于 exit。</p>
<p><strong>示例 3 ：函数传参</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$1</span>&quot;</span>
&#125;
func world
<span class="hljs-comment"># bash test.sh</span>
Hello world</code></pre>

<p>通过 Shell 位置参数给函数传参。</p>
<p>函数也支持递归调用，也就是自己调用自己。</p>
<p><strong>例如：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">test</span></span>() &#123;
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span>
  sleep 1
  <span class="hljs-built_in">test</span> hello
&#125;
<span class="hljs-built_in">test</span></code></pre>

<p>执行会一直在调用本身打印 hello，这就形成了闭环。</p>
<p>像经典的 fork 炸弹就是函数递归调用：</p>
<p><code>:()&#123; :|:&amp;&#125;;:</code> 或 <code>.()&#123;.|.&amp;&#125;;.</code></p>
<p>这样看起来不好理解，我们更改下格式：</p>
<pre><code class="hljs bash">:() &#123;
  :|:&amp;
&#125;;
:</code></pre>

<p>再易读一点：</p>
<pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">bomb</span></span>() &#123;
  bomb|bomb&amp;
&#125;;
bomb</code></pre>

<p>分析下：</p>
<ul>
<li>:(){} 定义一个函数，函数名是冒号。</li>
<li>: 调用自身函数</li>
<li>| 管道符</li>
<li>: 再一次递归调用自身函数</li>
<li>:|: 表示每次调用函数 “:” 的时候就会生成两份拷贝。</li>
<li>&amp; 放到后台</li>
<li>; 分号是继续执行下一个命令，可以理解为换行。</li>
<li>: 最后一个冒号是调用函数。</li>
</ul>
<p>因此不断生成新进程，直到系统资源崩溃。</p>
<p>一般递归函数用的也少，了解下即可！</p>
<h2 id="5-2-数组"><a href="#5-2-数组" class="headerlink" title="5.2 数组"></a>5.2 数组</h2><p>数组是相同类型的元素按一定顺序排列的集合。</p>
<p><strong>格式：</strong></p>
<p>array=(元素 1 元素 2 元素 3 …)</p>
<p>用小括号初始化数组，元素之间用空格分隔。</p>
<p><strong>定义方法 1</strong> ：初始化数组</p>
<p>array=(a b c)</p>
<p><strong>定义方法 2</strong> ：新建数组并添加元素</p>
<p>array[下标]= 元素</p>
<p><strong>定义方法 3</strong>：将命令输出作为数组元素</p>
<p>array=($(command))</p>
<p><strong>数组操作：</strong></p>
<pre><code class="hljs bash">获取所有元素：
<span class="hljs-comment"># echo $&#123;array[*]&#125; # * 和 @ 都是代表所有元素</span>
a b c
获取元素下标：
<span class="hljs-comment"># echo $&#123;!a[@]&#125;</span>
0 1 2
获取数组长度：
<span class="hljs-comment"># echo $&#123;#array[*]&#125;</span>
3
获取第一个元素：
<span class="hljs-comment"># echo $&#123;array[0]&#125;</span>
a
获取第二个元素：
<span class="hljs-comment"># echo $&#123;array[1]&#125;</span>
b
获取第三个元素：
<span class="hljs-comment"># echo $&#123;array[2]&#125;</span>
c
添加元素：
<span class="hljs-comment"># array[3]=d</span>
<span class="hljs-comment"># echo $&#123;array[*]&#125;</span>
a b c d
添加多个元素：
<span class="hljs-comment"># array+=(e f g)</span>
<span class="hljs-comment"># echo $&#123;array[*]&#125;</span>
a b c d e f g
删除第一个元素：
<span class="hljs-comment"># unset array[0] # 删除会保留元素下标</span>
<span class="hljs-comment"># echo $&#123;array[*]&#125;</span>
b c d e f g
删除数组：
<span class="hljs-comment"># unset array</span></code></pre>

<p><font color=red> 数组下标从 0 开始。</font></p>
<p><strong>示例 1</strong>：讲 seq 生成的数字序列循环放到数组里面</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(seq 1 10); <span class="hljs-keyword">do</span>
  array[a]=<span class="hljs-variable">$i</span>
  <span class="hljs-built_in">let</span> a++
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[*]&#125;</span>
<span class="hljs-comment"># bash test.sh</span>
1 2 3 4 5 6 7 8 9 10</code></pre>

<p><strong>示例 2</strong> ：遍历数组元素</p>
<pre><code class="hljs bash">方法 1 ：
<span class="hljs-meta">#!/bin/bash</span>
IP=(192.168.1.1 192.168.1.2 192.168.1.3)
<span class="hljs-keyword">for</span> ((i=0;i&lt;<span class="hljs-variable">$&#123;#IP[*]&#125;</span>;i++)); <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;IP[$i]&#125;</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
192.168.1.1
192.168.1.2
192.168.1.3

方法 2 ：
<span class="hljs-meta">#!/bin/bash</span>
IP=(192.168.1.1 192.168.1.2 192.168.1.3)
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;IP[*]&#125;</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>
<span class="hljs-keyword">done</span></code></pre>

<h1 id="六、-Shell-正则表达式"><a href="#六、-Shell-正则表达式" class="headerlink" title="六、 Shell 正则表达式"></a>六、 Shell 正则表达式</h1><p>正则表达式在每种语言中都会有，功能就是匹配符合你预期要求的字符串。</p>
<p>Shell 正则表达式分为 <strong>两种</strong>：</p>
<ul>
<li>基础正则表达式：BRE（basic regular express）</li>
<li>扩展正则表达式：ERE（extend regular express），扩展的表达式有 +、?、| 和 ()</li>
</ul>
<p>下面是一些常用的正则表达式符号，我们先拿 grep 工具举例说明。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符 (\n) 之外的任 &lt; br &gt; 意单个字符</td>
<td>匹配 123 ：<br>echo -e “123\n456” |grep ‘1.3’</td>
</tr>
<tr>
<td>^</td>
<td>匹配前面字符串开头</td>
<td>匹配以 abc 开头的行：<br>echo -e “abc\nxyz” |grep ^abc</td>
</tr>
<tr>
<td>$</td>
<td>匹配前面字符串结尾</td>
<td>匹配以 xyz 结尾的行：<br>echo -e “abc\nxyz” |grep xyz$</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个字符零个或多个</td>
<td>匹配 x、xo 和 xoo：<br>echo -e “x\nxo\nxoo\no\noo” |grep “xo*”<br>x 是必须的，批量了 0 零个或多个</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面字符 1 个或多个</td>
<td>匹配 abc 和 abcc：<br>echo -e “abc\nabcc\nadd” |grep -E ‘ab+’<br > 匹配单个数字：echo “113” |grep -o ‘[0-9]’<br > 连续匹配多个数字：echo “113” |grep -E -o ‘[0-9]+’</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面字符 0 个或 1 个</td>
<td>匹配 ac 或 abc：<br>echo -e “ac\nabc\nadd” |grep -E ‘a?c’</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号之中的任意一个字符</td>
<td>匹配 a 或 c：<br>echo -e “a\nb\nc” |grep ‘[ac]’</td>
</tr>
<tr>
<td>[.-.]</td>
<td>匹配中括号中范围内的任意一个字符</td>
<td>匹配所有字母：<br>echo -e “a\nb\nc” |grep ‘[a-z]’</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配 [^ 字符] 之外的任意一个字符</td>
<td>匹配 a 或 b：<br>echo -e “a\nb\nc” |grep ‘[^c-z]’<br > 匹配末尾数字：echo “abc:cde;123” |grep -E<br>‘[^;]+$’</td>
</tr>
<tr>
<td>^[^]</td>
<td>匹配不是中括号内任意一个 &lt; br &gt; 字符开头的行</td>
<td>匹配不是 #开头的行：<br>grep ‘^[^#]’ /etc/httpd/conf/httpd.conf</td>
</tr>
<tr>
<td>{n} 或 &lt; br&gt;{n,}</td>
<td>匹配花括号前面字符至少 n 个字符</td>
<td>匹配 abc 字符串（至少三个字符以上字符串）：<br>echo -e “a\nabc\nc” |grep -E ‘[a-z]{3}’</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配花括号前面字符至少 n<br > 个字符，最多 m 个字符</td>
<td>匹配 12 和 123 （不加边界符会匹配单个字符）：<br>echo -e “1\n12\n123\n1234” |grep -E -w -o ‘[0-9]{2,3}’</td>
</tr>
<tr>
<td>&lt;</td>
<td>边界符，匹配字符串开始</td>
<td>匹配开始是 123 和 1234 ：<br>echo - e “1\n12\n123\n1234” |grep ‘&lt;123’</td>
</tr>
<tr>
<td>&gt;</td>
<td>边界符，匹配字符串结束</td>
<td>匹配结束是 1234 ：<br>echo - e “1\n12\n123\n1234” |grep ‘4&gt;‘</td>
</tr>
<tr>
<td>()</td>
<td>单元或组合：将小括号里面 &lt; br&gt; 作为一个组合 &lt; br &gt; 分组：匹配小括号中正则表 &lt; br &gt; 达式或字符。\n 反向引 &lt; br &gt; 用，n 是数字，从 1 开始编 &lt; br &gt; 号，表示引用第 n 个分组匹 &lt; br &gt; 配的内容</td>
<td>单元：匹配 123a 字符串 &lt; br&gt;echo “123abc” |grep -E -o ‘([0-9a-z]){4}’<br > 分组：匹配 11<br>echo “113abc” |grep -E -o ‘(1)\1’<br > 匹配出现 xo 出现零次或多次：<br>echo -e “x\nxo\nxoo\no\noo” |egrep “(xo)*”</td>
</tr>
<tr>
<td>|</td>
<td>匹配竖杠两边的任意一个</td>
<td>匹配 12 和 123 ：<br>echo -e “1\n12\n123\n1234” |grep -E ‘12&gt;|123&gt;‘</td>
</tr>
<tr>
<td>\</td>
<td>转义符，将特殊符号转成原 <br> 有意义</td>
<td>1.2，匹配 1.2： 1 .2，否则 112 也会匹配到</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Posix 字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>等效 [a-zA-Z0-9]</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>等效 [a-zA-Z]</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>等效 [a-z]</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>等效 [A-Z]</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>等效 [0-9]</td>
</tr>
<tr>
<td>[:space:]</td>
<td>匹配任意空白字符，等效 [\t\n\r\f\v]</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>非空白字符</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格与定位字符</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>控制字符</td>
</tr>
<tr>
<td>[:print:]</td>
<td>可显示的字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号字符</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>十六进制</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;1\n12\n123\n1234a&quot;</span> |grep <span class="hljs-string">&#x27;[[:digit:]]&#x27;</span></code></pre>

<p>在 Shell 下使用这些正则表达式处理文本最多的命令有下面几个工具：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>grep</td>
<td>默认不支持扩展表达式，加 - E 选项开启 ERE。如果不加 - E 使用花括号要加 <br> 转义符 {}</td>
</tr>
<tr>
<td>egrep</td>
<td>支持基础和扩展表达式</td>
</tr>
<tr>
<td>awk</td>
<td>支持 egrep 所有的正则表达式</td>
</tr>
<tr>
<td>sed</td>
<td>默认不支持扩展表达式，加 - r 选项开启 ERE。如果不加 - r 使用花括号要加 <br> 转义符 {}</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>支持的特殊字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\w</td>
<td>匹配任意数字和字母，等效 [a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>与 \ w 相反，等效 [^a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\b</td>
<td>匹配字符串开始或结束，等效 \&lt;和 \&gt;</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白字符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>空白符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\ 0</td>
<td>空值符</td>
</tr>
<tr>
<td>\b</td>
<td>退后一格</td>
</tr>
</tbody></table>
<h1 id="七、-Shell-文本处理三剑客"><a href="#七、-Shell-文本处理三剑客" class="headerlink" title="七、 Shell 文本处理三剑客"></a>七、 Shell 文本处理三剑客</h1><h2 id="7-1-grep"><a href="#7-1-grep" class="headerlink" title="7.1 grep"></a>7.1 grep</h2><p>过滤来自一个文件或标准输入匹配模式内容。</p>
<p>除了 grep 外，还有 egrep、fgrep。egrep 是 grep 的扩展，相当于 grep -E。fgrep 相当于 grep -f，用的少。</p>
<p><strong>Usage: grep [OPTION]… PATTERN [FILE]…</strong></p>
<table>
<thead>
<tr>
<th>支持的正则</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>- E，–extended-regexp</td>
<td>模式是扩展正则表达式（ERE）</td>
</tr>
<tr>
<td>- P，–perl-regexp</td>
<td>模式是 Perl 正则表达式</td>
</tr>
<tr>
<td>- e，–regexp=PATTERN</td>
<td>使用模式匹配，可指定多个模式匹配</td>
</tr>
<tr>
<td>- f，–file=FILE</td>
<td>从文件每一行获取匹配模式</td>
</tr>
<tr>
<td>- i，–ignore-case</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>- w，–word-regexp</td>
<td>模式匹配整个单词</td>
</tr>
<tr>
<td>- x，–line-regexp</td>
<td>模式匹配整行</td>
</tr>
<tr>
<td>- v，–invert-match</td>
<td>打印不匹配的行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>输出控制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>- m，–max-count=NUM</td>
<td>输出匹配的结果 num 数</td>
</tr>
<tr>
<td>- n，–line-number</td>
<td>打印行号</td>
</tr>
<tr>
<td>- H，–with-filename</td>
<td>打印每个匹配的文件名</td>
</tr>
<tr>
<td>- h，–no-filename</td>
<td>不输出文件名</td>
</tr>
<tr>
<td>- o，–only-matching</td>
<td>只打印匹配的内容</td>
</tr>
<tr>
<td>- q，–quiet</td>
<td>不输出正常信息</td>
</tr>
<tr>
<td>- s, –no-messages</td>
<td>不输出错误信息</td>
</tr>
<tr>
<td>- r，–recursive</td>
<td>递归目录</td>
</tr>
<tr>
<td>- c，–count</td>
<td>只打印每个文件匹配的行数</td>
</tr>
<tr>
<td>–include=FILE_PATTERN</td>
<td>只检索匹配的文件</td>
</tr>
<tr>
<td>–exclude=FILE_PATTERN</td>
<td>跳过匹配的文件</td>
</tr>
<tr>
<td>–exclude-from=FILE</td>
<td>跳过匹配的文件，来自文件模式</td>
</tr>
<tr>
<td>–exclude-dir=PATTERN</td>
<td>跳过匹配的目录</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>内容行控制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>- B，–before-context=NUM</td>
<td>打印匹配的前几行</td>
</tr>
<tr>
<td>- A，–after-context=NUM</td>
<td>打印匹配的后几行</td>
</tr>
<tr>
<td>- C，–context=NUM</td>
<td>打印匹配的前后几行</td>
</tr>
<tr>
<td>–color[=WHEN]</td>
<td>匹配的字体颜色</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<p>1 ）输出 b 文件中在 a 文件相同的行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># grep -f a b</span></code></pre>

<p>2 ）输出 b 文件中在 a 文件不同的行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># grep -v -f a b</span></code></pre>

<p>3 ） 匹配多个模式</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a bc de&quot; |xargs -n1 |grep -e &#x27;a&#x27; -e &#x27;bc&#x27;</span>
a
bc</code></pre>

<p>4 ）去除空格 http.conf 文件空行或开头 #号的行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># grep -E -v &quot;^$|^#&quot; /etc/httpd/conf/httpd.conf</span></code></pre>

<p>5 ） 匹配开头不分大小写的单词</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;A a b c&quot; |xargs -n1 |grep -i a</span>
或
<span class="hljs-comment"># echo &quot;A a b c&quot; |xargs -n1 |grep &#x27;[Aa]&#x27;</span>
A
a</code></pre>

<p>6 ）只显示匹配的字符串</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;this is a test&quot; |grep -o &#x27;is&#x27;</span>
is
is</code></pre>

<p>7 ）输出匹配的前五个结果</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 1 20 |grep -m 5 -E &#x27;[0-9]&#123;2&#125;&#x27;</span>
10
11
12
13
14</code></pre>

<p>8 ）统计匹配多少行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 1 20 |grep -c -E &#x27;[0-9]&#123;2&#125;&#x27;</span>
11</code></pre>

<p>9 ） 匹配 b 字符开头的行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a bc de&quot; |xargs -n1 |grep &#x27;^b&#x27;</span>
bc</code></pre>

<p>10 ） 匹配 de 字符结尾的行并输出匹配的行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a ab abc abcd abcde&quot; |xargs -n1 |grep -n &#x27;de$&#x27;</span>
5:abcde</code></pre>

<p>11 ） 递归搜索 / etc 目录下包含 ip 的 conf 后缀文件</p>
<pre><code class="hljs bash"><span class="hljs-comment"># grep -r &#x27;192.167.1.1&#x27; /etc --include *.conf</span></code></pre>

<p>12 ） 排除搜索 bak 后缀的文件</p>
<pre><code class="hljs bash"><span class="hljs-comment"># grep -r &#x27;192.167.1.1&#x27; /opt --exclude *.bak</span></code></pre>

<p>13 ） 排除来自 file 中的文件</p>
<pre><code class="hljs bash"><span class="hljs-comment"># grep -r &#x27;192.167.1.1&#x27; /opt --exclude-from file</span></code></pre>

<p>14 ） 匹配 41 或 42 的数字</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 41 45 |grep -E &#x27;4[12]&#x27;</span>
41
42</code></pre>

<p>15 ） 匹配至少 2 个字符</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 13 |grep -E &#x27;[0-9]&#123;2&#125;&#x27;</span>
10
11
12
13</code></pre>

<p>16 ） 匹配至少 2 个字符的单词，最多 3 个字符的单词</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a ab abc abcd abcde&quot; |xargs -n1 |grep -E -w -o &#x27;[a-z]&#123;2,3&#125;&#x27;</span>
ab
abc</code></pre>

<p>17 ） 匹配所有 IP</p>
<pre><code class="hljs bash"><span class="hljs-comment"># ifconfig |grep -E -o &quot;[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;&quot;</span></code></pre>

<p>18 ） 打印匹配结果及后 3 行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 1 10 |grep 5 -A 3</span>
5
6
7
8</code></pre>

<p>19 ） 打印匹配结果及前 3 行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 1 10 |grep 5 -B 3</span>
2
3
4
5</code></pre>

<p>20 ） 打印匹配结果及前后 3 行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 1 10 |grep 5 -C 3</span>
2 3 4 5 6 7 8</code></pre>

<p>21 ） 不显示输出</p>
<pre><code class="hljs bash">不显示错误输出：
<span class="hljs-comment"># grep &#x27;a&#x27; abc</span>
grep: abc: No such file or directory
<span class="hljs-comment"># grep -s &#x27;a&#x27; abc</span>
<span class="hljs-comment"># echo $?</span>
2
不显示正常输出：
<span class="hljs-comment"># grep -q &#x27;a&#x27; a.txt</span></code></pre>

<p>grep 支持上一章的基础和扩展正则表达式字符。</p>
<h2 id="7-2-sed"><a href="#7-2-sed" class="headerlink" title="7.2 sed"></a>7.2 sed</h2><p>流编辑器，过滤和替换文本。</p>
<p><strong>工作原理</strong>：sed 命令将当前处理的行读入模式空间进行处理，处理完把结果输出，并清空模式空间。然后再将下一行读入模式空间进行处理输出，以此类推，直到最后一行。还有一个空间叫保持空间，又称暂存空间，可以暂时存放一些处理的数据，但不能直接输出，只能放到模式空间输出。这两个空间其实就是在内存中初始化的一个内存区域，存放正在处理的数据和临时存放的数据。</p>
<p><strong>Usage:</strong></p>
<p>sed [OPTION]… {script-only-if-no-other-script} [input-file]…</p>
<p>sed [选项] ‘地址 命令’ file</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>不打印模式空间</td>
</tr>
<tr>
<td>-e</td>
<td>执行脚本、表达式来处理</td>
</tr>
<tr>
<td>-f</td>
<td>执行动作从文件读取执行</td>
</tr>
<tr>
<td>-i</td>
<td>修改原文件</td>
</tr>
<tr>
<td>-r</td>
<td>使用扩展正则表达式</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s/regexp/replacement/</td>
<td>替换字符串</td>
</tr>
<tr>
<td>p</td>
<td>打印当前模式空间</td>
</tr>
<tr>
<td>P</td>
<td>打印模式空间的第一行</td>
</tr>
<tr>
<td>d</td>
<td>删除模式空间，开始下一个循环</td>
</tr>
<tr>
<td>D</td>
<td>删除模式空间的第一行，开始下一个循环</td>
</tr>
<tr>
<td>=</td>
<td>打印当前行号</td>
</tr>
<tr>
<td>a \text</td>
<td>当前行追加文本</td>
</tr>
<tr>
<td>i \text</td>
<td>当前行上面插入文本</td>
</tr>
<tr>
<td>c \text</td>
<td>所选行替换新文本</td>
</tr>
<tr>
<td>q</td>
<td>立即退出 sed 脚本</td>
</tr>
<tr>
<td>r</td>
<td>追加文本来自文件</td>
</tr>
<tr>
<td>: label</td>
<td>label 为 b 和 t 命令</td>
</tr>
<tr>
<td>b label</td>
<td>分支到脚本中带有标签的位置，如果分支不存在则分支到脚本的末尾</td>
</tr>
<tr>
<td>t label</td>
<td>如果 s/// 是一个成功的替换，才跳转到标签</td>
</tr>
<tr>
<td>h H</td>
<td>复制 / 追加模式空间到保持空间</td>
</tr>
<tr>
<td>g G</td>
<td>复制 / 追加保持空间到模式空间</td>
</tr>
<tr>
<td>x</td>
<td>交换模式空间和保持空间内容</td>
</tr>
<tr>
<td>l</td>
<td>打印模式空间的行，并显示控制字符 $</td>
</tr>
<tr>
<td>n N</td>
<td>读取 / 追加下一行输入到模式空间</td>
</tr>
<tr>
<td>w</td>
<td>filename 写入当前模式空间到文件</td>
</tr>
<tr>
<td>!</td>
<td>取反、否定</td>
</tr>
<tr>
<td>&amp;</td>
<td>引用已匹配字符串</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>first~step</td>
<td>步长，每 step 行，从第 first 开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配最后一行</td>
</tr>
<tr>
<td>/regexp/</td>
<td>正则表达式匹配行</td>
</tr>
<tr>
<td>number</td>
<td>只匹配指定行</td>
</tr>
<tr>
<td>addr1,addr2</td>
<td>开始匹配 addr1 行开始，直接 addr2 行结束</td>
</tr>
<tr>
<td>addr1,+N</td>
<td>从 addr1 行开始，向后的 N 行</td>
</tr>
<tr>
<td>addr1,~N</td>
<td>从 addr1 行开始，到 N 行结束</td>
</tr>
</tbody></table>
<p>借助以下文本内容作为示例讲解：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services</span>
nimgtw        48003/udp   <span class="hljs-comment"># Nimbus Gateway</span>
3gpp-cbsp     48049/tcp   <span class="hljs-comment"># 3GPP Cell Broadcast Service Protocol</span>
isnetserv     48128/tcp   <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv     48128/udp   <span class="hljs-comment"># Image Systems Network Services</span>
blp5          48129/tcp   <span class="hljs-comment"># Bloomberg locator</span>
blp5          48129/udp   <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp   <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp   <span class="hljs-comment"># com-bardac-dw</span>
iqobject      48619/tcp   <span class="hljs-comment"># iqobject</span>
iqobject      48619/udp   <span class="hljs-comment"># iqobject</span></code></pre>

<h3 id="7-2-1-匹配打印（p）"><a href="#7-2-1-匹配打印（p）" class="headerlink" title="7.2.1 匹配打印（p）"></a>7.2.1 匹配打印（p）</h3><p>1 ）打印匹配 blp5 开头的行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;/^blp5/p&#x27;</span>
blp5     48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>
blp5     48129/udp     <span class="hljs-comment"># Bloomberg locator</span></code></pre>

<p>2 ）打印第一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;1p&#x27;</span>
nimgtw     48003/udp     <span class="hljs-comment"># Nimbus Gateway</span></code></pre>

<p>3 ）打印第一行至第三行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;1,3p&#x27;</span>
nimgtw         48003/udp     <span class="hljs-comment"># Nimbus Gateway</span>
3gpp-cbsp      48049/tcp     <span class="hljs-comment"># 3GPP Cell Broadcast Service Protocol</span>
isnetserv      48128/tcp     <span class="hljs-comment"># Image Systems Network Services</span></code></pre>

<p>4 ）打印奇数行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 10 |sed -n &#x27;1~2p&#x27;</span>
1
3
5
7
9</code></pre>

<p>5 ）打印匹配行及后一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;/blp5/,+1p&#x27;</span>
blp5      48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>
blp5      48129/udp     <span class="hljs-comment"># Bloomberg locator</span></code></pre>

<p>6 ）打印最后一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;$p&#x27;</span>
iqobject       48619/udp      <span class="hljs-comment"># iqobject</span></code></pre>

<p>7 ）不打印最后一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;$!p&#x27;</span>
3gpp-cbsp      48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
Protocol
isnetserv      48128/tcp     <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv      48128/udp     <span class="hljs-comment"># Image Systems Network Services</span>
blp5           48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>
blp5           48129/udp     <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw  48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw  48556/udp     <span class="hljs-comment"># com-bardac-dw</span>
iqobject       48619/tcp     <span class="hljs-comment"># iqobject</span>
iqobject       48619/udp     <span class="hljs-comment"># iqobject</span></code></pre>

<p>感叹号也就是对后面的命令取反。</p>
<p>8 ）匹配范围</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;/^blp5/,/^com/p&#x27;</span>
blp5            48129/tcp       <span class="hljs-comment"># Bloomberg locator</span>
blp5            48129/udp       <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw   48556/tcp       <span class="hljs-comment"># com-bardac-dw</span></code></pre>

<p>匹配开头行到最后一行：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;/blp5/,$p&#x27;</span>
blp5          48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>
blp5          48129/udp     <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp     <span class="hljs-comment"># com-bardac-dw</span>
iqobject      48619/tcp     <span class="hljs-comment"># iqobject</span>
iqobject      48619/udp     <span class="hljs-comment"># iqobject</span></code></pre>

<p>以逗号分开两个样式选择某个范围。</p>
<p>9 ）引用系统变量，用引号</p>
<pre><code class="hljs bash"><span class="hljs-comment"># a=1</span>
<span class="hljs-comment"># tail /etc/services |sed -n &#x27;&#x27;$a&#x27;,3p&#x27;</span>
或
<span class="hljs-comment"># tail /etc/services |sed -n &quot;$a,3p&quot;</span></code></pre>

<p>sed 命令用单引号时，里面变量用单引号引起来，或者 sed 命令用双引号，因为双引号解释特殊符号原有意义。</p>
<h3 id="7-2-2-匹配删除（d）"><a href="#7-2-2-匹配删除（d）" class="headerlink" title="7.2.2 匹配删除（d）"></a>7.2.2 匹配删除（d）</h3><p>删除与打印使用方法类似，简单举几个例子。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/d&#x27;</span>
nimgtw            48003/udp    <span class="hljs-comment"># Nimbus Gateway</span>
3gpp-cbsp         48049/tcp    <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv         48128/tcp    <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv         48128/udp    <span class="hljs-comment"># Image Systems Network Services</span>
com-bardac-dw     48556/tcp    <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw     48556/udp    <span class="hljs-comment"># com-bardac-dw</span>
iqobject          48619/tcp    <span class="hljs-comment"># iqobject</span>
iqobject          48619/udp    <span class="hljs-comment"># iqobject</span>
<span class="hljs-comment"># tail /etc/services |sed &#x27;1d&#x27;</span>
3gpp-cbsp        48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
Protocol
isnetserv        48128/tcp     <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv        48128/udp     <span class="hljs-comment"># Image Systems Network Services</span>
blp5             48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>
blp5             48129/udp     <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw    48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw    48556/udp     <span class="hljs-comment"># com-bardac-dw</span>
iqobject         48619/tcp     <span class="hljs-comment"># iqobject</span>
iqobject         48619/udp     <span class="hljs-comment"># iqobject</span>
<span class="hljs-comment"># tail /etc/services |sed &#x27;1~2d&#x27;</span>
3gpp-cbsp         48049/tcp     <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv         48128/udp     <span class="hljs-comment"># Image Systems Network Services</span>
blp5              48129/udp     <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw     48556/udp     <span class="hljs-comment"># com-bardac-dw</span>
iqobject          48619/udp     <span class="hljs-comment"># iqobject</span>
<span class="hljs-comment"># tail /etc/services |sed &#x27;1,3d&#x27;</span>
isnetserv         48128/udp     <span class="hljs-comment"># Image Systems Network Services</span>
blp5              48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>
blp5              48129/udp     <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw     48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw     48556/udp     <span class="hljs-comment"># com-bardac-dw</span>
iqobject          48619/tcp     <span class="hljs-comment"># iqobject</span>
iqobject          48619/udp     <span class="hljs-comment"># iqobject</span></code></pre>

<p>去除空格 http.conf 文件空行或开头 # 号的行：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># sed &#x27;/^#/d;/^$/d&#x27; /etc/httpd/conf/httpd.conf</span></code></pre>

<p>打印是把匹配的打印出来，删除是把匹配的删除，删除只是不用 -n 选项。</p>
<h3 id="7-2-3-替换（s-）"><a href="#7-2-3-替换（s-）" class="headerlink" title="7.2.3 替换（s///）"></a>7.2.3 替换（s///）</h3><p>1 ）替换 blp5 字符串为 test</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;s/blp5/test/&#x27;</span>
3gpp-cbsp          48049/tcp     <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv          48128/tcp     <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv          48128/udp     <span class="hljs-comment"># Image Systems Network Services</span>
<span class="hljs-built_in">test</span>               48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>
<span class="hljs-built_in">test</span>               48129/udp     <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw      48556/tcp     <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw      48556/udp     <span class="hljs-comment"># com-bardac-dw</span>
iqobject           48619/tcp     <span class="hljs-comment"># iqobject</span>
iqobject           48619/udp     <span class="hljs-comment"># iqobject</span>
matahari           49000/tcp     <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>全局替换加 g：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;s/blp5/test/g&#x27;</span></code></pre>

<p>2 ）替换开头是 blp5 的字符串并打印</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -n &#x27;s/^blp5/test/p&#x27;</span>
<span class="hljs-built_in">test</span>          481 29/tcp      <span class="hljs-comment"># Bloomberg locator</span>
<span class="hljs-built_in">test</span>          48129/udp       <span class="hljs-comment"># Bloomberg locator</span></code></pre>

<p>3 ）使用 &amp; 命令引用匹配内容并替换</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;s/48049/&amp;.0/&#x27;</span>
3gpp-cbsp             48049.0/tcp     <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv             48128/tcp       <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv             48128/udp       <span class="hljs-comment"># Image Systems Network Services</span>
blp5                  48129/tcp       <span class="hljs-comment"># Bloomberg locator</span>
blp5                  48129/udp       <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw         48556/tcp       <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw         48556/udp       <span class="hljs-comment"># com-bardac-dw</span>
iqobject              48619/tcp       <span class="hljs-comment"># iqobject</span>
iqobject              48619/udp       <span class="hljs-comment"># iqobject</span>
matahari              49000/tcp       <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>IP 加单引号：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &#x27;10.10.10.1 10.10.10.2 10.10.10.3&#x27; |sed -r &#x27;s/[^]+/&quot;&amp;&quot;/g&#x27;</span>
<span class="hljs-string">&quot;10.10.10.1&quot;</span> <span class="hljs-string">&quot;10.10.10.2&quot;</span> <span class="hljs-string">&quot;10.10.10.3&quot;</span></code></pre>

<p>4 ）对 1 - 4 行的 blp5 进行替换</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services | sed &#x27;1,4s/blp5/test/&#x27;</span>
3gpp-cbsp           48049/tcp       <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv           48128/tcp       <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv           48128/udp       <span class="hljs-comment"># Image Systems Network Services</span>
<span class="hljs-built_in">test</span>                48129/tcp       <span class="hljs-comment"># Bloomberg locator</span>
blp5                48129/udp       <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw       48556/tcp       <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw       48556/udp       <span class="hljs-comment"># com-bardac-dw</span>
iqobject            48619/tcp       <span class="hljs-comment"># iqobject</span>
iqobject            48619/udp       <span class="hljs-comment"># iqobject</span>
matahari            49000/tcp       <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>5 ）对匹配行进行替换</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services | sed &#x27;/48129\/tcp/s/blp5/test/&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128 /tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
<span class="hljs-built_in">test</span> 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>6 ）二次匹配替换</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;s/blp5/test/;s/3g/4g/&#x27;</span>
4gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
<span class="hljs-built_in">test</span> 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
<span class="hljs-built_in">test</span> 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>7 ）分组使用，在每个字符串后面添加 123</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -r &#x27;s/(.*) (.*)(#.*)/\ 1 \2test \3/&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-built_in">test</span> <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-built_in">test</span> <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-built_in">test</span> <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>第一列是第一个小括号匹配，第二列第二个小括号匹配，第三列一样。将不变的字符串匹配分组，再通过 \ 数字按分组顺序反向引用。</p>
<p>8 ）将协议与端口号位置调换</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -r &#x27;s/(.*)(\&lt;[0-9]+\&gt;)\/(tcp|udp)(.*)/\ 1 \ 3 \/\ 2 \4/&#x27;</span>
3gpp-cbsp tcp/48049 <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv tcp/48128 <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv udp/48128 <span class="hljs-comment"># Image Systems Network Services</span>
blp5 tcp/48129 <span class="hljs-comment"># Bloomberg locator</span>
blp5 udp/48129 <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw tcp/48556 <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw udp/48556 <span class="hljs-comment"># com-bardac-dw</span>
iqobject tcp/48619 <span class="hljs-comment"># iqobject</span>
iqobject udp/48619 <span class="hljs-comment"># iqobject</span>
matahari tcp/49000 <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>9 ）位置调换</p>
<pre><code class="hljs bash">替换 x 字符为大写：
<span class="hljs-comment"># echo &quot;abc cde xyz&quot; |sed -r &#x27;s/(.*)x/\1X/&#x27;</span>
abc cde Xyz
456 与 cde 调换：
<span class="hljs-comment"># echo &quot;abc:cde;123:456&quot; |sed -r &#x27;s/([^:]+)(;.*:)([^:]+$)/\ 3 \ 2 \1/&#x27;</span>
abc:456;123:cde</code></pre>

<p>10 ）注释匹配行后的多少行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 10 |sed &#x27;/5/,+3s/^/#/&#x27;</span>
1
2
3
4
<span class="hljs-comment">#5</span>
<span class="hljs-comment">#6</span>
<span class="hljs-comment">#7</span>
<span class="hljs-comment">#8</span>
9
10</code></pre>

<p>11 ）注释指定多行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -r &#x27;s/^3|^4/&amp;#/&#x27;</span>
1
2
3<span class="hljs-comment">#</span>
4<span class="hljs-comment">#</span>
5
<span class="hljs-comment"># seq 5 |sed -r &#x27;/^3|^4/s/^/#/&#x27;</span>
1
2
<span class="hljs-comment">#3</span>
<span class="hljs-comment">#4</span>
5
<span class="hljs-comment"># seq 5 |sed -r &#x27;s/^3|^4/#\0/&#x27;</span>
1
2
<span class="hljs-comment">#3</span>
<span class="hljs-comment">#4</span>
5</code></pre>

<p>12 ）去除开头和结尾空格或制表符</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;1 2 3&quot; |sed &#x27;s/^[\t]*//;s/[ \t]*$//&#x27;</span>
1 2 3</code></pre>

<h3 id="7-2-4-多重编辑（-e）"><a href="#7-2-4-多重编辑（-e）" class="headerlink" title="7.2.4 多重编辑（-e）"></a>7.2.4 多重编辑（-e）</h3><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed -e &#x27;1,2d&#x27; -e &#x27;s/blp5/test/&#x27;</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
<span class="hljs-built_in">test</span> 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
<span class="hljs-built_in">test</span> 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>也可以使用分号分隔：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;1,2d;s/blp5/test/&#x27;</span></code></pre>

<h3 id="7-2-5-添加新内容（a、i-和-c）"><a href="#7-2-5-添加新内容（a、i-和-c）" class="headerlink" title="7.2.5 添加新内容（a、i 和 c）"></a>7.2.5 添加新内容（a、i 和 c）</h3><p>1 ）在 blp5 上一行添加 test</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/i \test&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
<span class="hljs-built_in">test</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
<span class="hljs-built_in">test</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>2 ）在 blp5 下一行添加 test</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/a \test&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
<span class="hljs-built_in">test</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
<span class="hljs-built_in">test</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>3 ）将 blp5 替换新行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/c \test&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
<span class="hljs-built_in">test</span>
<span class="hljs-built_in">test</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>4 ）在指定行下一行添加一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;2a \test&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
<span class="hljs-built_in">test</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>5 ）在指定行前面和后面添加一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed &#x27;3s/.*/txt\n&amp;/&#x27;</span>
1
2
txt
3
4
5
<span class="hljs-comment"># seq 5 |sed &#x27;3s/.*/&amp;\ntxt/&#x27;</span>
1
2
3
txt
4
5</code></pre>

<h3 id="7-2-6-读取文件并追加到匹配行后（r）"><a href="#7-2-6-读取文件并追加到匹配行后（r）" class="headerlink" title="7.2.6 读取文件并追加到匹配行后（r）"></a>7.2.6 读取文件并追加到匹配行后（r）</h3><pre><code class="hljs bash"><span class="hljs-comment"># cat a.txt</span>
123
456
<span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/r a.txt&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
123
456
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
123
456
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<h3 id="7-2-7-将匹配行写到文件（w）"><a href="#7-2-7-将匹配行写到文件（w）" class="headerlink" title="7.2.7 将匹配行写到文件（w）"></a>7.2.7 将匹配行写到文件（w）</h3><pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |sed &#x27;/blp5/w b.txt&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 4855 6/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span>
<span class="hljs-comment"># cat b.txt</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span></code></pre>

<h3 id="7-2-8-读取下一行（n-和-N）"><a href="#7-2-8-读取下一行（n-和-N）" class="headerlink" title="7.2.8 读取下一行（n 和 N）"></a>7.2.8 读取下一行（n 和 N）</h3><ul>
<li>n 读取下一行到模式空间。</li>
<li>N 追加下一行内容到模式空间，并以换行符 \ n 分隔。</li>
</ul>
<p><strong>1 ）</strong> 打印匹配的下一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;/3/&#123;n;p&#125;&#x27;</span>
4</code></pre>

<p><strong>2 ）</strong> 打印偶数</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -n &#x27;n;p&#x27;</span>
2
4
6</code></pre>

<p>sed 先读取第一行 1 ，执行 n 命令，获取下一行 2 ，此时模式空间是 2 ，执行 p 命令，打印模式空间。 现在模式空间是 2 ，sed 再读取 3 ，执行 n 命令，获取下一行 4 ，此时模式空间为 4 ，执行 p 命令，以此类推。</p>
<p><strong>3 ）</strong> 打印奇数</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;n;d&#x27;</span>
1
3
5</code></pre>

<p>sed 先读取第一行 1 ，此时模式空间是 1 ，并打印模式空间 1 ，执行 n 命令，获取下一行 2 ，执行 d 命令，删除模式空间的 2 ，sed 再读取 3 ，此时模式空间是 3 ，并打印模式空间，再执行 n 命令，获取下一行 4 ，执行 d 命令，删除模式空间的 3 ，以此类推。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -n &#x27;p;n&#x27;</span>
1
3
5</code></pre>

<p><strong>4 ）</strong> 每三行执行一次 p 命令</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;n;n;p&#x27;</span>
1
2
3
3
4
5
6
6</code></pre>

<p>sed 先读取第一行 1 ，并打印模式空间 1 ，执行 n 命令，获取下一行 2 ，并打印模式空间 2 ，再执行 n 命令，获取下一行 3 ，执行 p 命令，打印模式空间 3 。sed 读取下一行 3 ，并打印模式空间 3, 以此类推。</p>
<p><strong>5 ）</strong> 每三行替换一次</p>
<p>方法 1 ：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;n;n;s/^/=/;s/$/=/&#x27;</span>
1
2
=3=
4
5
=6=</code></pre>

<p>我们只是把 p 命令改成了替换命令。</p>
<p>方法 2 ：</p>
<p>这次用到了地址匹配，来实现上面的效果：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;3~3&#123;s/^/=/;s/$/=/&#125;&#x27;</span>
1
2
=3=
4
5
=6=</code></pre>

<p>当执行多个 sed 命令时，有时相互会产生影响，我们可以用大括号 {} 把他们括起来。</p>
<p><strong>6 ）</strong> 再看下 N 命令的功能</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;N;q&#x27;</span>
1
2
将两行合并一行：
<span class="hljs-comment"># seq 6 |sed &#x27;N;s/\n//&#x27;</span>
12
34
56</code></pre>

<p>第一个命令：sed 读取第一行 1 ，N 命令读取下一行 2 ，并以 \ n2 追加，此时模式空间是 1 \n2，再执行 q 退出。</p>
<p>为了进一步说明 N 的功能，看第二个命令：执行 N 命令后，此时模式空间是 1 \n2，再执行把 \ n 替换为空，此时模式空间是 12 ，并打印。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;N;p&#x27;</span>
1
2
3
4
<span class="hljs-comment"># seq 6 |sed -n &#x27;N;p&#x27;</span>
1
2
3
4
5
6</code></pre>

<p>为什么第一个不打印 5 呢？</p>
<p>因为 N 命令是读取下一行追加到 sed 读取的当前行，当 N 读取下一行没有内容时，则退出，也不会执行 p 命令打印当前行。<br>当行数为偶数时，N 始终就能读到下一行，所以也会执行 p 命令。</p>
<p><strong>7 ）</strong> 打印奇数行数时的最后一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;$!N;p&#x27;</span>
1
2
3
4
5</code></pre>

<p>加一个满足条件，当 sed 执行到最后一行时，用感叹号不去执行 N 命令，随后执行 p 命令。</p>
<h3 id="7-2-9-打印和删除模式空间第一行（P-和-D）"><a href="#7-2-9-打印和删除模式空间第一行（P-和-D）" class="headerlink" title="7.2.9 打印和删除模式空间第一行（P 和 D）"></a>7.2.9 打印和删除模式空间第一行（P 和 D）</h3><ul>
<li><p>P 打印模式空间的第一行。</p>
</li>
<li><p>D 删除模式空间的第一行。</p>
</li>
</ul>
<p><strong>1 ）</strong> 打印奇数</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -n &#x27;N;P&#x27;</span>
1
3
5</code></pre>

<p><strong>2 ）</strong> 保留最后一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;N;D&#x27;</span>
6</code></pre>

<p>读取第一行 1 ，执行 N 命令读取下一行并追加到模式空间，此时模式空间是 1 \n2，执行 D 命令删除模式空间第一行 1 ，剩余 2 。<br>读取第二行，执行 N 命令，此时模式空间是 3 \n4，执行 D 命令删除模式空间第一行 3 ，剩余 4 。<br>以此类推，读取最后一行打印时，而 N 获取不到下一行则退出，不再执行 D，因此模式空间只剩余 6 就打印。</p>
<h3 id="7-2-10-保持空间操作（h-与-H、g-与-G-和-x）"><a href="#7-2-10-保持空间操作（h-与-H、g-与-G-和-x）" class="headerlink" title="7.2.10 保持空间操作（h 与 H、g 与 G 和 x）"></a>7.2.10 保持空间操作（h 与 H、g 与 G 和 x）</h3><ul>
<li>h 复制模式空间内容到保持空间（覆盖）。</li>
<li>H 复制模式空间内容追加到保持空间。</li>
<li>g 复制保持空间内容到模式空间（覆盖）。</li>
<li>G 复制保持空间内容追加到模式空间。</li>
<li>x 模式空间与保持空间内容互换</li>
</ul>
<p><strong>1 ）</strong> 将匹配的内容覆盖到另一个匹配</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -e &#x27;/3/&#123;h;d&#125;&#x27; -e &#x27;/5/g&#x27;</span>
1
2
4
3
6</code></pre>

<p>h 命令把匹配的 3 复制到保持空间，d 命令删除模式空间的 3 。后面命令再对模式空间匹配 5 ，并用 g 命令把保持空间 3 覆盖模式空间 5 。</p>
<p><strong>2 ）</strong> 将匹配的内容放到最后</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -e &#x27;/3/&#123;h;d&#125;&#x27; -e &#x27;$G&#x27;</span>
1
2
4
5
6
3</code></pre>
<p><strong>3 ）</strong> 交换模式空间和保持空间</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed -e &#x27;/3/&#123;h;d&#125;&#x27; -e &#x27;/5/x&#x27; -e &#x27;$G&#x27;</span>
1
2
4
3
6
5</code></pre>

<p>看后面命令，在模式空间匹配 5 并将保持空间的 3 与 5 交换， 5 就变成了 3,。最后把保持空间的 5 追加到模式空间的。</p>
<p><strong>4 ）</strong> 倒叙输出</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed &#x27;1!G;h;$!d&#x27;</span>
5
4
3
2
1</code></pre>

<p>分析下：</p>
<p>1!G 第一行不执行把保持空间内容追加到模式空间，因为现在保持空间还没有数据。</p>
<p>h 将模式空间放到保持空间暂存。</p>
<p>$!d 最后一行不执行删除模式空间的内容。</p>
<p>读取第一行 1 时，跳过 G 命令，执行 h 命令将模式空间 1 复制到保持空间，执行 d 命令删除模式空间的 1 。</p>
<p>读取第二行 2 时，模式空间是 2 ，执行 G 命令，将保持空间 1 追加到模式空间，此时模式空间是 2 \n1，执行 h 命令将 2 \n1 覆盖到保持空间，d 删除模式空间。</p>
<p>读取第三行 3 时，模式空间是 3 ，执行 G 命令，将保持空间 2 \n1 追加到模式空间，此时模式空间是 3 \n2\n1，执行 h 命令将模式空间内容复制到保持空间，d 删除模式空间。</p>
<p>以此类推，读到第 5 行时，模式空间是 5 ，执行 G 命令，将保持空间的 4 \n3\n2\n1 追加模式空间，然后复制到模式空间， 5 \n4\n3\n2\n1，不执行 d，模式空间保留，输出。</p>
<p>由此可见，每次读取的行先放到模式空间，再复制到保持空间，d 命令删除模式空间内容，防止输出，再追加到模式空间，因为追加到模式空间，会追加到新读取的一行的后面，循环这样操作，就把所有行一行行追加到新读取行的后面，就形成了倒叙。</p>
<p><strong>5 ）</strong> 每行后面添加新空行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 10 |sed G</span>
1

2

3

4

5</code></pre>

<p><strong>6 ）</strong> 打印匹配行的上一行内容</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;/3/&#123;x;p&#125;;h&#x27;</span>
2</code></pre>

<p>读取第一行 1 ，没有匹配到 3 ，不执行 {x;p}，执行 h 命令将模式空间内容 1 覆盖到保持空间。<br>读取第二行 2 ，没有匹配到 3 ，不执行 {x;p}，执行 h 命令将模式空间内容 2 覆盖到保持空间。<br>读取第三行 3 ，匹配到 3 ，执行 x 命令把模式空间 3 与保持空间 2 交换，再执行 p 打印模式空间 2.<br>以此类推。</p>
<p>7 ）打印匹配行到最后一行或下一行到最后一行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |sed -n &#x27;/3/,$p&#x27;</span>
3
4
5
<span class="hljs-comment"># seq 5 |sed -n &#x27;/3/,$&#123;h;x;p&#125;&#x27;</span>
3
4
5
<span class="hljs-comment"># seq 5 |sed -n &#x27;/3/&#123;:a;N;$!ba;p&#125;&#x27;</span>
3
4
5
<span class="hljs-comment"># seq 5 |sed -n &#x27;/3/&#123;n;:a;N;$!ba;p&#125;&#x27;</span>
4
5</code></pre>

<p>匹配到 3 时，n 读取下一行 4 ，此时模式空间是 4 ，执行 N 命令读取下一行并追加到模式空间，此时模式空间是 4 \n5，标签循环完成后打印模式空间 4 \n5。</p>
<h3 id="7-2-11-标签（-、b-和-t）"><a href="#7-2-11-标签（-、b-和-t）" class="headerlink" title="7.2.11 标签（:、b 和 t）"></a>7.2.11 标签（:、b 和 t）</h3><p>标签可以控制流，实现分支判断。</p>
<ul>
<li>: lable name 定义标签</li>
<li>b lable 跳转到指定标签，如果没有标签则到脚本末尾</li>
<li>t lable 跳转到指定标签，前提是 s/// 命令执行成功</li>
</ul>
<p><strong>1 ）</strong> 将换行符替换成逗号</p>
<p>方法 1 ：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;N;s/\n/,/&#x27;</span>
1,2
3,4
5,6</code></pre>

<p>这种方式并不能满足我们的需求，每次 sed 读取到模式空间再打印是新行，替换 \ n 也只能对 N 命令追加后的 1 \n2 这样替换。</p>
<p>这时就可以用到标签了：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;:a;N;s/\n/,/;b a&#x27;</span>
1,2,3,4,5,6</code></pre>

<p>看看这里的标签使用，:a 是定义的标签名，b a 是跳转到 a 位置。<br>sed 读取第一行 1 ，N 命令读取下一行 2 ，此时模式空间是 1 \n2$，执行替换，此时模式空间是 1,2$，执行 b 命令再跳转到标签 a 位置继续执行 N 命令，读取下一行 3 追加到模式空间，此时模式空间是 1,2\n3$，再替换，以此类推，不断追加替换，直到最后一行 N 读不到下一行内容退出。</p>
<p>方法 2 ：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;:a;N;$!b a;s/\n/,/g&#x27;</span>
1,2,3,4,5,6</code></pre>

<p>先将每行读入到模式空间，最后再执行全局替换。$! 是如果是最后一行，则不执行 b a 跳转，最后执行全局替换。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 6 |sed &#x27;:a;N;b a;s/\n/,/g&#x27;</span>
1
2
3
4
5
6</code></pre>

<p>可以看到，不加 $! 是没有替换，因为循环到 N 命令没有读到行就退出了，后面的替换也就没执行。</p>
<p><strong>2 ）</strong> 每三个数字加个一个逗号</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;123456789&quot; |sed -r &#x27;s/([0-9]+)([0-9]+&#123;3&#125;)/\1,\2/&#x27;</span>
123456,789
<span class="hljs-comment"># echo &quot;123456789&quot; |sed -r &#x27;:a;s/([0-9]+)([0-9]+&#123;3&#125;)/\1,\2/;t a&#x27;</span>
123,456,789
<span class="hljs-comment"># echo &quot;123456789&quot; |sed -r &#x27;:a;s/([0-9]+)([0-9]+&#123;2&#125;)/\1,\2/;t a&#x27;</span>
1,23,45,67,89</code></pre>

<p>执行第一次时，替换最后一个，跳转后，再对 123456 匹配替换，直到匹配替换不成功，不执行 t 命令。</p>
<h3 id="7-2-12-忽略大小写匹配（I）"><a href="#7-2-12-忽略大小写匹配（I）" class="headerlink" title="7.2.12 忽略大小写匹配（I）"></a>7.2.12 忽略大小写匹配（I）</h3><pre><code class="hljs bash"><span class="hljs-comment"># echo -e &quot;a\nA\nb\nc&quot; |sed &#x27;s/a/1/Ig&#x27;</span>
1
1
b
c</code></pre>

<h3 id="7-2-13-获取总行数（-）"><a href="#7-2-13-获取总行数（-）" class="headerlink" title="7.2.13 获取总行数（#）"></a>7.2.13 获取总行数（#）</h3><pre><code class="hljs bash"><span class="hljs-comment"># seq 10 |sed -n &#x27;$=&#x27;</span></code></pre>

<h2 id="7-3-awk"><a href="#7-3-awk" class="headerlink" title="7.3 awk"></a>7.3 awk</h2><p>awk 是一个处理文本的编程语言工具，能用简短的程序处理标准输入或文件、数据排序、计算以及生成报表等等。</p>
<p>在 Linux 系统下默认 awk 是 gawk，它是 awk 的 GNU 版本。可以通过命令查看应用的版本：<code>ls -l/bin/awk</code></p>
<p>基本的命令语法：awk option ‘pattern {action}’ file</p>
<p>其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。</p>
<p>花括号用于根据特定的模式对一系列指令进行分组。</p>
<p>awk 处理的工作方式与数据库类似，支持对记录和字段处理，这也是 grep 和 sed 不能实现的。</p>
<p>在 awk 中，缺省的情况下将文本文件中的一行视为一个记录，逐行放到内存中处理，而将一行中的某一部分作为记录中的一个字段。用 1,2,3… 数字的方式顺序的表示行（记录）中的不同字段。用 $ 后跟数字，引用对应的字段，以逗号分隔， 0 表示整个行。</p>
<p><img src="/img/linux_shell/linux_shell_6.jpg" srcset="/img/loading.gif"></p>
<h3 id="7-3-1-选项"><a href="#7-3-1-选项" class="headerlink" title="7.3.1 选项"></a>7.3.1 选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>- f program-file</td>
<td>从文件中读取 awk 程序源文件</td>
</tr>
<tr>
<td>- F fs</td>
<td>指定 fs 为输入字段分隔符</td>
</tr>
<tr>
<td>- v var=value</td>
<td>变量赋值</td>
</tr>
<tr>
<td>- -posix</td>
<td>兼容 POSIX 正则表达式</td>
</tr>
<tr>
<td>- -dump-variables=[file]</td>
<td>把 awk 命令时的全局变量写入文件，<br > 默认文件是 awkvars.out</td>
</tr>
<tr>
<td>- -profile=[file]</td>
<td>格式化 awk 语句到文件，默认是 awkprof.out</td>
</tr>
</tbody></table>
<h3 id="7-3-2-模式"><a href="#7-3-2-模式" class="headerlink" title="7.3.2 模式"></a>7.3.2 模式</h3><p>常用模式有：</p>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>BEGIN{ }</td>
<td>给程序赋予初始状态，先执行的工作</td>
</tr>
<tr>
<td>END{ }</td>
<td>程序结束之后执行的一些扫尾工作</td>
</tr>
<tr>
<td>/regular expression/</td>
<td>为每个输入记录匹配正则表达式</td>
</tr>
<tr>
<td>pattern &amp;&amp; pattern</td>
<td>逻辑 and，满足两个模式</td>
</tr>
<tr>
<td>pattern || pattern</td>
<td>逻辑 or，满足其中一个模式</td>
</tr>
<tr>
<td>! pattern</td>
<td>逻辑 not，不满足模式</td>
</tr>
<tr>
<td>pattern1, pattern2</td>
<td>范围模式，匹配所有模式 1 的记录，直到匹配到模式 2</td>
</tr>
</tbody></table>
<p>而动作呢，就是下面所讲的 print、流程控制、I/O 语句等。</p>
<p><strong>示例：</strong></p>
<p><strong>1 ）</strong> 从文件读取 awk 程序处理文件</p>
<pre><code class="hljs bash"><span class="hljs-comment"># vi test.awk</span>
&#123;<span class="hljs-built_in">print</span> <span class="hljs-variable">$2</span>&#125;
<span class="hljs-comment"># tail -n3 /etc/services |awk -f test.awk</span>
48049/tcp
48128/tcp
49000/tcp</code></pre>

<p><strong>2 ）</strong> 指定分隔符，打印指定字段</p>
<pre><code class="hljs bash">打印第二字段，默认以空格分隔：
<span class="hljs-comment"># tail -n3 /etc/services |awk &#x27;&#123;print $2&#125;&#x27;</span>
48049/tcp
48128/tcp
48128/udp
指定冒号为分隔符打印第一字段：
<span class="hljs-comment"># awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; /etc/passwd</span>
root
bin
daemon
adm
lp
sync
......</code></pre>

<p>还可以指定多个分隔符，作为同一个分隔符处理：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/#]&#x27; &#x27;&#123;print $3&#125;&#x27;</span>
iqobject
iqobject
Matahari Broker
<span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/#]&#x27; &#x27;&#123;print $1&#125;&#x27;</span>
iqobject 48619
iqobject 48619
matahari 49000
<span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/#]&#x27; &#x27;&#123;print $2&#125;&#x27;</span>
tcp
udp
tcp
<span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/#]&#x27; &#x27;&#123;print $3&#125;&#x27;</span>
iqobject
iqobject
Matahari Broker
<span class="hljs-comment"># tail -n3 /etc/services |awk -F&#x27;[/]+&#x27; &#x27;&#123;print $2&#125;&#x27;</span>
48619
48619
49000</code></pre>

<p>[] 元字符的意思是符号其中任意一个字符，也就是说每遇到一个 / 或 #时就分隔一个字段，当用多个分隔符时，就能更方面处理字段了。</p>
<p><strong>3 ）</strong> 变量赋值</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk -v a=123 &#x27;BEGIN&#123;print a&#125;&#x27;</span>
123
系统变量作为 awk 变量的值：
<span class="hljs-comment"># a=123</span>
<span class="hljs-comment"># awk -v a=$a &#x27;BEGIN&#123;print a&#125;&#x27;</span>
123
或使用单引号
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print&#x27;$a&#x27;&#125;&#x27;</span>
123</code></pre>

<p><strong>4 ）</strong> 输出 awk 全局变量到文件</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk --dump-variables &#x27;&#123;print $0&#125;&#x27;</span>
1
2
3
4
5
<span class="hljs-comment"># cat awkvars.out</span>
ARGC: number (1)
ARGIND: number (0)
ARGV: array, 1 elements
BINMODE: number (0)
CONVFMT: string (<span class="hljs-string">&quot;%.6g&quot;</span>)
ERRNO: number (0)
FIELDWIDTHS: string (<span class="hljs-string">&quot;&quot;</span>)
FILENAME: string (<span class="hljs-string">&quot;-&quot;</span>)
FNR: number (5)
FS: string (<span class="hljs-string">&quot; &quot;</span>)
IGNORECASE: number (0)
LINT: number (0)
NF: number (1)
NR: number (5)
OFMT: string (<span class="hljs-string">&quot;%.6g&quot;</span>)
OFS: string (<span class="hljs-string">&quot; &quot;</span>)
ORS: string (<span class="hljs-string">&quot;\n&quot;</span>)
RLENGTH: number (0)
RS: string (<span class="hljs-string">&quot;\n&quot;</span>)
RSTART: number (0)
RT: string (<span class="hljs-string">&quot;\n&quot;</span>)
SUBSEP: string (<span class="hljs-string">&quot;\034&quot;</span>)
TEXTDOMAIN: string (<span class="hljs-string">&quot;messages&quot;</span>)</code></pre>

<p><strong>5 ）</strong>BEGIN 和 END</p>
<p>BEGIN 模式是在处理文件之前执行该操作，常用于修改内置变量、变量赋值和打印输出的页眉或标题。</p>
<p>例如：打印页眉</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;BEGIN&#123;print&quot;Service\t\tPort\t\t\tDescription\n===&quot;&#125;&#123;print$0&#125;&#x27;</span>
Service Port Description
===
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>END 模式是在程序处理完才会执行。</p>
<p>例如：打印页尾</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;print $0&#125;END&#123;print&quot;===\nEND......&quot;&#125;&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span>
===
END......</code></pre>

<p><strong>6 ）</strong> 格式化输出 awk 命令到文件</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk --profile &#x27;BEGIN&#123;print&quot;Service\t\tPort\t\t\tDescription\n===&quot;&#125;&#123;print $0&#125;END&#123;print&quot;===\nEND......&quot;&#125;&#x27;</span>
Service Port Description
===
nimgtw 48003/udp <span class="hljs-comment"># Nimbus Gateway</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service Protocol</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
===
END......
<span class="hljs-comment"># cat awkprof.out</span>
  <span class="hljs-comment"># gawk profile, created Sat Jan 7 19:45:22 2017</span>

  <span class="hljs-comment"># BEGIN block(s)</span>

  BEGIN &#123;
    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Service\t\tPort\t\t\tDescription\n===&quot;</span>
  &#125;

  <span class="hljs-comment"># Rule(s)</span>
  &#123;
    <span class="hljs-built_in">print</span> <span class="hljs-variable">$0</span>
  &#125;

  <span class="hljs-comment"># END block(s)</span>

  END &#123;
   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;===\nEND......&quot;</span>
  &#125;</code></pre>

<p><strong>7 ）</strong>/re / 正则匹配</p>
<pre><code class="hljs bash">匹配包含 tcp 的行：
<span class="hljs-comment"># tail /etc/services |awk &#x27;/tcp/&#123;print $0&#125;&#x27;</span>
3gpp-cbsp 48049/tcp      <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp      <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp           <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp  <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp       <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp       <span class="hljs-comment"># Matahari Broker</span>
匹配开头是 blp5 的行：
<span class="hljs-comment"># tail /etc/services |awk &#x27;/^blp5/&#123;print $0&#125;&#x27;</span>
blp5 48129/tcp     <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp     <span class="hljs-comment"># Bloomberg locator</span>
匹配第一个字段是 8 个字符的行：
<span class="hljs-comment"># tail /etc/services |awk &#x27;/^[a-z0-9]&#123;8&#125; /&#123;print $0&#125;&#x27;</span>
iqobject 48619/tcp   <span class="hljs-comment"># iqobject</span>
iqobject 48619/udp   <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp   <span class="hljs-comment"># Matahari Broker</span>
如果没有匹配到，请查看你的 awk 版本（awk --version）是不是 3 ，因为 4 才支持 &#123;&#125;</code></pre>

<p><strong>8 ）</strong> 逻辑 and、or 和 not</p>
<pre><code class="hljs bash">匹配记录中包含 blp5 和 tcp 的行：
<span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/ &amp;&amp; /tcp/&#123;print $0&#125;&#x27;</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
匹配记录中包含 blp5 或 tcp 的行：
<span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/ || /tcp/&#123;print $0&#125;&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span>
不匹配开头是 <span class="hljs-comment">#和空行：</span>
<span class="hljs-comment"># awk &#x27;! /^#/ &amp;&amp;! /^$/&#123;print $0&#125;&#x27; /etc/httpd/conf/httpd.conf</span>
或
<span class="hljs-comment"># awk &#x27;! /^#|^$/&#x27; /etc/httpd/conf/httpd.conf</span>
或
<span class="hljs-comment"># awk &#x27;/^[^#]|&quot;^$&quot;/&#x27; /etc/httpd/conf/httpd.conf</span></code></pre>

<p>9 ）匹配范围</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;/^blp5/,/^com/&#x27;</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span></code></pre>

<p>对匹配范围后记录再次处理，例如匹配关键字下一行到最后一行：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;/3/,/^$/&#123;printf /3/?&quot;&quot;:$0&quot;\n&quot;&#125;&#x27;</span>
4
5
另一种判断真假的方式实现：
<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;t=1;next&#125;t&#x27;</span>
4
5
1 和 2 都不匹配 3 ，不执行后面 &#123;&#125;，执行 t，t 变量还没赋值，为空，空在 awk 中就为假，就不打印当前行。匹配到 3 ，执行 t= 1 ，next 跳出，不执行 t。 4 也不匹配 3 ，执行 t，t 的值上次赋值的 1 ，为真，打印当前行，以此类推。（非 0 的数字都为真，所以 t 可以写任意非 0 数字）
如果想打印匹配行都最后一行，就可以这样了：
<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;t=1&#125;t&#x27;</span>
3
4
5</code></pre>

<h3 id="7-3-3-内置变量"><a href="#7-3-3-内置变量" class="headerlink" title="7.3.3 内置变量"></a>7.3.3 内置变量</h3><table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FS</td>
<td>输入字段分隔符，默认是空格或制表符</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符，默认是空格</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符，默认是换行符 \ n</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符，默认是换行符 \ n</td>
</tr>
<tr>
<td>NF</td>
<td>统计当前记录中字段个数</td>
</tr>
<tr>
<td>NR</td>
<td>统计记录编号，每处理一行记录，编号就会 + 1</td>
</tr>
<tr>
<td>FNR</td>
<td>统计记录编号，每处理一行记录，编号也会 + 1，与 NR 不同的是，处理第二个 <br> 文件时，编号会重新计数。</td>
</tr>
<tr>
<td>ARGC</td>
<td>命令行参数数量</td>
</tr>
<tr>
<td>ARGV</td>
<td>命令行参数数组序列数组，下标从 0 开始，ARGV[0] 是 awk</td>
</tr>
<tr>
<td>ARGIND</td>
<td>当前正在处理的文件索引值。第一个文件是 1 ，第二个文件是 2 ，以此类推</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>当前系统的环境变量</td>
</tr>
<tr>
<td>FILENAME</td>
<td>输出当前处理的文件名</td>
</tr>
<tr>
<td>IGNORECASE</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>SUBSEP</td>
<td>数组中下标的分隔符，默认为 “\034”</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<p><strong>1 ）</strong> FS 和 OFS</p>
<p>在程序开始前重新赋值 FS 变量，改变默认分隔符为冒号，与 - F 一样。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1,$2&#125;&#x27; /etc/passwd |head -n5</span>
root x
bin x
daemon x
adm x
lp x
也可以使用 - v 来重新赋值这个变量：
<span class="hljs-comment"># awk -vFS=&#x27;:&#x27; &#x27;&#123;print $1,$2&#125;&#x27; /etc/passwd |head -n5 # 中间逗号被换成了 OFS 的默</span>
认值
root x
bin x
daemon x
adm x
lp x
由于 OFS 默认以空格分隔，反向引用多个字段分隔的也是空格，如果想指定输出分隔符这样：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;FS=&quot;:&quot;;OFS=&quot;:&quot;&#125;&#123;print $1,$2&#125;&#x27; /etc/passwd |head -n5</span>
root:x
bin:x
daemon:x
adm:x
lp:x
也可以通过字符串拼接实现分隔：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1&quot;#&quot;$2&#125;&#x27; /etc/passwd |head -n5</span>
root<span class="hljs-comment">#x</span>
bin<span class="hljs-comment">#x</span>
daemon<span class="hljs-comment">#x</span>
adm<span class="hljs-comment">#x</span>
lp<span class="hljs-comment">#x</span></code></pre>

<p><strong>2 ）</strong> RS 和 ORS</p>
<p>RS 默认是 \n 分隔每行，如果想指定以某个字符作为分隔符来处理记录：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;www.baidu.com/user/test.html&quot; |awk &#x27;BEGIN&#123;RS=&quot;/&quot;&#125;&#123;print $0&#125;&#x27;</span>
www.baidu.com
user
test.html

RS 也支持正则，简单演示下：
<span class="hljs-comment"># seq -f &quot;str%02g&quot; 10 |sed &#x27;n;n;a\-----&#x27; |awk &#x27;BEGIN&#123;RS=&quot;-+&quot;&#125;&#123;print $1&#125;&#x27;</span>
str01
str04
str07
str10

将输出的换行符替换为 + 号：
<span class="hljs-comment"># seq 10 |awk &#x27;BEGIN&#123;ORS=&quot;+&quot;&#125;&#123;print $0&#125;&#x27;</span>
1+2+3+4+5+6+7+8+9+10+

替换某个字符：
<span class="hljs-comment"># tail -n2 /etc/services |awk &#x27;BEGIN&#123;RS=&quot;/&quot;;ORS=&quot;#&quot;&#125;&#123;print $0&#125;&#x27;</span>
iqobject 48619<span class="hljs-comment">#udp # iqobject</span>
matahari 49000<span class="hljs-comment">#tcp # Matahari Broker</span></code></pre>

<p><strong>3 ）</strong>NF</p>
<p>NF 是字段个数。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;print NF&#125;&#x27;</span>
6
打印最后一个字段：
<span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;print $NF&#125;&#x27;</span>
f
打印倒数第二个字段：
<span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;print $(NF-1)&#125;&#x27;</span>
e
排除最后两个字段：
<span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;$NF=&quot;&quot;;$(NF-1)=&quot;&quot;;print $0&#125;&#x27;</span>
a b c d
排除第一个字段：
<span class="hljs-comment"># echo &quot;a b c d e f&quot; |awk &#x27;&#123;$1=&quot;&quot;;print $0&#125;&#x27;</span>
b c d e f</code></pre>

<p><strong>4 ）</strong> NR 和 FNR</p>
<p>NR 统计记录编号，每处理一行记录，编号就会 +1，FNR 不同的是在统计第二个文件时会重新计数。</p>
<pre><code class="hljs bash">打印行数：
<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;&#123;print NR,$0&#125;&#x27;</span>
1 com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
2 com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
3 iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
4 iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
5 matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span>
打印总行数：
<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;END&#123;print NR&#125;&#x27;</span>
5
打印第三行：
<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;NR==3&#x27;</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
打印第三行第二个字段：
<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;NR==3&#123;print $2&#125;&#x27;</span>
48619/tcp
打印前三行：
<span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;NR&lt;=3&#123;print NR,$0&#125;&#x27;</span>
1 com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
2 com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
3 iqobject 48619/tcp <span class="hljs-comment"># iqobject</span></code></pre>

<p>看下 NR 和 FNR 的区别：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat a</span>
a
b
c
<span class="hljs-comment"># cat b</span>
c
d
e
<span class="hljs-comment"># awk &#x27;&#123;print NR,FNR,$0&#125;&#x27; a b</span>
1 1 a
2 2 b
3 3 c
4 1 c
5 2 d
6 3 e</code></pre>

<p>可以看出 NR 每处理一行就会 +1，而 FNR 在处理第二个文件时，编号重新计数。同时也知道 awk 处理两个文件时，是合并到一起处理。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;FNR==NR&#123;print $0&quot;1&quot;&#125;FNR!=NR&#123;print $0&quot;2&quot;&#125;&#x27; a b</span>
a1
b1
c1
c2
d2
e2</code></pre>

<p>当 FNR==NR 时，说明在处理第一个文件内容，不等于时说明在处理第二个文件内容。<br>一般 FNR 在处理多个文件时会用到，下面会讲解。</p>
<p><strong>5 ）</strong>ARGC 和 ARGV</p>
<p>ARGC 是命令行参数数量</p>
<p>ARGV 是将命令行参数存到数组，元素由 ARGC 指定，数组下标从 0 开始</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;print ARGC&#125;&#x27; 1 2 3</span>
4
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print ARGV[0]&#125;&#x27;</span>
awk
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print ARGV[1]&#125;&#x27; 1 2</span>
1
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print ARGV[2]&#125;&#x27; 1 2</span>
2</code></pre>

<p><strong>6 ）</strong>ARGIND</p>
<p>ARGIND 是当前正在处理的文件索引值，第一个文件是 1 ，第二个文件是 2 ，以此类推，从而可以通过这种方式判断正在处理哪个文件。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;&#123;print ARGIND,$0&#125;&#x27; a b</span>
1 a
1 b
1 c
2 c
2 d
2 e
<span class="hljs-comment"># awk &#x27;ARGIND==1&#123;print&quot;a-&gt;&quot;$0&#125;ARGIND==2&#123;print&quot;b-&gt;&quot;$0&#125;&#x27; a b</span>
a-&gt;a
a-&gt;b
a-&gt;c
b-&gt;c
b-&gt;d
b-&gt;e</code></pre>

<p><strong>7 ）</strong>ENVIRON</p>
<p>ENVIRON 调用系统变量。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;print ENVIRON[&quot;HOME&quot;]&#125;&#x27;</span>
/root
如果是设置的环境变量，还需要用 <span class="hljs-built_in">export</span> 导入到系统变量才可以调用：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print ENVIRON[&quot;a&quot;]&#125;&#x27;</span>

<span class="hljs-comment"># export a</span>
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print ENVIRON[&quot;a&quot;]&#125;&#x27;</span>
123</code></pre>

<p><strong>8 ）</strong>FILENAME</p>
<p>FILENAME 是当前处理文件的文件名。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;FNR==NR&#123;print FILENAME&quot;-&gt;&quot;$0&#125;FNR!=NR&#123;print FILENAME&quot;-&gt;&quot;$0&#125;&#x27; a b</span>
a-&gt;a
a-&gt;b
a-&gt;c
b-&gt;c
b-&gt;d
b-&gt;e</code></pre>

<p>9 ）忽略大小写</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;A a b c&quot; |xargs -n1 |awk &#x27;BEGIN&#123;IGNORECASE=1&#125;/a/&#x27;</span>
A
a</code></pre>

<p>等于 1 代表忽略大小写。</p>
<h3 id="7-3-4-操作符"><a href="#7-3-4-操作符" class="headerlink" title="7.3.4 操作符"></a>7.3.4 操作符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>（….）</td>
<td>分组</td>
</tr>
<tr>
<td>$</td>
<td>字段引用</td>
</tr>
<tr>
<td>++ –</td>
<td>递增和递减</td>
</tr>
<tr>
<td>+ -!</td>
<td>加号，减号，和逻辑否定</td>
</tr>
<tr>
<td>* / %</td>
<td>乘，除和取余</td>
</tr>
<tr>
<td>+ -</td>
<td>加法，减法</td>
</tr>
<tr>
<td>| |&amp;</td>
<td>管道，用于 getline，print 和 printf</td>
</tr>
<tr>
<td>&lt;&gt; &lt;=&gt;= != ==</td>
<td>关系运算符</td>
</tr>
<tr>
<td>~ !~</td>
<td>正则表达式匹配，否定正则表达式匹配</td>
</tr>
<tr>
<td>in</td>
<td>数组成员</td>
</tr>
<tr>
<td>&amp;&amp; ||</td>
<td>逻辑 and，逻辑 or</td>
</tr>
<tr>
<td>?:</td>
<td>简写条件表达式：<br>expr1? expr2 : expr3<br > 第一个表达式为真，执行 expr2，否则执行 expr3</td>
</tr>
<tr>
<td>= += -= *= /= %= ^=</td>
<td>变量赋值运算符</td>
</tr>
</tbody></table>
<p><strong>须知：</strong></p>
<p><font color=red> 在 awk 中，有 3 种情况表达式为假：数字是 0 ，空字符串和未定义的值。</font><br><font color=red> 数值运算，未定义变量初始值为 0 。字符运算，未定义变量初始值为空。</font></p>
<p><strong>举例测试：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;n=0;if(n)print&quot;true&quot;;else print&quot;false&quot;&#125;&#x27;</span>
<span class="hljs-literal">false</span>
<span class="hljs-comment"># awk &#x27;BEGIN&#123;s=&quot;&quot;;if(s)print &quot;true&quot;;else print &quot;false&quot;&#125;&#x27;</span>
<span class="hljs-literal">false</span>
<span class="hljs-comment"># awk &#x27;BEGIN&#123;if(s)print&quot;true&quot;;else print&quot;false&quot;&#125;&#x27;</span>
<span class="hljs-literal">false</span></code></pre>

<p><strong>示例：</strong></p>
<p><strong>1 ）</strong> 截取整数</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;123abc abc123 123abc123&quot; |xargs -n1 | awk &#x27;&#123;print +$0&#125;&#x27;</span>
123
0
123
<span class="hljs-comment"># echo &quot;123abc abc123 123abc123&quot; |xargs -n1 | awk &#x27;&#123;print -$0&#125;&#x27;</span>
-123
0
-123</code></pre>

<p><strong>2 ）</strong> 感叹号</p>
<pre><code class="hljs bash">打印奇数行：
<span class="hljs-comment"># seq 6 |awk &#x27;i=!i&#x27;</span>
1
3
5
打印偶数行：
<span class="hljs-comment"># seq 6 |awk &#x27;!(i=!i)&#x27;</span>
2
4
6</code></pre>

<p>读取第一行：i 是未定义变量，也就是 i=!0，! 取反意思。感叹号右边是个布尔值， 0 或空字符串为假，非 0 或非空字符串为真，!0 就是真，因此 i=1，条件为真打印当前记录。<br>没有 print 为什么会打印呢？因为模式后面没有动作，默认会打印整条记录。<br>读取第二行：因为上次 i 的值由 0 变成了 1 ，此时就是 i=!1，条件为假不打印。<br>读取第三行：上次条件又为假，i 恢复初始值 0 ，取反，继续打印。以此类推…<br>可以看出，运算时并没有判断行内容，而是利用布尔值真假判断输出当前行。</p>
<p><strong>3 ）</strong> 不匹配某行</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;!/blp5/&#123;print $0&#125;&#x27;</span>
3gpp-cbsp       48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv       48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
isnetserv       48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
com-bardac-dw   48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
com-bardac-dw   48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject        48619/tcp <span class="hljs-comment"># iqobject</span>
iqobject        48619/udp <span class="hljs-comment"># iqobject</span>
matahari        49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p><strong>4 ）</strong> 乘法和除法</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;&#123;print $0*2&#125;&#x27;</span>
2
4
6
8
10
<span class="hljs-comment"># seq 5 |awk &#x27;&#123;print $0%2&#125;&#x27;</span>
1
0
1
0
1
打印偶数行：
<span class="hljs-comment"># seq 5 |awk &#x27;$0%2==0&#123;print $0&#125;&#x27;</span>
2
4
打印奇数行：
<span class="hljs-comment"># seq 5 |awk &#x27;$0%2!=0&#123;print $0&#125;&#x27;</span>
1
3
5</code></pre>

<p><strong>5 ）</strong> 管道符使用</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |shuf |awk &#x27;&#123;print $0|&quot;sort&quot;&#125;&#x27;</span>
1
2
3
4
5</code></pre>

<p><strong>6 ）</strong> 正则表达式匹配</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;$0~3&#123;print $0&#125;&#x27;</span>
3
<span class="hljs-comment"># seq 5 |awk &#x27;$0!~3&#123;print $0&#125;&#x27;</span>
1
2
4
5
<span class="hljs-comment"># seq 5 |awk &#x27;$0~/[34]/&#123;print $0&#125;&#x27;</span>
3
4
<span class="hljs-comment"># seq 5 |awk &#x27;$0!~/[34]/&#123;print $0&#125;&#x27;</span>
1
2
5
<span class="hljs-comment"># seq 5 |awk &#x27;$0~/[^34]/&#123;print $0&#125;&#x27;</span>
1
2
5</code></pre>

<p><strong>7 ）</strong> 判断数组成员</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;a[&quot;a&quot;]=123&#125;END&#123;if(&quot;a&quot;in a)print&quot;yes&quot;&#125;&#x27; &lt;/dev/null</span>
yes</code></pre>

<p><strong>8 ）</strong> 三目运算符</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;print 1==1?&quot;yes&quot;:&quot;no&quot;&#125;&#x27; # 三目运算作为一个表达式，里面不允许写 print</span>
yes
<span class="hljs-comment"># seq 3 |awk &#x27;&#123;print $0==2?&quot;yes&quot;:&quot;no&quot;&#125;&#x27;</span>
no
yes
no
替换换行符为逗号：
<span class="hljs-comment"># seq 5 |awk &#x27;&#123;print n=(n?n&quot;,&quot;$0:$0)&#125;&#x27;</span>
1
1,2
1,2,3
1,2,3,4
1,2,3,4,5
<span class="hljs-comment"># seq 5 |awk &#x27;&#123;n=(n?n&quot;,&quot;$0:$0)&#125;END&#123;print n&#125;&#x27;</span>
1,2,3,4,5
说明：读取第一行时，n 没有变量，为假输出 <span class="hljs-variable">$0</span> 也就是 1 ，并赋值变量 n，读取第二行时，n 是 1 为
真，输出 1,2 以此类推，后面会一直为真。
每三行后面添加新一行：
<span class="hljs-comment"># seq 10 |awk &#x27;&#123;print NR%3?$0:$0&quot;\ntxt&quot;&#125;&#x27;</span>
1
2
3
txt
4
5
6
txt
7
8
9
txt
10
在
两行合并一行：
<span class="hljs-comment"># seq 6 |awk &#x27;&#123;printf NR%2!=0?$0&quot; &quot;:$0&quot; \n&quot;&#125;&#x27;</span>
1 2
3 4
5 6
<span class="hljs-comment"># seq 6 |awk &#x27;ORS=NR%2?&quot; &quot;:&quot;\n&quot;&#x27;</span>
1 2
3 4
5 6
<span class="hljs-comment"># seq 6 |awk &#x27;&#123;if(NR%2)ORS=&quot; &quot;;else ORS=&quot;\n&quot;;print&#125;&#x27;</span></code></pre>

<p><strong>9 ）</strong> 变量赋值</p>
<pre><code class="hljs bash">字段求和：
<span class="hljs-comment"># seq 5 |awk &#x27;&#123;sum+=1&#125;END&#123;print sum&#125;&#x27;</span>
5
<span class="hljs-comment"># seq 5 |awk &#x27;&#123;sum+=$0&#125;END&#123;print sum&#125;&#x27;</span>
15</code></pre>

<h3 id="7-3-5-流程控制"><a href="#7-3-5-流程控制" class="headerlink" title="7.3.5 流程控制"></a>7.3.5 流程控制</h3><p><strong>1 ）if 语句</strong></p>
<p>格式：if (condition) statement [ else statement ]</p>
<pre><code class="hljs bash">单分支：
<span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0==3)print $0&#125;&#x27;</span>
3
也支持正则匹配判断，一般在写复杂语句时使用：
<span class="hljs-comment"># echo &quot;123abc#456cde 789aaa#aaabbb&quot; |xargs - n1 |awk - F# &#x27;&#123;if($2~/[0-9]/)print $2&#125;&#x27;</span>
456cde
<span class="hljs-comment"># echo &quot;123abc#456cde 789aaa#aaabbb&quot; |xargs - n1 |awk - F# &#x27;&#123;if($2!~/[0-9]/)print $2&#125;&#x27;</span>
aaabbb
或
<span class="hljs-comment"># echo &quot;123abc#456cde 789 aaa#aaabbb&quot; |xargs - n1 |awk - F# &#x27;$2!~/[0-9]/&#123;print $2&#125;&#x27;</span>
aaabbb
双分支：
<span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0==3)print $0;else print&quot;no&quot;&#125;&#x27;</span>
no
no
3
no
no
多分支：
<span class="hljs-comment"># cat file</span>
1 2 3
4 5 6
7 8 9
<span class="hljs-comment"># awk &#x27;&#123;if($1==4)&#123;print&quot;1&quot;&#125; else if($2==5)&#123;print&quot;2&quot;&#125; else if($3==6)&#123;print&quot;3&quot;&#125; else &#123;print&quot;no&quot;&#125;&#125;&#x27; file</span>
no
1
no</code></pre>

<p><strong>2 ）while 语句</strong></p>
<p>格式：while (condition) statement</p>
<pre><code class="hljs bash">遍历打印所有字段：
<span class="hljs-comment"># awk &#x27;&#123;i=1;while(i&lt;=NF)&#123;print $i;i++&#125;&#125;&#x27; file</span>
1
2
3
4
5
6
7
8
9
awk 是按行处理的，每次读取一行，并遍历打印每个字段。</code></pre>

<p><strong>3 ）for 语句 C 语言风格</strong></p>
<p>格式：for (expr1; expr2; expr3) statement</p>
<pre><code class="hljs bash">遍历打印所有字段：
<span class="hljs-comment"># cat file</span>
1 2 3
4 5 6
7 8 9
<span class="hljs-comment"># awk &#x27;&#123;for(i=1;i&lt;=NF;i++)print $i&#125;&#x27; file</span>
1
2
3
4
5
6
7
8
9
倒叙打印文本：
<span class="hljs-comment"># awk &#x27;&#123;for(i=NF;i&gt;=1;i--)print $i&#125;&#x27; file</span>
3
2
1
6
5
4
9
8
7
都换行了，这并不是我们要的结果。怎么改进呢？
<span class="hljs-comment"># awk &#x27;&#123;for(i=NF;i&gt;=1;i--)&#123;printf $i&quot; &quot;&#125;;print&quot;&quot;&#125;&#x27; file # print 本身就会新打印一行</span>
3 2 1
6 5 4
9 8 7
或
<span class="hljs-comment"># awk &#x27;&#123;for(i=NF;i&gt;=1;i--)if(i==1)printf $i&quot;\n&quot;;else printf $i&quot; &quot;&#125;&#x27; file</span>
3 2 1
6 5 4
9 8 7
在这种情况下，是不是就排除第一行和倒数第一行呢？我们正序打印看下
排除第一行：
<span class="hljs-comment"># awk &#x27;&#123;for(i=2;i&lt;=NF;i++)&#123;printf $i&quot; &quot;&#125;;print&quot;&quot;&#125;&#x27; file</span>
2 3
5 6
8 9
排除第二行：
<span class="hljs-comment"># awk &#x27;&#123;for(i=1;i&lt;=NF-1;i++)&#123;printf $i&quot; &quot;&#125;;print&quot;&quot;&#125;&#x27; file</span>
1 2
4 5
7 8
IP 加单引号：
<span class="hljs-comment"># echo &#x27;10.10.10.1 10.10.10.2 10.10.10.3&#x27; |awk &#x27;&#123;for(i=1;i&lt;=NF;i++)printf&quot;\047&quot;$i&quot;\047&quot;&#125;&#x27;10.10.10.1&#x27;&#x27;10.10.10.2&#x27; &#x27;10.10.10.3&#x27;</span>
\047 是 ASCII 码，可以通过 showkey -a 命令查看。</code></pre>

<p><strong>4 ）for 语句遍历数组</strong></p>
<p>格式：for (var in array) statement</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[NR]=$0&#125;END&#123;for(v in a)print v,a[v]&#125;&#x27;</span>
4 str4
5 str5
1 str1
2 str2
3 str3</code></pre>

<p><strong>5 ）break 和 continue 语句</strong></p>
<p>break 跳过所有循环，continue 跳过当前循环。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;for(i=1;i&lt;=5;i++)&#123;if(i==3)&#123;break&#125;;print i&#125;&#125;&#x27;</span>
1
2
<span class="hljs-comment"># awk &#x27;BEGIN&#123;for(i=1;i&lt;=5;i++)&#123;if(i==3)&#123;continue&#125;;print i&#125;&#125;&#x27;</span>
1
2
4
5</code></pre>

<p><strong>6 ）删除数组和元素</strong></p>
<p>格式：</p>
<p>delete array[index] 删除数组元素</p>
<p>delete array 删除数组</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[NR]=$0&#125;END&#123;delete a;for(v in a)print v,a[v]&#125;&#x27;</span>
空的...
<span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[NR]=$0&#125;END&#123;delete a[3];for(v in a)print v,a[v]&#125;&#x27;</span>
4 str4
5 str5
1 str1
2 str2</code></pre>

<p><strong>7 ）exit 语句</strong></p>
<p>格式：exit [expression]</p>
<p>exit 退出程序，与 shell 的 exit 一样。[expr] 是 0 - 255 之间的数字。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0~/3/)exit (123)&#125;&#x27;</span>
<span class="hljs-comment"># echo $?</span>
123</code></pre>

<h3 id="7-3-6-数组"><a href="#7-3-6-数组" class="headerlink" title="7.3.6 数组"></a>7.3.6 数组</h3><p>数组：存储一系列相同类型的元素，键 / 值方式存储，通过下标（键）来访问值。</p>
<p>awk 中数组称为关联数组，不仅可以使用数字作为下标，还可以使用字符串作为下标。<br>数组元素的键和值存储在 awk 程序内部的一个表中，该表采用散列算法，因此数组元素是随机排序。</p>
<p>数组格式：array[index]=value</p>
<p><strong>1 ）自定义数组</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;a[0]=&quot;test&quot;;print a[0]&#125;&#x27;</span>
<span class="hljs-built_in">test</span></code></pre>

<p><strong>2 ）通过 NR 设置记录下标，下标从 1 开始</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail -n3 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;print a[1]&#125;&#x27;</span>
systemd-network
<span class="hljs-comment"># tail -n3 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;print a[2]&#125;&#x27;</span>
zabbix
<span class="hljs-comment"># tail -n3 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;print a[3]&#125;&#x27;</span>
user</code></pre>

<p><strong>3 ）通过 for 循环遍历数组</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail -n5 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>
zabbix 4
user 5
admin 1
systemd-bus-proxy 2
systemd-network 3
<span class="hljs-comment"># tail -n5 /etc/passwd |awk -F: &#x27;&#123;a[NR]=$1&#125;END&#123;for(i=1;i&lt;=NR;i++)print a[i],i&#125;&#x27;</span>
admin 1
systemd-bus-proxy 2
systemd-network 3
zabbix 4
user 5</code></pre>

<p>上面打印的 i 是数组的下标。<br>第一种 for 循环的结果是乱序的，刚说过，数组是无序存储。<br>第二种 for 循环通过下标获取的情况是排序正常。<br>所以当下标是数字序列时，还是用 for(expr1;expr2;expr3) 循环表达式比较好，保持顺序不变。</p>
<p><strong>4 ）通过 ++ 方式作为下标</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail -n5 /etc/passwd |awk -F: &#x27;&#123;a[x++]=$1&#125;END&#123;for(i=0;i&lt;=x-1;i++)print a[i],i&#125;&#x27;</span>
admin 0
systemd-bus-proxy 1
systemd-network 2
zabbix 3
user 4</code></pre>

<p>x 被 awk 初始化值是 0 ，没循环一次 + 1</p>
<p><strong>5 ）使用字段作为下标</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail -n5 /etc/passwd |awk -F: &#x27;&#123;a[$1]=$7&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>
/sbin/nologin admin
/bin/bash user
/sbin/nologin systemd-network
/sbin/nologin systemd-bus-proxy
/sbin/nologin zabbix</code></pre>

<p><strong>6 ）统计相同字段出现次数</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>
2 com-bardac-dw
1 3gpp-cbsp
2 iqobject
1 matahari
2 isnetserv
2 blp5
<span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;a[$1]+=1&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>
2 com-bardac-dw
1 3gpp-cbsp
2 iqobject
1 matahari
2 isnetserv
2 blp5
<span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/&#123;a[$1]++&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>
2 blp5</code></pre>

<p>第一个字段作为下标，值被 ++ 初始化是 0 ，每次遇到下标（第一个字段）一样时，对应的值就会被 + 1，因此实现了统计出现次数。<br>想要实现去重的的话就简单了，只要打印下标即可。</p>
<p><strong>7 ）统计 TCP 连接状态</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># netstat -antp |awk &#x27;/^tcp/&#123;a[$6]++&#125;END&#123;for(v in a)print a[v],v&#125;&#x27;</span>
9 LISTEN
6 ESTABLISHED
6 TIME_WAIT</code></pre>

<p><strong>8 ）只打印出现次数大于等于 2 的</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a) if(a[v]&gt;=2)&#123;print a[v],v&#125;&#125;&#x27;</span>
2 com-bardac-dw
2 iqobject
2 isnetserv
2 blp5</code></pre>

<p><strong>9 ）去重</strong></p>
<pre><code class="hljs bash">只打印重复的行：
<span class="hljs-comment"># tail /etc/services |awk &#x27;a[$1]++&#x27;</span>
isnetserv 48128/udp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/udp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/udp <span class="hljs-comment"># iqobject</span>
不打印重复的行：
<span class="hljs-comment"># tail /etc/services |awk &#x27;!a[$1]++&#x27;</span>
3gpp-cbsp 48049/tcp <span class="hljs-comment"># 3GPP Cell Broadcast Service</span>
isnetserv 48128/tcp <span class="hljs-comment"># Image Systems Network Services</span>
blp5 48129/tcp <span class="hljs-comment"># Bloomberg locator</span>
com-bardac-dw 48556/tcp <span class="hljs-comment"># com-bardac-dw</span>
iqobject 48619/tcp <span class="hljs-comment"># iqobject</span>
matahari 49000/tcp <span class="hljs-comment"># Matahari Broker</span></code></pre>

<p>先明白一个情况，当值是 0 是为假，非 0 整数为真，知道这点就不难理解了。<br>只打印重复的行说明：当处理第一条记录时，执行了 ++，初始值是 0 为假，就不打印，如果再遇到相同的记录，值就会 + 1，不为 0 ，则打印。<br>不打印重复的行说明：当处理第一条记录时，执行了 ++，初始值是 0 为假，感叹号取反为真，打印，如果再遇到相同的记录，值就会 + 1，不为 0 为真，取反为假就不打印。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;if(a[$1]++)print $1&#125;&#x27;</span>
isnetserv
blp5
com-bardac-dw
iqobject
使用三目运算：
<span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;print a[$1]++?$1:&quot;no&quot;&#125;&#x27;</span>
no
no
isnetserv
no
blp5
no
com-bardac-dw
no
iqobject
no
<span class="hljs-comment"># tail /etc/services |awk &#x27;&#123;if(!a[$1]++)print $1&#125;&#x27;</span>
3gpp-cbsp
isnetserv
blp5
com-bardac-dw
iqobject
matahari</code></pre>

<p><strong>10 ）统计每个相同字段的某字段总数：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail /etc/services |awk -F&#x27;[/]+&#x27; &#x27;&#123;a[$1]+=$2&#125;END&#123;for(v in a)print v, a[v]&#125;&#x27;</span>
com-bardac-dw 97112
3gpp-cbsp 48049
iqobject 97238
matahari 49000
isnetserv 96256
blp5 96258</code></pre>

<p><strong>11 ）多维数组</strong></p>
<p>awk 的多维数组，实际上 awk 并不支持多维数组，而是逻辑上模拟二维数组的访问方式，比如<br>a[a,b]=1，使用 SUBSEP（默认 \ 034 ）作为分隔下标字段，存储后是这样 a\034b。</p>
<p>示例：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;BEGIN&#123;a[&quot;x&quot;,&quot;y&quot;]=123;for(v in a) print v,a[v]&#125;&#x27;</span>
xy 123
我们可以重新复制 SUBSEP 变量，改变下标默认分隔符：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;SUBSEP=&quot;:&quot;;a[&quot;x&quot;,&quot;y&quot;]=123;for(v in a) print v,a[v]&#125;&#x27;</span>
x:y 123
根据指定的字段统计出现次数：
<span class="hljs-comment"># cat file</span>
A 192.168.1.1 HTTP
B 192.168.1.2 HTTP
B 192.168.1.2 MYSQL
C 192.168.1.1 MYSQL
C 192.168.1.1 MQ
D 192.168.1.4 NGINX
<span class="hljs-comment"># awk &#x27;BEGIN&#123;SUBSEP=&quot;-&quot;&#125;&#123;a[$1,$2]++&#125;END&#123;for(v in a)print a[v],v&#125;&#x27; file</span>
1 D-192.168.1.4
1 A-192.168.1.1
2 C-192.168.1.1
2 B-192.168.1.2</code></pre>

<h3 id="7-3-7-内置函数"><a href="#7-3-7-内置函数" class="headerlink" title="7.3.7 内置函数"></a>7.3.7 内置函数</h3><p>| 函数 | 描述 |</p>
<p>|int(expr) | 截断为整数 |<br>|sqrt(expr) | 平方根 |<br>|rand() | 返回一个随机数 N， 0 和 1 范围，0 &lt; N &lt; 1|<br>|srand([expr]) | 使用 expr 生成随机数，如果不指定，默认使用当前时间为种子，如 &lt; br &gt; 果前面有种子则使用生成随机数 |<br>|asort(a, b) | 对数组 a 的值进行排序，把排序后的值存到新的数组 b 中，新排序 &lt; br &gt; 的数组下标从 1 开始 |<br>|asorti(a,b) | 对数组 a 的下标进行排序，同上 |<br>|sub(r, s [, t]) | 对输入的记录用 s 替换 r 正则匹配，t 可选针对某字段替换，但只替 &lt; br &gt; 换第一个字符串 |<br>|gsub(r, s [, t]) | 对输入的记录用 s 替换 r 正则匹配，t 可选针对某字段替换，否则替 &lt; br &gt; 换所有字符串 |<br>|gensub(r, s, h [, t]) | 对输入的记录用 s 替换 r 正则匹配，h 替换指定索引位置 |<br>|index(s, t) | 返回 s 中字符串 t 的索引位置， 0 为不存在 |<br>|length([s]) | 返回 s 的长度 |<br>|match(s, r [, a]) | 测试字符串 s 是否包含匹配 r 的字符串，如果不包含返回 0|<br>|split(s, a [, r [, seps] ]) | 根据分隔符 seps 将 s 分成数组 a|<br>|substr(s, i [, n]) | 截取字符串 s 从 i 开始到长度 n，如果 n 没指定则是剩余部分 |<br>|tolower(str) |str 中的所有大写转换成小写 |<br>|toupper(str) |str 中的所有小写转换成大写 |<br>|systime() | 当前时间戳 |<br>|strftime<br>([format [,timestamp[, utc-flag]]]) | 格式化输出时间，将时间戳转为字符串 |</p>
<p><strong>示例：</strong></p>
<p><strong>1 ）int()</strong></p>
<pre><code class="hljs bash">截断为整数：
<span class="hljs-comment"># echo -e &quot;123abc\nabc123\n123abc123&quot; | awk &#x27;&#123;print int($0)&#125;&#x27;</span>
123
0
123
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print int(10/3)&#125;&#x27;</span>
3</code></pre>

<p><strong>2 ）sqrt()</strong></p>
<pre><code class="hljs bash">获取 9 的平方根：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print sqrt(9)&#125;&#x27;</span>
3</code></pre>

<p><strong>3 ）rand() 和 srand()</strong></p>
<pre><code class="hljs bash">rand() 并不是每次运行就是一个随机数，会一直保持一个不变：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print rand()&#125;&#x27;</span>
0.237788
当执行 srand() 函数后，rand() 才会发生变化，所以一般在 awk 着两个函数结合生成随机数，但是
也有很大几率生成一样：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;srand();print rand()&#125;&#x27;</span>
0.31687
如果想生成 1 - 10 的随机数可以这样：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;srand();print int(rand()*10)&#125;&#x27;</span>
4</code></pre>

<p>如果想更完美生成随机数，还得做相应的处理！</p>
<p><strong>4 ）asort() 和 asorti()</strong></p>
<pre><code class="hljs bash">排序数组：
<span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[x++]=$0&#125;END&#123;s=asort(a,b);for(i=1;i&lt;=s;i++)print b[i],i&#125;&#x27;</span>
str1 1
str2 2
str3 3
str4 4
str5 5
<span class="hljs-comment"># seq -f &quot;str%.g&quot; 5 |awk &#x27;&#123;a[x++]=$0&#125;END&#123;s=asorti(a,b);for(i=1;i&lt;=s;i++)print b[i],i&#125;&#x27;</span>
0 1
1 2
2 3
3 4
4 5</code></pre>

<p>asort 将 a 数组的值放到数组 b，a 下标丢弃，并将数组 b 的总行号赋值给 s，新数组 b 下标从 1 开始，然后遍历。</p>
<p><strong>5 ）sub() 和 gsub()</strong></p>
<pre><code class="hljs bash">替换正则匹配的字符串：
<span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/&#123;sub(/tcp/,&quot;icmp&quot;);print $0&#125;&#x27;</span>
blp5 48129/icmp <span class="hljs-comment"># Bloomberg locator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg locator</span>
<span class="hljs-comment"># tail /etc/services |awk &#x27;/blp5/&#123;gsub(/c/,&quot;9&quot;);print $0&#125;&#x27;</span>
blp5 48129/t9p <span class="hljs-comment"># Bloomberg lo9ator</span>
blp5 48129/udp <span class="hljs-comment"># Bloomberg lo9ator</span>
<span class="hljs-comment"># echo &quot;1 2 2 3 4 5&quot; |awk &#x27;gsub(2,7,$2)&#123;print $0&#125;&#x27;</span>
1 7 2 3 4 5
<span class="hljs-comment"># echo &quot;1 2 3 a b c&quot; |awk &#x27;gsub(/[0-9]/,&#x27;0&#x27;)&#123;print $0&#125;&#x27;</span>
0 0 0 a b c</code></pre>

<p>在指定行前后加一行：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 | awk &#x27;NR==2&#123;sub(&#x27;/.*/&#x27;,&quot;txt\n&amp;&quot;)&#125;&#123;print&#125;&#x27;</span>
1
txt
2
3
4
5
<span class="hljs-comment"># seq 5 | awk &#x27;NR==2&#123;sub(&#x27;/.*/&#x27;,&quot;&amp;\ntxt&quot;)&#125;&#123;print&#125;&#x27;</span>
1
2
txt
3
4
5</code></pre>

<p><strong>6 ）index()</strong></p>
<pre><code class="hljs bash">获取字段索引起始位置：
<span class="hljs-comment"># tail -n 5 /etc/services |awk &#x27;&#123;print index($2,&quot;tcp&quot;)&#125;&#x27;</span>
7
0
7
0
7</code></pre>

<p><strong>7 ）length()</strong></p>
<pre><code class="hljs bash">统计字段长度：
<span class="hljs-comment"># tail -n 5 /etc/services |awk &#x27;&#123;print length($2)&#125;&#x27;</span>
9
9
9
9
9
统计数组的长度：
<span class="hljs-comment"># tail -n 5 /etc/services |awk &#x27;&#123;a[$1]=$2&#125;END&#123;print length(a)&#125;&#x27;</span>
3</code></pre>

<p><strong>8 ）match</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;123abc#456cde 789aaa#234bbb 999aaa#aaabbb&quot; |xargs -n1 |awk &#x27;&#123;printmatch($0,234)&#125;&#x27;</span>
0
8
0
如果记录匹配字符串 234 ，则返回索引位置，否则返回 0 。
那么，我们只想打印包含这个字符串的记录就可以这样：
<span class="hljs-comment"># echo &quot;123abc#456cde 789aaa#234bbb 999aaa#aaabbb&quot; |xargs -n1 |awk</span>
<span class="hljs-string">&#x27;&#123;if(match($0,234)!=0)print $0&#125;&#x27;</span>
789aaa<span class="hljs-comment">#234bbb</span></code></pre>

<p><strong>9 ）split()</strong></p>
<pre><code class="hljs bash">切分记录为数组 a：
<span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;split($0,a);for(v in a)print a[v],v&#125;&#x27;</span>
123<span class="hljs-comment">#456#789 1</span>
abc<span class="hljs-comment">#cde#fgh 1</span>
以 <span class="hljs-comment">#号切分记录为数据 a：</span>
<span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;split($0,a,&quot;#&quot;);for(v in a)print a[v],v&#125;&#x27;</span>
123 1
456 2
789 3
abc 1
cde 2
fgh 3</code></pre>

<p><strong>10 ）substr()</strong></p>
<pre><code class="hljs bash">截取字符串索引 4 到最后：
<span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;printsubstr($0,4)&#125;&#x27;</span>
<span class="hljs-comment">#456#789</span>
<span class="hljs-comment">#cde#fgh</span>
截取字符串索引 4 到长度 5 ：
<span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;print substr($0,4,5)&#125;&#x27;</span>
<span class="hljs-comment">#456#</span>
<span class="hljs-comment">#cde#</span></code></pre>

<p><strong>11 ）tolower() 和 toupper()</strong></p>
<pre><code class="hljs bash">转换小写：
<span class="hljs-comment"># echo -e &quot;123#456#789\nABC#cde#fgh&quot; |awk &#x27;&#123;print tolower($0)&#125;&#x27;</span>
123<span class="hljs-comment">#456#789</span>
abc<span class="hljs-comment">#cde#fgh</span>
转换大写：
<span class="hljs-comment"># echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk &#x27;&#123;print toupper($0)&#125;&#x27;</span>
123<span class="hljs-comment">#456#789</span>
ABC<span class="hljs-comment">#CDE#FGH</span></code></pre>

<p><strong>12 ) 时间处理</strong></p>
<pre><code class="hljs bash">返回当前时间戳：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;print systime()&#125;&#x27;</span>
1483297766
将时间戳转为日期和时间
<span class="hljs-comment"># echo &quot;1483297766&quot; |awk &#x27;&#123;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,$0)&#125;&#x27;</span>
2017 - 01 - 01 14:09:26</code></pre>

<h3 id="7-3-8-I-O-语句"><a href="#7-3-8-I-O-语句" class="headerlink" title="7.3.8 I/O 语句"></a>7.3.8 I/O 语句</h3><table>
<thead>
<tr>
<th>语句</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getline</td>
<td>读取下一个输入记录设置给 $0</td>
</tr>
<tr>
<td>getline var</td>
<td>读取下一个输入记录并赋值给变量 var</td>
</tr>
<tr>
<td>command | getline [var]</td>
<td>运行 Shell 命令管道输出到 $0 或 var</td>
</tr>
<tr>
<td>next</td>
<td>停止当前处理的输入记录后面动作</td>
</tr>
<tr>
<td>print</td>
<td>打印当前记录</td>
</tr>
<tr>
<td>printf fmt, expr-list</td>
<td>格式化输出</td>
</tr>
<tr>
<td>printf fmt, expr-list &gt;file</td>
<td>格式输出和写到文件</td>
</tr>
<tr>
<td>system(cmd-line)</td>
<td>执行命令和返回状态</td>
</tr>
<tr>
<td>print … &gt;&gt; file</td>
<td>追加输出到文件</td>
</tr>
<tr>
<td>print … | command</td>
<td>打印输出作为命令输入</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<p><strong>1 ）getline</strong></p>
<pre><code class="hljs bash">获取匹配的下一行：
<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;getline;print&#125;&#x27;</span>
4
<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;print;getline;print&#125;&#x27;</span>
3
4
在匹配的下一行加个星号：
<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;getline;sub(&quot;.*&quot;,&quot;&amp;*&quot;);print&#125;&#x27;</span>
4*
<span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;print;getline;sub(&quot;.*&quot;,&quot;&amp;*&quot;)&#125;&#123;print&#125;&#x27;</span>
1
2
3
4*
5</code></pre>

<p><strong>2 ）getline var</strong></p>
<pre><code class="hljs bash">把 a 文件的行追加到 b 文件的行尾：
<span class="hljs-comment"># cat a</span>
a
b
c
<span class="hljs-comment"># cat b</span>
1 one
2 two
3 three
<span class="hljs-comment"># awk &#x27;&#123;getline line&lt;&quot;a&quot;;print $0,line&#125;&#x27; b</span>
1 one a
2 two b
3 three c
把 a 文件的行替换 b 文件的指定字段：
<span class="hljs-comment"># awk &#x27;&#123;getline line&lt;&quot;a&quot;;gsub($2,line,$2);print&#125;&#x27; b</span>
1 a
2 b
3 c
把 a 文件的行替换 b 文件的对应字段：
<span class="hljs-comment"># awk &#x27;&#123;getline line&lt;&quot;a&quot;;gsub(&quot;two&quot;,line,$2);print&#125;&#x27; b</span>
1 one
2 b
3 three</code></pre>

<p><strong>3 ）command | getline [var]</strong></p>
<pre><code class="hljs bash">获取执行 shell 命令后结果的第一行：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;&quot;seq 5&quot;|getline var;print var&#125;&#x27;</span>
1
循环输出执行 shell 命令后的结果：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;while(&quot;seq 5&quot;|getline)print&#125;&#x27;</span>
1
2
3
4
5</code></pre>

<p><strong>4 ）next</strong></p>
<pre><code class="hljs bash">不打印匹配行：
<span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0==3)&#123;next&#125;else&#123;print&#125;&#125;&#x27;</span>
1
2
4
5
删除指定行：
<span class="hljs-comment"># seq 5 |awk &#x27;NR==1&#123;next&#125;&#123;print $0&#125;&#x27;</span>
2
3
4
5
如果前面动作成功，就遇到 next，后面的动作不再执行，跳过。
或者：
<span class="hljs-comment"># seq 5 |awk &#x27;NR!=1&#123;print&#125;&#x27;</span>
2
3
4
5
把第一行内容放到每行的前面：
<span class="hljs-comment"># cat a</span>
hello
1 a
2 b
3 c
<span class="hljs-comment"># awk &#x27;NR==1&#123;s=$0;next&#125;&#123;print s,$0&#125;&#x27; a</span>
hello 1 a
hello 2 b
hello 3 c
<span class="hljs-comment"># awk &#x27;NR==1&#123;s=$0&#125;NF!=1&#123;print s,$0&#125;&#x27; a</span>
hello 1 a
hello 2 b
hello 3 c</code></pre>

<p><strong>5 ）system()</strong></p>
<pre><code class="hljs bash">执行 shell 命令判断返回值：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;if(system(&quot;grep root /etc/passwd &amp;&gt;/dev/null&quot;)==0)print&quot;yes&quot;;else print&quot;no&quot;&#125;&#x27;</span>
yes</code></pre>

<p><strong>6 ）打印结果写到文件</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># tail -n5 /etc/services |awk &#x27;&#123;print $2&gt;&quot;a.txt&quot;&#125;&#x27;</span>
<span class="hljs-comment"># cat a.txt</span>
48049/tcp
48128/tcp
48128/udp
48129/tcp
48129/udp</code></pre>

<p><strong>7 ）管道连接 shell 命令</strong></p>
<pre><code class="hljs bash">将结果通过 grep 命令过滤：
<span class="hljs-comment"># tail - n5 /etc/services |awk &#x27;&#123;print $2|&quot;grep tcp&quot;&#125;&#x27;</span>
48556/tcp
48619/tcp
49000/tcp</code></pre>

<h3 id="7-3-9-printf-语句"><a href="#7-3-9-printf-语句" class="headerlink" title="7.3.9 printf 语句"></a>7.3.9 printf 语句</h3><p>格式化输出，默认打印字符串不换行。</p>
<p>格式：printf [format] arguments</p>
<table>
<thead>
<tr>
<th>Format</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>一个字符串</td>
</tr>
<tr>
<td>%d，%i</td>
<td>一个小数</td>
</tr>
<tr>
<td>%f</td>
<td>一个浮点数</td>
</tr>
<tr>
<td>%.ns</td>
<td>输出字符串，n 是输出几个字符</td>
</tr>
<tr>
<td>%m.nf</td>
<td>输出浮点数，m 是输出整数位数，n 是输出的小数位数</td>
</tr>
<tr>
<td>%x</td>
<td>不带正负号的十六进制，使用 a 至 f 表示 10 到 15</td>
</tr>
<tr>
<td>%X</td>
<td>不带正负号的十六进制，使用 A 至 F 表示 10 至 15</td>
</tr>
<tr>
<td>%%</td>
<td>输出单个 %</td>
</tr>
<tr>
<td>%-5s</td>
<td>左对齐，对参数每个字段左对齐, 宽度为 5</td>
</tr>
<tr>
<td>%-4.2f</td>
<td>左对齐，宽度为 4 ，保留两位小数</td>
</tr>
<tr>
<td>%5s</td>
<td>右对齐，不加横线表示右对齐</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">将换行符换成逗号：
<span class="hljs-comment"># seq 5 |awk &#x27;&#123;if($0!=5)printf&quot;%s,&quot;,$0;else print $0&#125;&#x27;</span>
1,2,3,4,5
小括号中的 5 是最后一个数字。
输出一个字符：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%.1s\n&quot;,&quot;abc&quot;&#125;&#x27;</span>
a
保留一个小数点：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%.2f\n&quot;,10/3&#125;&#x27;</span>
3.33
格式化输出：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;user:%s\tpass:%d\n&quot;,&quot;abc&quot;,123&#125;&#x27;</span>
user:abc pass:123
左对齐宽度 10 ：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%-10s %-10s %-10s\n&quot;,&quot;ID&quot;,&quot;Name&quot;,&quot;Passwd&quot;&#125;&#x27;</span>
ID Name Passwd
右对齐宽度 10 ：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%10s %10s %10s\n&quot;,&quot;ID&quot;,&quot;Name&quot;,&quot;Passwd&quot;&#125;&#x27;</span>
ID Name Passwd
打印表格：
<span class="hljs-comment"># vi test.awk</span>
BEGIN&#123;
<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;+--------------------+--------------------+&quot;</span>;
<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;|%-20s|%-20s|\n&quot;</span>,<span class="hljs-string">&quot;Name&quot;</span>,<span class="hljs-string">&quot;Number&quot;</span>;
<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;+--------------------+--------------------+&quot;</span>;
&#125;
<span class="hljs-comment"># awk -f test.awk</span>
+--------------------+--------------------+
|Name |Number |
+--------------------+--------------------+
格式化输出：
<span class="hljs-comment"># awk -F: &#x27;BEGIN&#123;printf&quot;UserName\t\tShell\n-----------------------------\n&quot;&#125;&#123;printf&quot;%-20s %-20s\n&quot;,$1,$7&#125;END&#123;print&quot;END...\n&quot;&#125;&#x27; /etc/passwd</span>
打印十六进制：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;printf&quot;%x %X&quot;,123,123&#125;&#x27;</span>
7b 7B</code></pre>

<h3 id="7-3-10-自定义函数"><a href="#7-3-10-自定义函数" class="headerlink" title="7.3.10 自定义函数"></a>7.3.10 自定义函数</h3><p>格式：function name(parameter list) { statements }</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># awk &#x27;function myfunc(a,b)&#123;return a+b&#125;BEGIN&#123;print myfunc(1,2)&#125;&#x27;</span>
3</code></pre>

<h3 id="7-3-11-需求案例"><a href="#7-3-11-需求案例" class="headerlink" title="7.3.11 需求案例"></a>7.3.11 需求案例</h3><p><strong>1 ）分析 Nginx 日志</strong></p>
<p>日志格式：</p>
<p>‘$remote_addr - $remote_user [$time_local]”$request”$status $body_bytes_sent”$http_referer””$http_user_agent” “$http_x_forwarded_for”‘</p>
<pre><code class="hljs bash">统计访问 IP 次数：
<span class="hljs-comment"># awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a)print v,a[v]&#125;&#x27; access.log</span>
统计访问访问大于 100 次的 IP：
<span class="hljs-comment"># awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a)&#123;if(a[v]&gt;100)print v,a[v]&#125;&#125;&#x27; access.log</span>
统计访问 IP 次数并排序取前 10 ：
<span class="hljs-comment"># awk &#x27;&#123;a[$1]++&#125;END&#123;for(v in a)print v,a[v] |&quot;sort -k2 -nr |head -10&quot;&#125;&#x27; access.log</span>
统计时间段访问最多的 IP：
<span class="hljs-comment"># awk &#x27;$4&gt;=&quot;[02/Jan/2017:00:02:00&quot;&amp;&amp; $4&lt;=&quot;[02/Jan/2017:00:03:00&quot;&#123;a[$1]++&#125;END&#123;for(v ina)print v,a[v]&#125;&#x27; access.log</span>

统计上一分钟访问量：
<span class="hljs-comment"># date=$(date -d &#x27;-1 minute&#x27; +%d/%d/%Y:%H:%M)</span>
<span class="hljs-comment"># awk - vdate=$date &#x27;$4~date&#123;c++&#125;END&#123;print c&#125;&#x27; access.log</span>

统计访问最多的 10 个页面：
<span class="hljs-comment"># awk &#x27;&#123;a[$7]++&#125;END&#123;for(v in a)print v,a[v] |&quot;sort -k1 -nr|head -n10&quot;&#125;&#x27; access.log</span>

统计每个 URL 数量和返回内容总大小：
<span class="hljs-comment"># awk &#x27;&#123;a[$7]++;size[$7]+=$10&#125;END&#123;for(v in a)print a[v],v,size[v]&#125;&#x27; access.log</span>
统计每个 IP 访问状态码数量：

<span class="hljs-comment"># awk &#x27;&#123;a[$1&quot; &quot;$9]++&#125;END&#123;for(v in a)print v,a[v]&#125;&#x27; access.log</span>
统计访问 IP 是 404 状态次数：

<span class="hljs-comment"># awk &#x27;&#123;if($9~/404/)a[$1&quot; &quot;$9]++&#125;END&#123;for(i in a)print v,a[v]&#125;&#x27; access.log</span></code></pre>

<p><strong>2 ）两个文件对比</strong></p>
<p>找出 b 文件在 a 文件相同记录：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 1 5 &gt; a</span>
<span class="hljs-comment"># seq 3 7 &gt; b</span>
方法 1 ：
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0];next&#125;&#123;if($0 in a)print $0&#125;&#x27; a b</span>
3
4
5
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0];next&#125;&#123;if($0 in a)print FILENAME,$0&#125;&#x27; a b</span>
b 3
b 4
b 5
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]&#125;NR&gt;FNR&#123;if($0 in a)print $0&#125;&#x27; a b</span>
3
4
5
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]=1;next&#125;(a[$0]==1)&#x27; a b # a[$0] 是通过 b 文件每行获取值，如果是 1 说明有</span>
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]=1;next&#125;&#123;if(a[$0]==1)print&#125;&#x27; a b</span>
3
4
5
方法 2 ：
<span class="hljs-comment"># awk &#x27;FILENAME==&quot;a&quot;&#123;a[$0]&#125;FILENAME==&quot;b&quot;&#123;if($0 in a)print $0&#125;&#x27; a b</span>
3
4
5
方法 3 ：
<span class="hljs-comment"># awk &#x27;ARGIND==1&#123;a[$0]=1&#125;ARGIND==2 &amp;&amp; a[$0]==1&#x27; a b</span>
3
4
5</code></pre>

<p>找出 b 文件在 a 文件不同记录：</p>
<pre><code class="hljs bash">方法 1 ：
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0];next&#125;!($0 in a)&#x27; a b</span>
6
7
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]=1;next&#125;(a[$0]!=1)&#x27; a b</span>
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$0]=1;next&#125;&#123;if(a[$0]!=1)print&#125;&#x27; a b</span>
6
7
方法 2 ：
<span class="hljs-comment"># awk &#x27;FILENAME==&quot;a&quot;&#123;a[$0]=1&#125;FILENAME==&quot;b&quot;&amp;&amp; a[$0]!=1&#x27; a b</span>
方法 3 ：
<span class="hljs-comment"># awk &#x27;ARGIND==1&#123;a[$0]=1&#125;ARGIND==2 &amp;&amp; a[$0]!=1&#x27; a b</span></code></pre>

<p><strong>3 ）合并两个文件</strong></p>
<p>将 a 文件合并到 b 文件：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat a</span>
zhangsan 20
lisi 23
wangwu 29
<span class="hljs-comment"># cat b</span>
zhangsan man
lisi woman
wangwu man
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$1]=$0;next&#125;&#123;print a[$1],$2&#125;&#x27; a b</span>
zhangsan 20 man
lisi 23 woman
wangwu 29 man
<span class="hljs-comment"># awk &#x27;FNR==NR&#123;a[$1]=$0&#125;NR&gt;FNR&#123;print a[$1],$2&#125;&#x27; a b</span>
zhangsan 20 man
lisi 23 woman
wangwu 29 man</code></pre>

<p>将 a 文件相同 IP 的服务名合并：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat a</span>
192.168.1.1: httpd
192.168.1.1: tomcat
192.168.1.2: httpd
192.168.1.2: postfix
192.168.1.3: mysqld
192.168.1.4: httpd
<span class="hljs-comment"># awk &#x27;BEGIN&#123;FS=&quot;:&quot;;OFS=&quot;:&quot;&#125;&#123;a[$1]=a[$1] $2&#125;END&#123;for(v in a)print v,a[v]&#125;&#x27; a</span>
192.168.1.4: httpd
192.168.1.1: httpd tomcat
192.168.1.2: httpd postfix
192.168.1.3: mysqld</code></pre>

<p>说明：数组 a 存储是 $1=a[$1] $2，第一个 a[$1] 是以第一个字段为下标，值是 a[$1] $2，也就是 $1=a[$1] $2，值的 a[$1] 是用第一个字段为下标获取对应的值，但第一次数组 a 还没有元素，那么 a[$1] 是空值，此时数组存储是 192.168.1.1=httpd，再遇到 192.168.1.1 时，a[$1] 通过第一字段下标获得上次数组的 httpd，把当前处理的行第二个字段放到上一次同下标的值后面，作为下标 192.168.1.1 的新值。此时数组存储是 192.168.1.1=httpd tomcat。每次遇到相同的下标（第一个字段）就会获取上次这个下标对应的值与当前字段并作为此下标的新值。</p>
<p><strong>4 ）将第一列合并到一行</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat file</span>
1 2 3
4 5 6
7 8 9
<span class="hljs-comment"># awk &#x27;&#123;for(i=1;i&lt;=NF;i++)a[i]=a[i]$i&quot; &quot;&#125;END&#123;for(v in a)print a[v]&#125;&#x27; file</span>
1 4 7
2 5 8
3 6 9</code></pre>

<p>说明：<br>for 循环是遍历每行的字段，NF 等于 3 ，循环 3 次。</p>
<p>读取第一行时：<br>第一个字段：a[1]=a[1] 1 “ “ 值 a[ 1 ] 还未定义数组，下标也获取不到对应的值，所以为空，因此 a[ 1 ]= 1 。</p>
<p>第二个字段：a[2]=a[2] 2 “ “ 值 a[ 2 ] 数组 a 已经定义，但没有 2 这个下标，也获取不到对应的值，为空，因此 a[ 2 ]=2 。</p>
<p>第三个字段：a[3]=a[3] 3 “ “ 值 a[ 2 ] 与上面一样，为空, a[3]= 3 。</p>
<p>读取第二行时：</p>
<p>第一个字段：a[1]=a[ 1 ] 4 “ “ 值 a[ 2 ] 获取数组 a 的 2 为下标对应的值，上面已经有这个下标了，对应的值是 1 ，因此 a[ 1 ]=1 4</p>
<p>第二个字段：a[2]=a[2] 5 “ “ 同上，a[ 2 ]=2 5</p>
<p>第三个字段：a[3]=a[3] 6 “ “ 同上，a[ 2 ]= 3 6</p>
<p>读取第三行时处理方式同上，数组最后还是三个下标，分别是 1=1 4 7，2=2 5 8， 3 =3 6 9。最后 for 循环输出所有下标值。</p>
<p><strong>5 ）字符串拆分，统计出现的次数</strong></p>
<p>字符串拆分：</p>
<pre><code class="hljs bash">方法 1 ：
<span class="hljs-comment"># echo &quot;hello world&quot; |awk -F &#x27;&#x27;&#x27;&#123;print $1&#125;&#x27;</span>
h
<span class="hljs-comment"># echo &quot;hello&quot; |awk -F &#x27;&#x27;&#x27;&#123;for(i=1;i&lt;=NF;i++)print $i&#125;&#x27;</span>
h
e
l
l
o
方法 2 ：
<span class="hljs-comment"># echo &quot;hello&quot; |awk &#x27;&#123;split($0,a,&quot;&#x27;&#x27;&quot;);for(v in a)print a[v]&#125;&#x27;</span>
l
o
h
e
l</code></pre>

<p>统计字符串中每个字母出现的次数：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;a.b.c,c.d.e&quot; |awk -F &#x27;[.,]&#x27; &#x27;&#123;for(i=1;i&lt;=NF;i++)a[$i]++&#125;END&#123;for(v in a)printv,a[v]&#125;&#x27;</span>
a 1
b 1
c 2
d 1
e 1</code></pre>

<p><strong>6 ）统计平均成绩</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat file</span>
job 80
dave 84
tom 75
dave 73
job 72
tom 83
dave 88
<span class="hljs-comment"># awk &#x27;&#123;a[$1]+=$2;b[$1]++&#125;END&#123;for(i in a)print i,a[i]/b[i]&#125;&#x27; file</span>
job 76
dave 81.6667
tom 79</code></pre>

<p><strong>7 ）费用统计</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat file</span>
zhangsan 8000 1
zhangsan 5000 1
lisi 1000 1
lisi 2000 1
wangwu 1500 1
zhaoliu 6000 1
zhaoliu 2000 1
zhaoliu 3000 1
<span class="hljs-comment"># awk &#x27;&#123;name[$1]++;cost[$1]+=$2;number[$1]+=$3&#125;END&#123;for(v in name)printv,cost[v],number[v]&#125;&#x27; file</span>
zhangsan 5000 1
lisi 3000 2
wangwu 1500 1
zhaoliu 11000 3</code></pre>

<p><strong>8 ）获取数字字段最大值</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat file</span>
a b 1
c d 2
e f 3
g h 3
i j 2
获取第三字段最大值：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;max=0&#125;&#123;if($3&gt;max)max=$3&#125;END&#123;print max&#125;&#x27; file</span>
3
打印第三字段最大行：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;max=0&#125;&#123;a[$0]=$3;if($3&gt;max)max=$3&#125;END&#123;for(v in a)print v,a[v],max&#125;&#x27; a</span>
g h 3 3 3
e f 3 3 3
c d 2 2 3
a b 1 1 3
i j 2 2 3
<span class="hljs-comment"># awk &#x27;BEGIN&#123;max=0&#125;&#123;a[$0]=$3;if($3&gt;max)max=$3&#125;END&#123;for(v in a)if(a[v]==max)print v&#125;&#x27; a</span>
g h 3
e f 3</code></pre>

<p><strong>9 ）去除第一行和最后一行</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;NR&gt;2&#123;print s&#125;&#123;s=$0&#125;&#x27;</span>
2
3
4</code></pre>

<p>读取第一行，NR= 1 ，不执行 print s，s= 1</p>
<p>读取第二行，NR= 2 ，不执行 print s，s= 2 （大于为真）</p>
<p>读取第三行，NR= 3 ，执行 print s，此时 s 是上一次 p 赋值内容 2 ，s=3</p>
<p>最后一行，执行 print s，打印倒数第二行，s = 最后一行</p>
<p>获取 Nginx 负载均衡配置端 IP 和端口：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat nginx.conf</span>
upstream example-servers1 &#123;
server 127.0.0.1:80 weight=1 max_fails=2 fail_timeout=30s;


<span class="hljs-comment">##### &#125;</span>

upstream example-servers2 &#123;
server 127.0.0.1:80 weight=1 max_fails=2 fail_timeout=30s;
server 127.0.0.1:82 backup;
&#125;
<span class="hljs-comment"># awk &#x27;/example-servers1/,/&#125;/&#123;if(NR&gt;2)&#123;print s&#125;&#123;s=$2&#125;&#125;&#x27; nginx.conf</span>
127.0.0.1:80
<span class="hljs-comment"># awk &#x27;/example-servers1/,/&#125;/&#123;if(i&gt;1)print s;s=$2;i++&#125;&#x27; nginx.conf</span>
<span class="hljs-comment"># awk &#x27;/example-servers1/,/&#125;/&#123;if(i&gt;1)&#123;print s&#125;&#123;s=$2;i++&#125;&#125;&#x27; nginx.conf</span>
127.0.0.1:80</code></pre>

<p>读取第一行，i 初始值为 0 ，0&gt;1 为假，不执行 print s，x=example-servers1，i= 1</p>
<p>读取第二行，i= 1 ，1&gt;1 为假，不执行 print s，s=127.0.0.1:80,i=2</p>
<p>读取第三行，i=2，2&gt;1 为真，执行 print s，此时 s 是上一次 s 赋值内容 127.0.0.1:80，i= 3</p>
<p>最后一行，执行 print s，打印倒数第二行，s = 最后一行。</p>
<p>这种方式与上面一样，只是用 i++ 作为计数器。</p>
<p><strong>10 ）知道上述方式，就可以实现这种需求了，打印匹配行的上一行</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 5 |awk &#x27;/3/&#123;print s&#125;&#123;s=$0&#125;&#x27;</span>
2</code></pre>

<p>其他参考资料：<a target="_blank" rel="noopener" href="http://www.gnu.org/software/gawk/manual/gawk.html">http://www.gnu.org/software/gawk/manual/gawk.html</a></p>
<h1 id="八、-Shell-标准输入、输出和错误"><a href="#八、-Shell-标准输入、输出和错误" class="headerlink" title="八、 Shell 标准输入、输出和错误"></a>八、 Shell 标准输入、输出和错误</h1><p>文件描述符（fd）：文件描述符是一个非负整数，在打开现存文件或新建文件时，内核会返回一个文件描述符，读写文件也需要使用文件描述符来访问文件。</p>
<p>内核为每个进程维护该进程打开的文件记录表。文件描述符只适于 Unix、Linux 操作系统。</p>
<h2 id="8-1-标准输入、输出和错误"><a href="#8-1-标准输入、输出和错误" class="headerlink" title="8.1 标准输入、输出和错误"></a>8.1 标准输入、输出和错误</h2><table>
<thead>
<tr>
<th>文件描述符</th>
<th>描述</th>
<th>映射关系</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>标准输入，键盘</td>
<td>/dev/stdin -&gt; /proc/self/fd/0</td>
</tr>
<tr>
<td>1</td>
<td>标准输出，屏幕</td>
<td>/dev/stdout -&gt; /proc/self/fd/1</td>
</tr>
<tr>
<td>2</td>
<td>标准错误，屏幕</td>
<td>/dev/stderr -&gt; /proc/self/fd/2</td>
</tr>
</tbody></table>
<h2 id="8-2-重定向符号"><a href="#8-2-重定向符号" class="headerlink" title="8.2 重定向符号"></a>8.2 重定向符号</h2><table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>符号左边输出作为右边输入（标准输出）</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>符号左边输出追加右边输入</td>
</tr>
<tr>
<td>&lt;</td>
<td>符号右边输出作为左边输入（标准输入）</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>符号右边输出追加左边输入</td>
</tr>
<tr>
<td>&amp;</td>
<td>重定向绑定符号</td>
</tr>
</tbody></table>
<p>输入和输出可以被重定向符号解释到 shell。</p>
<p>shell 命令是从左到右依次执行命令。</p>
<p>下面 n 字母是文件描述符。</p>
<h2 id="8-3-重定向输出"><a href="#8-3-重定向输出" class="headerlink" title="8.3 重定向输出"></a>8.3 重定向输出</h2><p><strong>1 ）覆盖输出</strong></p>
<p>一般格式：[n]&gt;word</p>
<p>如果 n 没有指定，默认是 1</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">打印结果写到文件：
<span class="hljs-comment"># echo &quot;test&quot; &gt; a.txt</span>
当没有安装 bc 计算器时，错误输出结果写到文件：
<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc 2 &gt; error.log</span></code></pre>

<p><strong>2 ）追加重定向输出</strong></p>
<p>一般格式：[n]&gt;&gt;word</p>
<p>如果 n 没有指定，默认是 1</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">打印结果追加到文件：
<span class="hljs-comment"># echo &quot;test&quot; &gt;&gt; a.txt</span>
当没有安装 bc 计算器时，错误输出结果追加文件：
<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc 2 &gt; error.log</span></code></pre>

<h2 id="8-4-重定向输入"><a href="#8-4-重定向输入" class="headerlink" title="8.4 重定向输入"></a>8.4 重定向输入</h2><p>一般格式：[n]&lt;word</p>
<p>如果 n 没有指定，默认是 0</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">a.txt 内容作为 grep 输入：
<span class="hljs-comment"># grep &quot;test&quot; --color &lt; a.txt</span></code></pre>

<h2 id="8-5-重定向标准输出和标准错误"><a href="#8-5-重定向标准输出和标准错误" class="headerlink" title="8.5 重定向标准输出和标准错误"></a>8.5 重定向标准输出和标准错误</h2><p><strong>1 ）覆盖重定向标准输出和标准错误</strong></p>
<p>&amp;&gt;word 和 &gt;&amp;word 等价于 &gt;word 2&gt;&amp;1</p>
<p>&amp; 将标准输出和标准输入绑定到一起，重定向 word 文件。</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">当不确定执行对错时都覆盖到文件：
<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc &amp;&gt; error.log</span>
当不确定执行对错时都覆盖到文件：
<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc &gt; error.log 2&gt;&amp;1</span></code></pre>

<p><strong>2 ）追加重定向标准输出和标准错误</strong></p>
<p>&amp;&gt;&gt;word 等价于 &gt;&gt;word 2&gt;&amp;1</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">当不确定执行对错时都追加文件：
<span class="hljs-comment"># echo &quot;1 + 1&quot; |bc &amp;&gt;&gt; error.log</span></code></pre>

<p>将标准输出和标准输入追加重定向到 delimiter：</p>
<pre><code class="hljs bash">&lt;&lt; delimiter
here-document
delimiter</code></pre>

<p>从当前 shell 读取输入源，直到遇到一行只包含 delimiter 终止，内容作为标准输入。</p>
<p>将 eof 标准输入作为 cat 标准输出再写到 a.txt：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat &lt;&lt; eof</span>
123
abc
eof

123
abc
<span class="hljs-comment"># cat &gt; a.txt &lt;&lt; eof</span>
&gt; 123
&gt; abc
&gt; eof</code></pre>

<h2 id="8-6-重定向到空设备"><a href="#8-6-重定向到空设备" class="headerlink" title="8.6 重定向到空设备"></a>8.6 重定向到空设备</h2><p><code>/dev/null</code> 是一个空设备，向它写入的数组都会丢弃，但返回状态是成功的。与其对应的还有一个 <code>/dev/zero</code> 设备，提供无限的 0 数据流。</p>
<p>在写 Shell 脚本时我们经常会用到 <code>/dev/null</code> 设备，将 stdout、stderr 输出给它，也就是我们不想要这些输出的数据。</p>
<p>通过重定向到 <code>/dev/null</code> 忽略输出，比如我们没有安装 bc 计算器，正常会抛出没有发现命令：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;1 + 1&quot; |bc &gt;/dev/null 2&gt;&amp;1</span></code></pre>

<p>这就让标准和错误输出到了空设备。</p>
<p><strong>忽略标准输出：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;test&quot; &gt;/dev/null</span></code></pre>

<p><strong>忽略错误输出：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;1 + 1&quot; |bc 2&gt;/dev/null</span></code></pre>

<h2 id="8-7-read-命令"><a href="#8-7-read-命令" class="headerlink" title="8.7 read 命令"></a>8.7 read 命令</h2><p>read 命令从标准输入读取，并把输入的内容复制给变量。</p>
<p>命令格式： read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]</p>
<ul>
<li>-e: 在一个交互 shell 中使用 readline 获取行</li>
<li>-r: 不允许反斜杠转义任何字符</li>
<li>-s: 隐藏输入</li>
<li>-a array: 保存为数组，元素以空格分隔</li>
<li>-d delimiter: 持续读取直到遇到 delimiter 第一个字符退出</li>
<li>-n nchars: 读取 nchars 个字符返回，而不是等到换行符</li>
<li>-p prompt: 提示信息</li>
<li>-t timeout: 等待超时时间，秒</li>
<li>-u fd: 指定文件描述符号码作为输入，默认是 0</li>
<li>name: 变量名</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">获取用户输入保存到变量：
<span class="hljs-comment"># read -p &quot;Please input your name:&quot; VAR</span>
Please input your name: lizhenliang
<span class="hljs-comment"># echo $VAR</span>
lizhenliang
用户输入保存为数组：
<span class="hljs-comment"># read -p &quot;Please input your name:&quot; -a ARRAY</span>
Please input your name: a b c
<span class="hljs-comment"># echo $&#123;ARRAY[*]&#125;</span>
a b c
遇到 e 字符返回：
<span class="hljs-comment"># read -d e VAR</span>
123
456
e
<span class="hljs-comment"># echo $VAR</span>
123 456
从文件作为 <span class="hljs-built_in">read</span> 标准输入：
<span class="hljs-comment"># cat a.txt</span>
adfasfd
<span class="hljs-comment"># read VAR &lt; a.txt</span>
<span class="hljs-comment"># echo $VAR</span>
adfasfd
<span class="hljs-keyword">while</span> 循环读取每一行作为 <span class="hljs-built_in">read</span> 的标准输入：
<span class="hljs-comment"># cat a.txt |while read LINE; do echo $LINE; done</span>
123
abc
分别变量赋值：
<span class="hljs-comment"># read a b c</span>
1 2 3
<span class="hljs-comment"># echo $a</span>
1
<span class="hljs-comment"># echo $b</span>
2
<span class="hljs-comment"># echo $c</span>
3
<span class="hljs-comment"># echo 1 2 3 | while read a b c;do echo &quot;$a $b $c&quot;; done</span>
1 2 3</code></pre>

<h1 id="九、-Shell-信号发送与捕捉"><a href="#九、-Shell-信号发送与捕捉" class="headerlink" title="九、 Shell 信号发送与捕捉"></a>九、 Shell 信号发送与捕捉</h1><h2 id="9-1-Linux-信号类型"><a href="#9-1-Linux-信号类型" class="headerlink" title="9.1 Linux 信号类型"></a>9.1 Linux 信号类型</h2><p>信号（Signal）：信号是在软件层次上对中断机制的一种模拟，通过给一个进程发送信号，执行相应的处理函数。</p>
<p>进程可以通过三种方式来响应一个信号：</p>
<ul>
<li>1 ）忽略信号，即对信号不做任何处理，其中有两个信号不能忽略：SIGKILL 及 SIGSTOP。</li>
<li>2 ）捕捉信号。</li>
<li>3 ）执行缺省操作，Linux 对每种信号都规定了默认操作。</li>
</ul>
<p>Linux 究竟采用上述三种方式的哪一个来响应信号呢？取决于传递给响应的 API 函数。</p>
<p>Linux 支持的信号有：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>信号名称</th>
<th>缺省动作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>终止</td>
<td>终止进程，挂起</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止</td>
<td>键盘输入中断命令，一般是 CTRL+C</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>CoreDump</td>
<td>键盘输入退出命令，一般是 CTRL+\</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>CoreDump</td>
<td>非法指令</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>CoreDump</td>
<td>trap 指令发出，一般调试用</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>CoreDump</td>
<td>abort(3) 发出的终止信号</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>CoreDump</td>
<td>非法地址</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>CoreDump</td>
<td>浮点数异常</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止</td>
<td>立即停止进程，不能捕获，不能忽略</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSR1</td>
<td>终止</td>
<td>用户自定义信号 ^1 ，像 Nginx 就支持 USR1 信号，用于重载配 <br> 置，重新打开日志</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>CoreDump</td>
<td>无效内存引用</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>终止</td>
<td>用户自定义信号 2</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>终止</td>
<td>管道不能访问</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>终止</td>
<td>时钟信号，alrm(2) 发出的终止信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止</td>
<td>终止信号，进程会先关闭正在运行的任务或打开的文件再终 <br> 止，有时候有的进程在运行任务会忽略此信号。不能捕捉</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>终止</td>
<td>处理器栈错误</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>可忽略</td>
<td>子进程结束时，父进程收到的信号</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>可忽略</td>
<td>让终止的进程继续执行</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止</td>
<td>停止进程，不能忽略，不能捕获</td>
</tr>
<tr>
<td>20</td>
<td>SIGSTP</td>
<td>停止</td>
<td>停止进程，一般是 CTRL+Z</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>停止</td>
<td>后台进程从终端读数据</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>停止</td>
<td>后台进程从终端写数据</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>可忽略</td>
<td>紧急数组是否到达 socket</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>CoreDump</td>
<td>超出 CPU 占用资源限制</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>CoreDump</td>
<td>超出文件大小资源限制</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTALRM</td>
<td>终止</td>
<td>虚拟时钟信号，类似于 SIGALRM，但计算的是进程占用的时间</td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>终止</td>
<td>类似与 SIGALRM，但计算的是进程占用 CPU 的时间</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>可忽略</td>
<td>窗口大小改变发出的信号</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>终止</td>
<td>文件描述符准备就绪，可以输入 / 输出操作了</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>终止</td>
<td>电源失败</td>
</tr>
<tr>
<td>31</td>
<td>SIGSYS</td>
<td>CoreDump</td>
<td>非法系统调用</td>
</tr>
</tbody></table>
<p><strong>CoreDump（核心转储）</strong>：当程序运行过程中异常退出时，内核把当前程序在内存状况存储在一个 core 文件中，以便调试。执行命令 <code>ulimit -c</code> 如果是 0 则没有开启，也不会生成 core dump 文件，可通过 <code>ulimit -c unlimited</code> 命令临时开启 core dump 功能，只对当前终端环境有效，如果想永久生效，可修改 <code>/etc/security/limites.conf</code> 文件，添加一行 “* soft core unlimited” 默认生成的 core 文件保存在可执行文件所在的目录下，文件名为 core。如果想修改 core 文件保存路径，可通过修改内核参数：<code>echo &quot;/tmp/corefile-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern</code> 则文件名格式为 core- 命名名 -pid- 时间戳</p>
<p>Linux 支持两种信号：</p>
<p>一种是标准信号，编号 1 - 31 ，称为非可靠信号（非实时），不支持队列，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次，如果第一个信号没有处理完，第二个信号将会丢弃。</p>
<p>另一种是扩展信号，编号 32 - 64 ，称为可靠信号（实时），支持队列，发多少次进程就可以收到多少次。</p>
<p>信号类型比较多，我们只要了解下，记住几个常用信号就行了，红色标记的我觉得需要记下。</p>
<p>发送信号一般有两种情况：</p>
<p>一种是内核检测到系统事件，比如键盘输入 CTRL+C 会发送 SIGINT 信号。</p>
<p>另一种是通过系统调用 kill 命令来向一个进程发送信号。</p>
<h2 id="9-2-kill-命令"><a href="#9-2-kill-命令" class="headerlink" title="9.2 kill 命令"></a>9.2 kill 命令</h2><p>kill 命令发送信号给进程。</p>
<p>命令格式：kill [-s sigspec | -n signum | -sigspec] pid | jobspec … kill -l [sigspec]</p>
<ul>
<li>-s # 信号名称</li>
<li>-n # 信号编号</li>
<li>-l # 打印编号 1 - 31 信号名称</li>
</ul>
<p>示例：</p>
<pre><code class="hljs bash">给一个进程发送终止信号：
<span class="hljs-built_in">kill</span> - s SIGTERM pid
或
<span class="hljs-built_in">kill</span> - n 15 pid
或
<span class="hljs-built_in">kill</span> - 15 pid
或
<span class="hljs-built_in">kill</span> - TREM pid</code></pre>

<h2 id="9-3-trap-命令"><a href="#9-3-trap-命令" class="headerlink" title="9.3 trap 命令"></a>9.3 trap 命令</h2><p>trap 命令定义 shell 脚本在运行时根据接收的信号做相应的处理。</p>
<p>命令格式：trap [-lp] [[arg] signal_spec …]</p>
<ul>
<li>-l # 打印编号 1 - 64 编号信号名称</li>
<li>arg # 捕获信号后执行的命令或者函数</li>
<li>signal_spec # 信号名或编号</li>
</ul>
<p>一般捕捉信号后，做以下几个动作：</p>
<ul>
<li>1 ）清除临时文件</li>
<li>2 ）忽略该信号</li>
<li>3 ）询问用户是否终止脚本执行</li>
</ul>
<p><strong>示例 1 ：按 CTRL+C 不退出循环</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;&quot;</span> 2 <span class="hljs-comment"># 不指定 arg 就不做任何操作，后面也可以写多个信号，以空格分隔</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
sleep 1
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash a.sh</span>
1
2
3
^C4
5
6
^C7
8
9
10</code></pre>

<p><strong>示例 2 ：循环打印数字，按 CTRL+C 退出，并打印退出提示</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;echo&#x27;exit...&#x27;;exit&quot;</span> 2
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
sleep 1
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh</span>
1
2
3
^Cexit...</code></pre>

<p><strong>示例 3 ：让用户选择是否终止循环</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;func&quot;</span> 2
<span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;
  <span class="hljs-built_in">read</span> - p <span class="hljs-string">&quot;Terminate the process? (Y/N):&quot;</span> input
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$input</span> == <span class="hljs-string">&quot;Y&quot;</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">exit</span>
  <span class="hljs-keyword">fi</span>
&#125;

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
  sleep 1
<span class="hljs-keyword">done</span>

<span class="hljs-comment"># bash a.sh</span>
1
2
3
^CTerminate the process? (Y/N): Y
<span class="hljs-comment"># bash a.sh</span>
1
2
3
^CTerminate the process? (Y/N): N
4
5
6
...</code></pre>

<h1 id="十、-Shell-编程时常用的系统文件"><a href="#十、-Shell-编程时常用的系统文件" class="headerlink" title="十、 Shell 编程时常用的系统文件"></a>十、 Shell 编程时常用的系统文件</h1><h2 id="10-1-Linux-系统目录结构"><a href="#10-1-Linux-系统目录结构" class="headerlink" title="10.1 Linux 系统目录结构"></a>10.1 Linux 系统目录结构</h2><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>根目录，所有文件的第一级目录</td>
</tr>
<tr>
<td>/home</td>
<td>普通用户家目录</td>
</tr>
<tr>
<td>/root</td>
<td>超级用户家目录</td>
</tr>
<tr>
<td>/usr</td>
<td>用户命令、应用程序等目录</td>
</tr>
<tr>
<td>/var</td>
<td>应用数据、日志等目录</td>
</tr>
<tr>
<td>/lib</td>
<td>库文件和内核模块目录</td>
</tr>
<tr>
<td>/etc</td>
<td>系统和软件配置文件</td>
</tr>
<tr>
<td>/bin</td>
<td>可执行程序目录</td>
</tr>
<tr>
<td>/boot</td>
<td>内核加载所需的文件，grub 引导</td>
</tr>
<tr>
<td>/dev</td>
<td>设备文件目录，比如磁盘驱动</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时文件目录</td>
</tr>
<tr>
<td>/opt</td>
<td>第三方软件安装目录</td>
</tr>
</tbody></table>
<h2 id="10-2-环境变量文件"><a href="#10-2-环境变量文件" class="headerlink" title="10.2 环境变量文件"></a>10.2 环境变量文件</h2><h4 id="系统级"><a href="#系统级" class="headerlink" title="系统级"></a>系统级</h4><p>系统级变量文件对所有用户生效。</p>
<ul>
<li><code>/etc/profile</code> # 系统范围内的环境变量和启动文件。不建议把要做的事情写在这里面，最好创建一个自定义的，放在 <code>/etc/profile.d</code> 下</li>
<li><code>/etc/bashrc</code> # 系统范围内的函数和别名</li>
</ul>
<h4 id="用户级"><a href="#用户级" class="headerlink" title="用户级"></a>用户级</h4><p>用户级变量文件对自己生效，都在自己家目录下。</p>
<ul>
<li><code>~/.bashrc</code> # 用户指定别名和函数</li>
<li><code>~/.bash_logout</code> # 用户退出执行</li>
<li><code>~/.bash_profile</code> # 用户指定变量和启动程序</li>
<li><code>~/.bash_history</code> # 用户执行命令历史文件</li>
</ul>
<h4 id="开启启动脚本顺序："><a href="#开启启动脚本顺序：" class="headerlink" title="开启启动脚本顺序："></a>开启启动脚本顺序：</h4><p><code>/etc/profile -&gt; /etc/profile.d/*.sh -&gt; ~/.bash_profile -&gt; ~/.bashrc -&gt;/etc/bashrc</code></p>
<p>因此，我们可以把写的脚本放到以上文件里执行。</p>
<h3 id="10-3-系统配置文件"><a href="#10-3-系统配置文件" class="headerlink" title="10.3 系统配置文件"></a>10.3 系统配置文件</h3><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/etc/issue</td>
<td>系统版本</td>
</tr>
<tr>
<td>/etc/hosts</td>
<td>主机名与 IP 对应关系</td>
</tr>
<tr>
<td>/etc/resolv.conf</td>
<td>DNS 服务器地址</td>
</tr>
<tr>
<td>/etc/hostname</td>
<td>主机名</td>
</tr>
<tr>
<td>/etc/sysctl.conf</td>
<td>系统参数配置文件</td>
</tr>
<tr>
<td>/etc/sudoers</td>
<td>sudo 权限配置</td>
</tr>
<tr>
<td>/etc/init.d</td>
<td>服务启动脚本</td>
</tr>
<tr>
<td>/etc/sysconfig/network-scripts</td>
<td>网卡信息配置目录</td>
</tr>
<tr>
<td>/etc/rc.d/rc.local</td>
<td>系统 init 初始化完后执行，不建议将启动服务写在这里面，<br> 应创建自己的 systemd 或 udev</td>
</tr>
<tr>
<td>/etc/fstab</td>
<td>硬盘自动挂载配置</td>
</tr>
<tr>
<td>/etc/inittab</td>
<td>系统启动运行级别</td>
</tr>
<tr>
<td>/etc/crontab</td>
<td>系统级任务计划</td>
</tr>
<tr>
<td>/var/spool/cron</td>
<td>用户级任务计划，此目录下以用户名命名对应每个用户的任务计划</td>
</tr>
<tr>
<td>/etc/cron.d</td>
<td>描述计算机任务计划</td>
</tr>
<tr>
<td>/etc/hosts.allow</td>
<td>TCP 包访问列表</td>
</tr>
<tr>
<td>/etc/hosts.deny</td>
<td>TCP 包拒绝列表</td>
</tr>
<tr>
<td>/usr/share/doc</td>
<td>各软件的文档</td>
</tr>
<tr>
<td>/etc/sshd_config</td>
<td>SSH 服务配置文件</td>
</tr>
<tr>
<td>/var/log</td>
<td>系统和应用程序日志目录</td>
</tr>
<tr>
<td>/var/spool/mail</td>
<td>邮件目录</td>
</tr>
</tbody></table>
<p>crontab 任务计划说明：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># Example of job definition:</span>
<span class="hljs-comment"># .---------------- minute (0 - 59)</span>
<span class="hljs-comment"># | .------------- hour (0 - 23)</span>
<span class="hljs-comment"># | | .---------- day of month (1 - 31)</span>
<span class="hljs-comment"># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...</span>
<span class="hljs-comment"># | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR</span>
sun,mon,tue,wed,thu,fri,sat
<span class="hljs-comment"># | | | | |</span>
<span class="hljs-comment"># * * * * * user-name command to be executed</span></code></pre>

<h2 id="10-4-dev-目录"><a href="#10-4-dev-目录" class="headerlink" title="10.4 /dev 目录"></a>10.4 /dev 目录</h2><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/dev</td>
<td>目录下存放的是一些设备文件。</td>
</tr>
<tr>
<td>/dev/hd[a-t]</td>
<td>IDE 设备</td>
</tr>
<tr>
<td>/dev/sd[a-z]</td>
<td>SCSI 设备</td>
</tr>
<tr>
<td>/dev/dm-[-9]</td>
<td>LVM 逻辑磁盘</td>
</tr>
<tr>
<td>/dev/null</td>
<td>黑洞</td>
</tr>
<tr>
<td>/dev/zero</td>
<td>无限 0 数据流</td>
</tr>
</tbody></table>
<h2 id="10-5-proc-目录"><a href="#10-5-proc-目录" class="headerlink" title="10.5 /proc 目录"></a>10.5 /proc 目录</h2><p><code>/proc</code> 是一个虚拟目录，在 Linux 系统启动后生成的，数据存储在内存中，存放内核运行时的参数、网络信息、进程状态等等。</p>
<h3 id="10-5-1-proc"><a href="#10-5-1-proc" class="headerlink" title="10.5.1 /proc"></a>10.5.1 /proc</h3><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/proc/[0-9]+</td>
<td>此目录下数字命名的目录是运行进程信息，目录名为 PID</td>
</tr>
<tr>
<td>/proc/meminfo</td>
<td>物理内存、交换空间等信息，free</td>
</tr>
<tr>
<td>/proc/loadavg</td>
<td>系统负载</td>
</tr>
<tr>
<td>/proc/uptime</td>
<td>系统运行时间 <br> 计算系统启动时间：<br>date -d “$(awk -F.’{print $1}’/proc/uptime) second ago”<br>+”%Y-%m-%d %H:%M:%S” 或 who -b</td>
</tr>
<tr>
<td>/proc/cpuinfo</td>
<td>CPU 信息</td>
</tr>
<tr>
<td>/proc/modules</td>
<td>系统已加载的模块或驱动，lsmod</td>
</tr>
<tr>
<td>/proc/mounts</td>
<td>文件系统挂载信息，mount</td>
</tr>
<tr>
<td>/proc/swaps</td>
<td>swap 分区信息</td>
</tr>
<tr>
<td>/proc/partitions</td>
<td>系统分区信息</td>
</tr>
<tr>
<td>/proc/version</td>
<td>内核版本</td>
</tr>
<tr>
<td>/proc/stat</td>
<td>CPU 利用率，磁盘，内存页</td>
</tr>
<tr>
<td>/proc/devices</td>
<td>可用的设备列表</td>
</tr>
</tbody></table>
<h3 id="10-5-2-proc-net"><a href="#10-5-2-proc-net" class="headerlink" title="10.5.2 /proc/net"></a>10.5.2 /proc/net</h3><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/proc/net</td>
<td>目录存放的是一些网络协议信息。</td>
</tr>
<tr>
<td>/proc/net/tcp</td>
<td>TCP 状态连接信息，netstat</td>
</tr>
<tr>
<td>/proc/net/udp</td>
<td>UDP 状态连接信息</td>
</tr>
<tr>
<td>/proc/net/arp</td>
<td>arp 信息表</td>
</tr>
<tr>
<td>/proc/net/dev</td>
<td>网卡流量</td>
</tr>
<tr>
<td>/proc/net/snmp</td>
<td>网络传输协议的收发包信息</td>
</tr>
<tr>
<td>/proc/net/sockstat</td>
<td>socket 使用情况，比如已使用，正在使用</td>
</tr>
<tr>
<td>/proc/net/netstat</td>
<td>网络统计数据，netstat -s</td>
</tr>
<tr>
<td>/proc/net/route</td>
<td>路由表</td>
</tr>
</tbody></table>
<h3 id="10-5-3-proc-sys"><a href="#10-5-3-proc-sys" class="headerlink" title="10.5.3 /proc/sys"></a>10.5.3 /proc/sys</h3><p>这个目录下的文件可被读写，存了大多数内核参数，可以修改改变内核行为。所以修改这些文件要特别小心，修改错误可能导致内核不稳定。</p>
<p>有四个主要的目录：</p>
<ul>
<li>fs # 文件系统各方面信息，包括配额、文件句柄、inode 和目录项。</li>
<li>kernel # 内核行为的信息</li>
<li>net # 网络配置信息，包括以太网、ipx、ipv4 和 ipv6。</li>
<li>vm # Linux 内核的虚拟内存子系统，通常称为交换空间。</li>
</ul>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/proc/sys/fs/file-max</td>
<td>内核分配所有进程最大打开文件句柄数量，可 <br> 适当增加此值</td>
</tr>
<tr>
<td>/proc/sys/fs/file-nr</td>
<td>只读，第一个值已分配的文件句柄数量，第二 <br> 个值分配没有使用文件句柄数量，第三个值文 &lt; br &gt; 件句柄最大数量。lsof</td>
</tr>
<tr>
<td>/proc/sys/kernel/ctrl-alt-del</td>
<td>组合键重启计算机，只为 0 同步缓冲区到磁盘，<br>1 为不同步</td>
</tr>
<tr>
<td>/proc/sys/kernel/domainname</td>
<td>配置系统域名</td>
</tr>
<tr>
<td>/proc/sys/kernel/exec-shield</td>
<td>配置内核执行保护功能，防止某类型缓冲区溢 <br> 出攻击。 0 为禁用， 1 开启</td>
</tr>
<tr>
<td>/proc/sys/kernel/hostname</td>
<td>配置系统主机名</td>
</tr>
<tr>
<td>/proc/sys/kernel/osrelease</td>
<td>内核版本号</td>
</tr>
<tr>
<td>/proc/sys/kernel/ostype</td>
<td>操作系统类型</td>
</tr>
<tr>
<td>/proc/sys/kernel/shmall</td>
<td>设置共享内存的总量，以字节为单位</td>
</tr>
<tr>
<td>/proc/sys/kernel/shmmax</td>
<td>设置最大共享内存段</td>
</tr>
<tr>
<td>/proc/sys/kernel/shmmni</td>
<td>设置共享内存段最大数量</td>
</tr>
<tr>
<td>/proc/sys/kernel/threads-max</td>
<td>设置最大允许线程数量</td>
</tr>
<tr>
<td>/proc/sys/kernel/pid_max</td>
<td>设置最大允许创建的 pid 数量</td>
</tr>
<tr>
<td>/proc/sys/kernel/version</td>
<td>显示最后一次编译内核时间</td>
</tr>
<tr>
<td>/proc/sys/kernel/random/uuid</td>
<td>生成 uuid</td>
</tr>
<tr>
<td>/proc/sys/kernel/core_pattern</td>
<td>控制生成 core dump 文件位置和保存格式</td>
</tr>
<tr>
<td>/proc/sys/net/core/netdev_max_backlog</td>
<td>设置数据包队列允许最大数量</td>
</tr>
<tr>
<td>/proc/sys/net/core/optmem_max</td>
<td>设置 socket 允许最大缓冲区大小</td>
</tr>
<tr>
<td>/proc/sys/net/core/somaxconn</td>
<td>每个端口最大监听队列长度</td>
</tr>
<tr>
<td>/proc/sys/net/core/rmem_default</td>
<td>设置 socket 接收默认缓冲区大小，单位字节</td>
</tr>
<tr>
<td>/proc/sys/net/core/rmem_max</td>
<td>设置 socket 接收最大缓冲区大小</td>
</tr>
<tr>
<td>/proc/sys/net/core/wmem_default</td>
<td>设置 socket 发送默认缓冲区大小</td>
</tr>
<tr>
<td>/proc/sys/net/core/wmem_max</td>
<td>设置 socket 发送最大缓冲区大小</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/icmp_echo_ignore_all<br> 和 icmp_echo_ignore_broadcasts</td>
<td>设置是否忽略 icmp 响应包和广播包， 0 为不忽 &lt; br &gt; 略， 1 为忽略</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/ip_default_ttl</td>
<td>设置默认生存时间</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/ip_forward</td>
<td>允许系统接口转发数据包，默认 0 为关闭，1 为 <br> 开启</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/ip_local_port_range</td>
<td>指定使用本地 TCP 或 UDP 端口范围，第一个值 <br> 最低，第二个值最高</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_syn_retries</td>
<td>限制重新发送 syn 尝试建立连接次数</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_synack_retries</td>
<td>syn ack 确认包尝试次数</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_syncookies</td>
<td>是否启用 syn cookie， 0 为关闭，默认 1 为开 <br> 启</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_max_tw_buckets</td>
<td>系统保持 TIME_WAIT 最大数量</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_tw_recycle</td>
<td>是否启用 TIME_WAIT 快速收回，默认 0 为关闭，<br>1 为开启</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_tw_reuse</td>
<td>是否启用 TIME_WAIT 复用，默认 0 为关闭， 1<br> 为开启</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_keepalive_time</td>
<td>TCP 连接保持时间（默认 ^2 小时），当连接活动，<br> 定时器会重新复位。</td>
</tr>
<tr>
<td>/proc/sys/vm/swappiness</td>
<td>内核按此值百分比来使用 swap，值越小越不考 <br> 虑使用物理内存， 0 为尽可能不使用 swap</td>
</tr>
<tr>
<td>/proc/sys/vm/overcommit_memory</td>
<td>控制内存分配，默认 0 为内核先评估可用内存，<br> 如果足够允许申请，否则拒绝， 1 为允许分配 &lt; br &gt; 所有物理内存， 2 为允许分配超过物理内存和 &lt; br &gt; 交换空间总和的内存</td>
</tr>
<tr>
<td>/proc/sys/vm/overcommit_ratio</td>
<td>指定物理内存比率，当 overcommit_memory=2<br> 时，用户空间进程可使用的内存不超过物理内 &lt; br &gt; 存 * overcommit_ratio+swap</td>
</tr>
</tbody></table>
<p><strong>参考资料：</strong><br><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-">https://access.redhat.com/documentation/en-</a><br>US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s2-proc-dir-sys.html</p>
<h1 id="十一、-Shell-常用命令与工具"><a href="#十一、-Shell-常用命令与工具" class="headerlink" title="十一、 Shell 常用命令与工具"></a>十一、 Shell 常用命令与工具</h1><p>本章节学习一些在编写 Shell 时的常用命令或工具及使用技巧。有人说 Shell 脚本是命令堆积的一个文件，按顺序去执行。还有人说想学好 Shell 脚本，要把 Linux 上各种常见的命令或工具掌握了，这些说法都没错。由于 Shell 语言本身在语法结构上比较简单，是面向过程编程，想实现复杂的功能有点强人所难！而且 Shell 本身又工作在 Linux 内核之上，在用户态调用 Linux 命令会很方面，所以大多数情况下我们都是依靠这些命令来完成脚本中的某些功能，比如文本处理、获取系统状态等等，然后通过 Shell 语法结构组织代码逻辑。不管是学 Linux 系统好还是写 Shell 脚本也好，有些命令都是必须要会的，以下是根据个人经验总结的一些常用的命令。</p>
<p>怎么更好的学习命令呢？</p>
<p>当然查看官方帮助文档了，可以通过 man cmd、cmd –help、help cmd、info cmd 等方式查看命令的使用。</p>
<h2 id="11-1-ls"><a href="#11-1-ls" class="headerlink" title="11.1 ls"></a>11.1 ls</h2><p>功能：列出目录内容</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-a 显示所有文件，包括隐藏的</li>
<li>-l 长格式列出信息</li>
<li>-i 显示文件 inode 号</li>
<li>-t 按修改时间排序</li>
<li>-r 按修改时间倒序排序</li>
<li>-h 打印易读大小单位</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">按修改时间排序：
<span class="hljs-comment"># ls - t</span>
按修改时间倒序排序：
<span class="hljs-comment"># ls - rt</span>
长格式列出：
<span class="hljs-comment"># ls - lh</span>
查看文件 inode：
<span class="hljs-comment"># ls - i file</span></code></pre>

<h2 id="11-2-echo"><a href="#11-2-echo" class="headerlink" title="11.2 echo"></a>11.2 echo</h2><p>功能：打印一行</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-n 不加换行符</li>
<li>-e 解释转义符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">解释换行符：
<span class="hljs-comment"># echo - e &quot;1\n2\n3&quot;</span>
1
2
3</code></pre>

<h2 id="11-3-printf"><a href="#11-3-printf" class="headerlink" title="11.3 printf"></a>11.3 printf</h2><p>功能：格式化打印数据。默认打印字符串不换行。</p>
<p><strong>格式</strong>：printf format [arguments]</p>
<table>
<thead>
<tr>
<th>Format</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>一个字符串</td>
</tr>
<tr>
<td>%d，%i</td>
<td>一个小数</td>
</tr>
<tr>
<td>%f</td>
<td>一个浮点数</td>
</tr>
<tr>
<td>%.ns</td>
<td>输出字符串，n 是输出几个字符</td>
</tr>
<tr>
<td>%m.nf</td>
<td>输出浮点数，m 是输出整数位数，n 是输出的小数位数</td>
</tr>
<tr>
<td>%x</td>
<td>不带正负号的十六进制，使用 a 至 f 表示 10 到 15</td>
</tr>
<tr>
<td>%X</td>
<td>不带正负号的十六进制，使用 A 至 F 表示 10 至 15</td>
</tr>
<tr>
<td>%%</td>
<td>输出单个 %</td>
</tr>
<tr>
<td>%-5s</td>
<td>左对齐，对参数每个字段左对齐, 宽度为 5</td>
</tr>
<tr>
<td>%-4.2f</td>
<td>左对齐，宽度为 4 ，保留两位小数</td>
</tr>
<tr>
<td>%5s</td>
<td>右对齐，不加横线表示右对齐</td>
</tr>
</tbody></table>
<p>一些常用的空白符：</p>
<ul>
<li>\n 换行</li>
<li>\r 回车</li>
<li>\t 水平制表符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">输出一个字符：
<span class="hljs-comment"># printf &quot;%.1s&quot; abc</span>
a
保留一个小数点：
<span class="hljs-comment"># printf &quot;%.1f&quot; 1.333</span>
1.3
输出换行：
<span class="hljs-comment"># printf &quot;%.1f\n&quot; 1.333</span>
1.3
格式化输出：
<span class="hljs-comment"># printf &quot;user: %s\tpass: %d\n&quot; abc 123</span>
user: abc pass: 1
左对齐宽度 10 ：
<span class="hljs-comment"># printf &quot;%-10s %-10s %-10s\n&quot; ID Name Number</span>
ID Name Number
右对齐宽度 10 ：
<span class="hljs-comment"># printf &quot;%10s %10s %10s\n&quot; ID Name Number</span>
ID Name Number
每段对齐：
<span class="hljs-comment"># printf &quot;%10s\n&quot; ID Name Number</span>
ID
Name
Number
<span class="hljs-comment"># printf &quot;%-10s\n&quot; ID Name Number</span>
ID
Name
Number</code></pre>

<h2 id="11-4-cat"><a href="#11-4-cat" class="headerlink" title="11.4 cat"></a>11.4 cat</h2><p>功能：连接文件和标准输出打印</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-b 显示非空行行号</li>
<li>-n 显示所有行行号</li>
<li>-T 显示 tab，用 ^I 表示</li>
<li>-E 显示以 $ 结尾</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">连接两个文件：
<span class="hljs-comment"># cat a b</span>
<span class="hljs-comment"># cat &lt;&lt; EOF</span>
&gt; 123
&gt; abc
&gt; EOF
123
abc
将 eof 标准输入作为 cat 标准输出再写到 a.txt：
<span class="hljs-comment"># cat &gt; a.txt &lt;&lt; eof</span>
&gt; 123
&gt; abc
&gt; eof</code></pre>

<h2 id="11-5-tac"><a href="#11-5-tac" class="headerlink" title="11.5 tac"></a>11.5 tac</h2><p>功能：连接文件和倒序打印文件</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">倒序打印每一行：
<span class="hljs-comment"># tac a.txt</span></code></pre>

<h2 id="11-6-rev"><a href="#11-6-rev" class="headerlink" title="11.6 rev"></a>11.6 rev</h2><p>功能：反向打印每一行</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># echo &quot;123&quot; |rev</span>
321</code></pre>

<h2 id="11-7-wc"><a href="#11-7-wc" class="headerlink" title="11.7 wc"></a>11.7 wc</h2><p>功能：统计文件行数、字节、字符数</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-c 打印文件字节数，一个英文字母 1 字节，一个汉字占 2 - 4 字节（根据编码）</li>
<li>-m 打印文件字符数，一个汉字占 2 个字符</li>
<li>-l 打印多少行</li>
<li>-L 打印最长行的长度，也可以统计字符串长度</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">统计文件多少行：
<span class="hljs-comment"># wc - l file</span>
统计字符串长度：
<span class="hljs-comment"># echo &quot;hello&quot; |wc - L</span>
5</code></pre>

<h2 id="11-8-cp"><a href="#11-8-cp" class="headerlink" title="11.8 cp"></a>11.8 cp</h2><p>功能：复制文件或目录</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-a 归档</li>
<li>-b 目标文件存在创建备份，备份文件是文件名跟~</li>
<li>-f 强制复制文件或目录</li>
<li>-r 递归复制目录</li>
<li>-p 保留原有文件或目录属性</li>
<li>-i 覆盖文件之前先询问用户</li>
<li>-u 当源文件比目的文件修改时间新时才复制</li>
<li>-v 显示复制信息</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">复制目录：
<span class="hljs-comment"># cp - rf test /opt</span></code></pre>

<h2 id="11-9-mkdir"><a href="#11-9-mkdir" class="headerlink" title="11.9 mkdir"></a>11.9 mkdir</h2><p>功能：创建目录</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-p 递归创建目录</li>
<li>-v 显示创建过程</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">创建多级目录：
<span class="hljs-comment"># mkdir /opt/test/abc</span>
创建多个目录：
<span class="hljs-comment"># mkdir &#123;install,tmp&#125;</span>
创建连续目录：
<span class="hljs-comment"># mkdir &#123;a..c&#125;</span></code></pre>

<h2 id="11-10-mv"><a href="#11-10-mv" class="headerlink" title="11.10 mv"></a>11.10 mv</h2><p>功能：移动文件或重命名</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-b 目标文件存在创建备份，备份文件是 “文件名后跟~”</li>
<li>-u 当源文件比目的文件修改时间新时才移动</li>
<li>-v 显示移动信息</li>
</ul>
<p>示例：</p>
<pre><code class="hljs bash">移动文件：
<span class="hljs-comment"># mv a.txt /opt</span>
重命名文件：
<span class="hljs-comment"># mv a.txt b.txt</span></code></pre>

<h2 id="11-11-rename"><a href="#11-11-rename" class="headerlink" title="11.11 rename"></a>11.11 rename</h2><p>功能：重命名文件，支持通配符</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">批量命名文件
将 foo1-foo9 替换为 foo01-foo09：
<span class="hljs-comment"># rename foo foo0 foo?</span>
将以. htm 后缀的文件替换为. html：
<span class="hljs-comment"># rename .htm .html *.htm</span></code></pre>

<h2 id="11-12-dirname"><a href="#11-12-dirname" class="headerlink" title="11.12 dirname"></a>11.12 dirname</h2><p>功能：去除路径的最后一个名字</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># dirname /usr/bin/</span>
/usr
<span class="hljs-comment"># dirname dir1/str dir2/str</span>
dir1
dir2
<span class="hljs-comment"># dirname stdio.h</span></code></pre>

<h2 id="11-13-basename"><a href="#11-13-basename" class="headerlink" title="11.13 basename"></a>11.13 basename</h2><p>功能：打印路径的最后一个名字</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-a 支持多个参数</li>
<li>-s 删除后面的后缀</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># basename /usr/bin/sort</span>
sort
<span class="hljs-comment"># basename include/stdio.h .h</span>
stdio
<span class="hljs-comment"># basename -s .h include/stdio.h</span>
stdio
<span class="hljs-comment"># basename -a any/str1 any/str2</span>
str1
str2</code></pre>

<h2 id="11-14-du"><a href="#11-14-du" class="headerlink" title="11.14 du"></a>11.14 du</h2><p>功能：估算文件磁盘空间使用</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-h 易读格式显示（K，M，G）</li>
<li>-b 单位 bytes 显示</li>
<li>-k 单位 KB 显示</li>
<li>-m 单位 MB 显示</li>
<li>-s 只显示总大小</li>
<li>–max-depth=&lt;目录层数&gt;，超过层数的目录忽略</li>
<li>–exclude=file 排除文件或目录</li>
<li>–time 显示大小和创建时间</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">查看目录大小：
<span class="hljs-comment"># du -sh /opt</span>
排除目录某个文件：
<span class="hljs-comment"># du -sh --exclude=test /opt</span></code></pre>

<h2 id="11-15-cut"><a href="#11-15-cut" class="headerlink" title="11.15 cut"></a>11.15 cut</h2><p>功能：选取文件的每一行数据</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-b 选中第几个字符</li>
<li>-c 选中多少个字符</li>
<li>-d 指定分隔符分字段，默认是空格</li>
<li>-f 显示选中字段</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">打印 b 字符：
<span class="hljs-comment"># echo &quot;abc&quot; |cut - b &quot;2&quot;</span>
b
截取 abc 字符：
<span class="hljs-comment"># echo &quot;abcdef&quot; |cut - c 1 - 3</span>
abc
以冒号分隔，显示第二个字段：
<span class="hljs-comment"># echo &quot;a:b:c&quot; |cut - d: - f2</span>
b</code></pre>

<h2 id="11-16-tr"><a href="#11-16-tr" class="headerlink" title="11.16 tr"></a>11.16 tr</h2><p>功能：替换或删除字符</p>
<p><strong>格式：</strong>Usage: tr [OPTION]… SET1 [SET2]</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-c 替换 SET1 没有 SET2 的字符</li>
<li>-d 删除 SET1 中字符</li>
<li>-s 压缩 SET1 中重复的字符</li>
<li>-t 将 SET1 用 SET2 转换，默认</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">替换 SET1 没有 SET2 的字符：
<span class="hljs-comment"># echo &quot;aaabbbccc&quot; | tr -c c 1</span>
111111ccc
去重字符：
<span class="hljs-comment"># echo &quot;aaacccddd&quot; | tr -s &#x27;[a-z]&#x27;</span>
acd
删除字符：
<span class="hljs-comment"># echo &quot;aaabbbccc&quot; | tr -d bbb</span>
aaaccc
删除换行符：
<span class="hljs-comment"># echo -e &quot;a\nb\nc&quot; | tr -d &#x27;\n&#x27;</span>
abc
替换字符：
<span class="hljs-comment"># echo &quot;aaabbbccc&quot; | tr &#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;</span>
AAABBBCCC</code></pre>

<h2 id="11-17-stat"><a href="#11-17-stat" class="headerlink" title="11.17 stat"></a>11.17 stat</h2><p>功能：显示文件或文件的系统状态</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-Z 显示 selinux 安全上下文</li>
<li>-f 显示文件系统状态</li>
<li>-c 指定格式输出内容</li>
<li>-t 以简洁的形式打印</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">显示文件信息：
<span class="hljs-comment"># stat file</span>
只显示文件修改时间：
<span class="hljs-comment"># stat -c %y file</span></code></pre>

<h2 id="11-18-seq"><a href="#11-18-seq" class="headerlink" title="11.18 seq"></a>11.18 seq</h2><p>功能：打印序列化数字</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>f 使用 printf 样式格式</li>
<li>s 指定换行符，默认是 \ n</li>
<li>w 等宽，用 0 填充</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">数字序列：
<span class="hljs-comment"># seq 3</span>
1
2
3
带 0 的数字序列：
<span class="hljs-comment"># seq - w 03</span>
01
02
03
范围数字序列：
<span class="hljs-comment"># seq 2 5</span>
2
3
4
5
步长序列：
<span class="hljs-comment"># seq 1 2 5 # 2 是步长</span>
1
3
5
以冒号分隔序列：
<span class="hljs-comment"># seq -s &quot;+&quot; 5</span>
1+2+3+4+5
等宽并在数字前面加字符串：
<span class="hljs-comment"># seq -f &quot;str%02g&quot; 3 # %g 是默认数字位数， 02 是数字不足 2 位时用 0 填充。</span>
str01
str02
str03</code></pre>

<h2 id="11-19-shuf"><a href="#11-19-shuf" class="headerlink" title="11.19 shuf"></a>11.19 shuf</h2><p>功能：生成随机序列</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-i 输出数字范围</li>
<li>-o 结果写入文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">输出范围随机数：
<span class="hljs-comment"># seq 5 |shuf</span>
2
1
5
4
3
<span class="hljs-comment"># shuf -i 5-10</span>
8
10
7
9
6
5</code></pre>

<h2 id="11-20-sort"><a href="#11-20-sort" class="headerlink" title="11.20 sort"></a>11.20 sort</h2><p>功能：排序文本，默认对整列有效</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-f 忽略字母大小写</li>
<li>-M 根据月份比较，比如 JAN、DEC</li>
<li>-h 根据易读的单位大小比较，比如 2K、1G</li>
<li>-g 按照常规数值排序</li>
<li>-n 根据字符串数值比较</li>
<li>-r 倒序排序</li>
<li>-k 位置 1, 位置 2 根据关键字排序，在从第位置 1 开始，位置 2 结束</li>
<li>t 指定分隔符</li>
<li>u 去重重复行</li>
<li>o 将结果写入文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">随机数字排序：
<span class="hljs-comment"># seq 5 |shuf |sort</span>
随机字母排序：
<span class="hljs-comment"># printf &quot;%c\n&quot; &#123;a..f&#125; |shuf |sort</span>
倒序排序：
<span class="hljs-comment"># seq 5 |shuf |sort - r</span>
分隔后的字段排序：
<span class="hljs-comment"># cat /etc/passwd |sort -t : -k 3 -n</span>
去重重复行：
<span class="hljs-comment"># echo -e &quot;1\n1\n2\n3\n3&quot; |sort -u</span>
大小单位排序：
<span class="hljs-comment"># du -h |sort -k 1 -h -r</span>
分隔后第一个字段的第二个字符排序：
<span class="hljs-comment"># echo -e &quot;fa:1\neb:2\ncc:3&quot; |sort -t : -k 1.2</span>
tab 作为分隔符：
<span class="hljs-comment"># sort -t $&quot;\t&quot;</span>
file 文件内容：
zhangsan 6 100
lisi 8 80
wangwu 7 90
zhaoliu 9 70
对 file 文件的第二列正序排序，再次基础再对第三列倒序排序（多列排序）：
<span class="hljs-comment"># sort -k 2,2 -n -k 3,3 -nr file</span>
<span class="hljs-comment"># sort -k 2 -n -k 3 -nr file</span>
zhaoliu 9 70
lisi 8 80
wangwu 7 90
zhangsan 6 100
对两个文件同时排序：
<span class="hljs-comment"># sort file1 file2</span></code></pre>

<h2 id="11-21-uniq"><a href="#11-21-uniq" class="headerlink" title="11.21 uniq"></a>11.21 uniq</h2><p>功能：去除重复行, 只会统计相邻的</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-c 打印出现的次数</li>
<li>-d 只打印重复行</li>
<li>-u 只打印不重复行</li>
<li>-D 只打印重复行，并且把所有重复行打印出来</li>
<li>-f N 比较时跳过前 N 列</li>
<li>-i 忽略大小写</li>
<li>-s N 比较时跳过前 N 个字符</li>
<li>-w N 对每行第 N 个字符以后内容不做比较</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">测试文本如下：
<span class="hljs-comment"># cat file</span>
abc
cde
xyz
cde
xyz
abd
去重复行：
<span class="hljs-comment"># sort file |uniq</span>
abc
abd
cde
xyz
打印每行重复次数：
<span class="hljs-comment"># sort file |uniq -c</span>
1 abc
1 abd
2 cde
2 xyz
打印不重复行：
<span class="hljs-comment"># sort file |uniq -u</span>
abc
abd
打印重复行：
<span class="hljs-comment"># sort file |uniq -d</span>
cde
xyz
打印重复行并统计出现次数：
<span class="hljs-comment"># sort file |uniq -d -c</span>
2 cde
2 xyz
根据前几个字符去重：
<span class="hljs-comment"># sort file |uniq -w 2</span>
abc
cde
xyz</code></pre>

<h2 id="11-22-tee"><a href="#11-22-tee" class="headerlink" title="11.22 tee"></a>11.22 tee</h2><p>功能：从标准输入读取写到标准输出和文件</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-a 追加到文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">打印并追加到文件：
<span class="hljs-comment"># echo 123 |tee -a a.log</span></code></pre>

<h2 id="11-23-join"><a href="#11-23-join" class="headerlink" title="11.23 join"></a>11.23 join</h2><p>功能：连接两个文件</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-i 忽略大小写</li>
<li>-o 按照指定文件栏位显示</li>
<li>-t 使用字符作为输入和输出字段分隔符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat file1</span>
1 a
2 b
3 c
<span class="hljs-comment"># cat file2</span>
1 x
2 y
3 z
将两个文件相同字段合并一列：
<span class="hljs-comment"># join file1 file2</span>
1 a x
2 b y
3 c z
打印 file1 第二列和 file2 第二列：
<span class="hljs-comment"># join -o 1.2 2.2 file1 file2</span>
a x
b y
c z
<span class="hljs-comment"># join -t &#x27;:&#x27; -o 1.1 2.1 /etc/passwd /etc/shadow</span>
user1:user1</code></pre>

<h2 id="11-24-paste"><a href="#11-24-paste" class="headerlink" title="11.24 paste"></a>11.24 paste</h2><p>功能：合并文件</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-d 指定分隔符，默认是 tab 键分隔</li>
<li>-s 将文件内容平行合并，默认 tab 键分隔</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># seq 1 3 &gt; file1</span>
<span class="hljs-comment"># seq 4 6 &gt; file2</span>
两个文件合并：
<span class="hljs-comment"># paste file1 file2</span>
1 4
2 5
3 6
两个文件合并，+ 号分隔：
<span class="hljs-comment"># paste -d &quot;+&quot; file1 file2</span>
1+4
2+5
3+6
文件内容平行显示：
<span class="hljs-comment"># paste -s file1 file2</span>
1 2 3
4 5 6</code></pre>

<h2 id="11-25-head"><a href="#11-25-head" class="headerlink" title="11.25 head"></a>11.25 head</h2><p>功能：输出文件的前几行</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-c 打印前多少 K，M</li>
<li>-n 打印前多少行</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">打印文件前 50 行：
<span class="hljs-comment"># head -n 50 file</span></code></pre>

<h2 id="11-26-tail"><a href="#11-26-tail" class="headerlink" title="11.26 tail"></a>11.26 tail</h2><p>功能：输出文件的后几行</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-c 打印后多少 K，M</li>
<li>-f 实时读文件，随着文件输出附加输出</li>
<li>-n 输出最后几行</li>
<li>–pid 与 - f 一起使用，表示 pid 死掉后结束</li>
<li>-s 与 - f 一起使用，表示休眠多少秒输出</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">打印文件后 50 行：
<span class="hljs-comment"># tail -n 50 file</span>
实时输出新增行：
<span class="hljs-comment"># tail -f file</span></code></pre>

<h2 id="11-27-find"><a href="#11-27-find" class="headerlink" title="11.27 find"></a>11.27 find</h2><p>功能：目录层次结构中搜索文件</p>
<p>格式：find path -option actions</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-name 文件名，支持 (‘*’, ‘?’)</li>
<li>-type 文件类型，d 目录，f 常规文件等</li>
<li>-perm 符合权限的文件，比如 755</li>
<li>-atime -/+n 在 n 天以内 / 过去 n 天被访问过</li>
<li>-ctime -/+n 在 n 天以内 / 过去 n 天被修改过</li>
<li>-amin -/+n 在 n 天以内 / 过去 n 分钟被访问过</li>
<li>-cmin -/+n 在 n 天以内 / 过去 n 分钟被修改过</li>
<li>-size -/+n 文件大小小于 / 大于，b、k、M、G</li>
<li>-maxdepth levels 目录层次显示的最大深度</li>
<li>-regex pattern 文件名匹配正则表达式模式</li>
<li>-inum 通过 inode 编号查找文件</li>
</ul>
<p><strong>动作：</strong></p>
<ul>
<li>-detele 删除文件</li>
<li>-exec command {} ; 执行命令，花括号代表当前文件</li>
<li>-ls 列出当前文件，ls -dils 格式</li>
<li>-print 完整的文件名并添加一个回车换行符</li>
<li>-print0 打印完整的文件名并不添加一个回车换行符</li>
<li>-printf format 打印格式</li>
</ul>
<p><strong>其他字符：</strong><br>！ 取反</p>
<ul>
<li>-or/-o 逻辑或</li>
<li>-and 逻辑和</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">查找文件名：
<span class="hljs-comment"># find / -name &quot;*http*&quot;</span>
查找文件名并且文件类型：
<span class="hljs-comment"># find /tmp -name core -type f -print</span>
查找文件名并且文件类型删除：
<span class="hljs-comment"># find /tmp -name core -type f -delete</span>
查找当前目录常规文件并查看文件类型：
<span class="hljs-comment"># find. -type f -exec file &#x27;&#123;&#125;&#x27; \;</span>
查找文件权限是 664 ：
<span class="hljs-comment"># find. -perm 664</span>
查找大于 1024k 的文件：
<span class="hljs-comment"># find. -size -1024k</span>
查找 3 天内修改的文件：
<span class="hljs-comment"># find /bin -ctime -3</span>
查找 3 分钟前修改的文件：
<span class="hljs-comment"># find /bin -cmin +3</span>
排除多个类型的文件：
<span class="hljs-comment"># find.! -name &quot;*.sql&quot;! -name &quot;*.txt&quot;</span>
或条件查找多个类型的文件：
<span class="hljs-comment"># find. -name &#x27;*.sh&#x27; -o -name &#x27;*.bak&#x27;</span>
<span class="hljs-comment"># find. -regex &quot;.*\.sh\|.*\.bak&quot;</span>
<span class="hljs-comment"># find. -regex &quot;.*\.\(sh\|bak\)&quot;</span>
并且条件查找文件：
<span class="hljs-comment"># find. -name &quot;*.sql&quot; -a -size +1024k</span>
只显示第一级目录：
<span class="hljs-comment"># find /etc -type d -maxdepth 1</span>
通过 inode 编号删除文件：
<span class="hljs-comment"># rm `find. -inum 671915`</span>
<span class="hljs-comment"># find. -inum 8651577 -exec rm -i &#123;&#125; \;</span></code></pre>

<h2 id="11-28-xargs"><a href="#11-28-xargs" class="headerlink" title="11.28 xargs"></a>11.28 xargs</h2><p>功能：从标准输入执行命令</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-a file 从指定文件读取数据作为标准输入</li>
<li>-0 处理包含空格的文件名, print0</li>
<li>-d delimiter 分隔符，默认是空格分隔显示</li>
<li>-i 标准输入的结果以 {} 代替</li>
<li>-I 标准输入的结果以指定的名字代替</li>
<li>-t 显示执行命令</li>
<li>-p 交互式提示是否执行命令</li>
<li>-n 最大命令行参数</li>
<li>–show-limits 查看系统命令行长度限制</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">删除 / tmp 下名字是 core 的文件：
<span class="hljs-comment"># find /tmp -name core -type f -print | xargs /bin/rm -f</span>
<span class="hljs-comment"># find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f</span>
列转行（去除换行符 ）：
<span class="hljs-comment"># cut -d: -f1 &lt; /etc/passwd | sort | xargs echo</span>
行转列：
<span class="hljs-comment"># echo &quot;1 2 3 4 5&quot; |xargs -n1</span>
最长两列显示：
<span class="hljs-comment"># echo &quot;1 2 3 4 5&quot; |xargs -n2</span>
创建未来十天时间：
<span class="hljs-comment"># seq 1 10 |xargs -i date -d &quot;&#123;&#125; days&quot; +%Y-%m-%d</span>
复制多个目录：
<span class="hljs-comment"># echo dir1 dir2 |xargs -n1 cp a.txt</span>
清空所有日志：
<span class="hljs-comment"># find ./ -name &quot;*.log&quot; |xargs -i tee &#123;&#125; # echo &quot;&quot;&gt; &#123;&#125; 这样不行，&gt; 把命令中断了</span>
rm 在删除大量的文件时，会提示参数过长，那么可以使用 xargs 删除：
<span class="hljs-comment"># ls |xargs rm –rf</span>
或分配删除 rm [a-n]* -rf <span class="hljs-comment"># getconf ARG_MAX 获取系统最大参数限制</span></code></pre>

<h2 id="11-29-nl"><a href="#11-29-nl" class="headerlink" title="11.29 nl"></a>11.29 nl</h2><p>功能：打印文件行号</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-b &lt;a|t&gt; 指定行号显示方式，a 表示所有行都打印行号，b 表示空行不显示行号，默认是 a</li>
<li>-n &lt;ln|rn|rz&gt; 行号显示方法，ln 左对齐，rn 右对齐，rz 右边显示，左边空白用 0 填充。</li>
<li>-w 行号栏位在左边占用的宽度</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">打印行号，空行不显示：
<span class="hljs-comment"># nl a.txt</span>
左对齐打印行号：
<span class="hljs-comment"># nl -n ln a.txt</span>
行号右移动五个空格：
<span class="hljs-comment"># nl -w 5 a.txt</span></code></pre>

<h2 id="11-30-date"><a href="#11-30-date" class="headerlink" title="11.30 date"></a>11.30 date</h2><p>功能：打印或设置系统日期和时间</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-d string 显示指定字符串所描述的时间，而非当前时间</li>
<li>-f datefile 从日期文件中按行读入时间描述</li>
<li>-I 输出 ISO 8601 格式的日期和时间</li>
<li>-r 显示文件的最后修改时间</li>
<li>-R 输出 RFC 2822 格式的日期和时间</li>
<li>-s string 设置时间所描述的字符串</li>
<li>-u 打印或设置 UTC 时间</li>
</ul>
<p><strong>控制输出格式：</strong></p>
<ul>
<li>%% 一个文字的 %</li>
<li>%a 当前 locale 的星期名缩写 (例如： 日，代表星期日)</li>
<li>%A 当前 locale 的星期名全称 (如：星期日)</li>
<li>%b 当前 locale 的月名缩写 (如：一，代表一月)</li>
<li>%B 当前 locale 的月名全称 (如：一月)</li>
<li>%c 当前 locale 的日期和时间 (如： 2005 年 3 月 3 日 星期四 23:05:25)</li>
<li>%C 世纪；比如 %Y，通常为省略当前年份的后两位数字 (例如：20)</li>
<li>%d 按月计的日期 (例如：01)</li>
<li>%D 按月计的日期；等于 %m/%d/%y</li>
<li>%e 按月计的日期，添加空格，等于 %_d</li>
<li>%F 完整日期格式，等价于 %Y-%m-%d</li>
<li>%g ISO- 8601 格式年份的最后两位 (参见 %G)</li>
<li>%G ISO- 8601 格式年份 (参见 %V)，一般只和 %V 结合使用</li>
<li>%h 等于 %b</li>
<li>%H 小时 (00-23)</li>
<li>%I 小时 (00-12)</li>
<li>%j 按年计的日期 (001-366)</li>
<li>%k 时 (0-23)</li>
<li>%l 时 (1-12)</li>
<li>%m 月份 (01-12)</li>
<li>%M 分 (00-59)</li>
<li>%n 换行</li>
<li>%N 纳秒 (000000000-999999999)</li>
<li>%p 当前 locale 下的 “上午” 或者 “下午”，未知时输出为空</li>
<li>%P 与 %p 类似，但是输出小写字母</li>
<li>%r 当前 locale 下的 12 小时时钟时间 (如：11:11:04 下午)</li>
<li>%R 24 小时时间的时和分，等价于 %H:%M</li>
<li>%s 自 UTC 时间 1970 - 01 - 01 00:00:00 以来所经过的秒数</li>
<li>%S 秒 (00-60)</li>
<li>%t 输出制表符 Tab</li>
<li>%T 时间，等于 %H:%M:%S</li>
<li>%u 星期， 1 代表星期一</li>
<li>%U 一年中的第几周，以周日为每星期第一天 (00-53)</li>
<li>%V ISO- 8601 格式规范下的一年中第几周，以周一为每星期第一天 (01-53)</li>
<li>%w 一星期中的第几日 (0-6)， 0 代表周一</li>
<li>%W 一年中的第几周，以周一为每星期第一天 (00-53)</li>
<li>%x 当前 locale 下的日期描述 (如：12/31/99)</li>
<li>%X 当前 locale 下的时间描述 (如：23:13:48)</li>
<li>%y 年份最后两位数位 (00-99)</li>
<li>%Y 年份</li>
</ul>
<pre><code class="hljs bash">
设置系统日期和时间：
<span class="hljs-comment"># date -s &quot;2016-12-15 00:00:00&quot;</span>
查看当前系统时间戳：
<span class="hljs-comment"># date +%s</span>
查看当前系统时间：
<span class="hljs-comment"># date +&#x27;%F %T&#x27;</span>
把日期和时间转换成时间戳：
<span class="hljs-comment"># date -d &quot;2016-12 -15 18:00:00&quot; +%s</span>
把时间戳转成时间：
<span class="hljs-comment"># date -d &#x27;@1481842800&#x27; &#x27;+%F %T&#x27;</span>
时间加减：
显示前 30 秒：date -d <span class="hljs-string">&#x27;- 30 second&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>
显示前一分钟：date -d <span class="hljs-string">&#x27;- 1 minute&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>
显示前一个时间：date -d <span class="hljs-string">&#x27;- 1 hour&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>
显示前一个天：date -d <span class="hljs-string">&#x27;- 1 day&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>
显示上一周：date -d <span class="hljs-string">&#x27;- 1 week&#x27;</span> +<span class="hljs-string">&#x27;%F %T&#x27;</span>
显示上一个月日期：date -d <span class="hljs-string">&#x27;- 1 month&#x27;</span> +%F
显示上一年日期：date -d <span class="hljs-string">&#x27;- 1 year&#x27;</span> +%F
或
显示前一天日期：date -d yesterday +%F
显示后一天日期：date -d tomorrow +%F
时间比较：
NOW_DATE=$(date +%s)
AGO_DATE=$(date -d <span class="hljs-string">&quot;2016-12-15 18:00:00&quot;</span> +%s)
[<span class="hljs-variable">$NOW_DATE</span> -gt <span class="hljs-variable">$AGO_DATE</span>] &amp;&amp; <span class="hljs-built_in">echo</span> yes || <span class="hljs-built_in">echo</span> no</code></pre>

<h2 id="11-31-wget"><a href="#11-31-wget" class="headerlink" title="11.31 wget"></a>11.31 wget</h2><p>功能：非交互式网络下载，类似于 HTTP 客户端</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-b, –background 后台运行<br>日志记录和输入文件：</li>
<li>-o, –output-file=FILE 日志写到文件</li>
<li>-a, –append-output=FILE 日志追加到文件</li>
<li>-d, –debug 打印 debug 信息，会包含头信息</li>
<li>-q, –quiet 退出，不输出</li>
<li>-i, –input-file=FILE 从文件中读取 URL 下载</li>
</ul>
<p><strong>下载选项：</strong></p>
<ul>
<li>-t, –tries=NUMBER 设置链接重试次数</li>
<li>-O, –output-document=FILE 写入内容到文件</li>
<li>-nc, –no-clobber 跳过下载现有的文件</li>
<li>-c, –continue 断点续传</li>
<li>–progress=TYPE 设置进度条（dot 和 bar）</li>
<li>-S, –server-response 打印服务器响应头信息</li>
<li>–spider 不下载任何内容</li>
<li>-T, –timeout=SECONDS 设置相应超时时间（还有 –dns-timeout、–connect-timeout 和</li>
<li>–read-timeout）</li>
<li>-w, –wait=SECONDS 两次重试间隔等待时间</li>
<li>–bind-address=ADDRESS 设置绑定地址</li>
<li>–limit-rate=RATE 限制下载速度</li>
<li>–user=USER 设置 ftp 和 http 用户名</li>
<li>–password=PASS 设置 ftp 和 http 密码</li>
</ul>
<p><strong>目录：</strong></p>
<ul>
<li>-P, –directory-prefix=PREFIX 保存文件目录<br>HTTP 选项：</li>
<li>–http-user=USER 设置 http 用户名</li>
<li>–http-password=PASS 设置 http 密码</li>
<li>–proxy-user=USER 设置代理用户名</li>
<li>–proxy-password=PASS 设置代理密码</li>
<li>–referer=URL 设置 Referer</li>
<li>–save-headers 保存头到文件</li>
<li>–default-page=NAME 改变默认页面名字，默认 index.html</li>
<li>-U,–user-agent=AGENT 设置客户端信息</li>
<li>–no-http-keep-alive 禁用 HTTP keep-alive（长连接）</li>
<li>–load-cookies=FILE 从文件加载 cookies</li>
<li>–save-cookies=FILE 保存 cookies 到文件</li>
<li>–post-data=STRING 使用 POST 方法，发送数据</li>
</ul>
<p><strong>FTP 选项：</strong></p>
<ul>
<li>–ftp-user=USER 设置 ftp 用户名</li>
<li>–ftp-password=PASS 设置 ftp 密码</li>
<li>–no-passive-ftp 禁用被动传输模式</li>
</ul>
<p><strong>递归下载：</strong></p>
<ul>
<li>-r, –recursive 指定递归下载</li>
<li>-l, –level=NUMBER 最大递归深度</li>
<li>-A, –accept=LIST 逗号分隔下载的扩展列表</li>
<li>-R, –reject=LIST 逗号分隔不被下载的扩展列表</li>
<li>-D, –domains=LIST 逗号分隔被下载域的列表</li>
<li>–exclude-domains=LIST 排除不被下载域的列表</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">下载单个文件到当前目录：
<span class="hljs-comment"># wget http://nginx.org/download/nginx-1.11.7.tar.gz</span>
放到后台下载：
<span class="hljs-comment"># wget -b http://nginx.org/download/nginx-1.11.7.tar.gz</span>
对于网络不稳定的用户使用 - c 和 --tries 参数，保证下载完成，并下载到指定目录：


<span class="hljs-comment"># wget -t 3 -c http://nginx.org/download/nginx-1.11.7.tar.gz -P down</span>
不下载任何内容，判断 URL 是否可以访问：
<span class="hljs-comment"># wget --spider http://nginx.org/download/nginx-1.11.7.tar.gz</span>
下载内容写到文件：
<span class="hljs-comment"># wget http://www.baidu.com/index.html -O index.html</span>
从文件中读取 URL 下载：
<span class="hljs-comment"># wget -i url.list</span>
下载 ftp 文件：
<span class="hljs-comment"># wget --ftp-user=admin --ftp-password=admin ftp://192.168.1.10/ISO/CentOS-6.5-i386-minimal.iso</span>
伪装客户端，指定 user-agent 和 referer 下载：
<span class="hljs-comment"># wget -U &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/44.0.2403.157 Safari/537.36&quot; --referer &quot;http://nginx.org/en/download.html&quot;http://nginx.org/download/nginx-1.11.7.tar.gz</span>
查看 HTTP 头信息：
<span class="hljs-comment"># wget -S http://nginx.org/download/nginx-1.11.7.tar.gz</span>
<span class="hljs-comment"># wget --debug http://nginx.org/download/nginx-1.11.7.tar.gz</span></code></pre>

<h2 id="11-32-curl"><a href="#11-32-curl" class="headerlink" title="11.32 curl"></a>11.32 curl</h2><p>功能：发送数据到 URL，类似于 HTTP 客户端</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-k, –insecure 允许 HTTPS 连接网站</li>
<li>-C, –continue-at 断点续传</li>
<li>-b, –cookie STRING/FILE 从文件中读取 cookie</li>
<li>-c, –cookie-jar 把 cookie 保存到文件</li>
<li>-d, –data 使用 POST 方式发送数据</li>
<li>–data-urlencode POST 的数据 URL 编码</li>
<li>-F, –form 指定 POST 数据的表单</li>
<li>-D, –dump-header 保存头信息到文件</li>
<li>–ftp-pasv 指定 FTP 连接模式 PASV/EPSV</li>
<li>-P, –ftp-port 指定 FTP 端口</li>
<li>-L, –location 遵循 URL 重定向，默认不处理</li>
<li>-l, –list-only 指列出 FTP 目录名</li>
<li>-H, –header 自定义头信息发送给服务器</li>
<li>-I, –head 查看 HTTP 头信息</li>
<li>-o, –output FILE 输出到文件</li>
<li>-#, –progress-bar 显示 bar 进度条</li>
<li>-x, –proxy [PROTOCOL://]HOST[:PORT] 使用代理</li>
<li>-U, –proxy-user USER[:PASSWORD] 代理用户名和密码</li>
<li>-e, –referer 指定引用地址 referer</li>
<li>-O, –remote-name 使用远程服务器上名字写到本地</li>
<li>–connect-timeout 连接超时时间，单位秒</li>
<li>–retry NUM 连接重试次数</li>
<li>–retry-delay 两次重试间隔等待时间</li>
<li>-s, –silent 静默模式，不输出任何内容</li>
<li>-Y, –speed-limit 限制下载速率</li>
<li>-u, –user USER[:PASSWORD] 指定 http 和 ftp 用户名和密码</li>
<li>-T, –upload-file 上传文件</li>
<li>-A, –user-agent 指定客户端信息</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">下载页面：
<span class="hljs-comment"># curl -o badu.html http://www.baidu.com</span>
不输出下载信息：
<span class="hljs-comment"># curl -s -o baidu.html http://www.baidu.com</span>
伪装客户端，指定 user-agent 和 referer 下载：
<span class="hljs-comment"># curl -A &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/44.0.2403.157 Safari/537.36&quot; - e &quot;baike.baidu.com&quot; http://127.0.0.1</span>
模拟用户登录，并保存 cookies 到文件：
<span class="hljs-comment"># curl -c ./cookies.txt -F NAME=user -F PWD=123 http://www.example.com/login.html</span>
使用 cookie 访问：
<span class="hljs-comment"># curl -b cookies.txt http://www.baidu.com</span>
访问 HTTP 认证页面：
<span class="hljs-comment"># curl -u user:pass http://www.example.com</span>
FTP 上传文件：
<span class="hljs-comment"># curl -T filename ftp://user:pass@ip/a.txt</span>
<span class="hljs-comment"># curl ftp://ip -u user:pass-T filename</span>
FTP 下载文件：
<span class="hljs-comment"># curl -O ftp://user:pass@ip/a.txt</span>
<span class="hljs-comment"># curl ftp://ip/filename -u user:pass -o filename</span>
FTP 下载多个文件：
<span class="hljs-comment"># curl ftp://ip/img/[1,3,5].jpg</span>
查看 HTTP 头信息：
<span class="hljs-comment"># curl -I http://www.baidu.com</span></code></pre>

<h2 id="11-33-scp"><a href="#11-33-scp" class="headerlink" title="11.33 scp"></a>11.33 scp</h2><p>功能：基于 SSH 的安全远程服务器文件拷贝</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-i 指定私钥文件</li>
<li>-l 限制速率，单位 Kb/s，1024Kb=1Mb</li>
<li>-P 指定远程主机 SSH 端口</li>
<li>-p 保存修改时间、访问时间和权限</li>
<li>-r 递归拷贝目录</li>
<li>-o SSH 选项，有以下几个比较常用的：</li>
<li>ConnectionAttempts=NUM 连接失败后重试次数</li>
<li>ConnectTimeout=SEC 连接超时时间</li>
<li>StrictHostKeyChecking=no 自动拉去主机 key 文件</li>
<li>PasswordAuthentication=no 禁止密码认证</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">本地目录推送到远程主机：
<span class="hljs-comment"># scp -P 22 - r src_dir root@192.168.1.10:/dst_dir</span>
远程主机目录拉取到本地：
<span class="hljs-comment"># scp -P 22 - r root@192.168.1.10:dst_dir src_dir</span>
同步文件方式一样，不用加 - r 参数</code></pre>

<h2 id="11-34-rsync"><a href="#11-34-rsync" class="headerlink" title="11.34 rsync"></a>11.34 rsync</h2><p>功能：远程或本地文件同步工具</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-v 显示复制信息</li>
<li>-q 不输出错误信息</li>
<li>-c 跳过基础效验，不判断修改时间和大小</li>
<li>-a 归档模式，等效 - rlptgoD，保留权限、属组等</li>
<li>-r 递归目录</li>
<li>-l 拷贝软连接</li>
<li>-z 压缩传输数据</li>
<li>-e 指定远程 shell，比如 ssh、rsh</li>
<li>–progress 进度条，等同 - P</li>
<li>–bwlimit=KB/s 限制速率， 0 为没有限制</li>
<li>–delete 删除那些 DST 中 SRC 没有的文件</li>
<li>–exclude=PATTERN 排除匹配的文件或目录</li>
<li>–exclude-from=FILE 从文件中读取要排除的文件或目录</li>
<li>–password-file=FILE 从文件读取远程主机密码</li>
<li>–port=PORT 监听端口</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs baash">本地复制目录：
# rsync -avz abc &#x2F;opt
本地目录推送到远程主机：
# rsync -avz SRC root@192.168.1.120:DST
远程主机目录拉取到本地：
# rsync -avz root@192.168.1.10:SRC DST
保持远程主机目录与本地一样：
# rsync -avz --delete SRC root@192.168.1.120:DST
排除某个目录：
# rsync -avz --exclude&#x3D;no_dir SRC root@192.168.1.120:DST
指定 SSH 端口：
# rsync -avz &#x2F;etc&#x2F;hosts -e &quot;ssh - p22&quot; root@192.168.1.120:&#x2F;opt</code></pre>

<h2 id="11-35-nohup"><a href="#11-35-nohup" class="headerlink" title="11.35 nohup"></a>11.35 nohup</h2><p>功能：运行程序，忽略挂起信号</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">后台运行程序，终端关闭不影响：
<span class="hljs-comment"># nohup bash test.sh &amp;&gt;test.log &amp;</span></code></pre>

<h2 id="11-36-iconv"><a href="#11-36-iconv" class="headerlink" title="11.36 iconv"></a>11.36 iconv</h2><p>功能：将文件内容字符集转成其他字符集</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-l 列出所有已知的字符集</li>
<li>-f 原始文本编码</li>
<li>-t 输出编码</li>
<li>-o 输出到文件</li>
<li>-s 关闭警告</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">将文件内容转换 UTF8：
<span class="hljs-comment"># iconv -f gbk -t utf8 old.txt -o new.txt</span>
将 csv 文件转换 GBK：
<span class="hljs-comment"># iconv -f utf8 -t gbk old.txt -o new.txt</span>
解决邮件乱码：
<span class="hljs-comment"># echo $(echo &quot;content&quot; | iconv -f utf8 -t gbk) | mail -s &quot;$(echo&quot;title&quot;| iconv -f utf8 -t gbk)&quot; example@mail.com</span></code></pre>

<h2 id="11-37-uname"><a href="#11-37-uname" class="headerlink" title="11.37 uname"></a>11.37 uname</h2><p>功能：输出系统信息</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-a 输出以下所有信息</li>
<li>-s 输出内核名称</li>
<li>-n 输出主机名</li>
<li>-r 输出内核发行版</li>
<li>-v 输出内核版本</li>
<li>-m 输出主机的硬件架构名称</li>
<li>-p 输出处理器类型或 “unknown”</li>
<li>-i 输出硬件平台或 “unknown</li>
<li>-o 输出操作系统名称</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">输出所有系统信息：
<span class="hljs-comment"># uname -a</span>
输出主机名：
<span class="hljs-comment"># uname -a</span>
输出内核版本：
<span class="hljs-comment"># uname -r</span>
输出操作系统：
<span class="hljs-comment"># uname -o</span></code></pre>

<h2 id="11-38-sshpass"><a href="#11-38-sshpass" class="headerlink" title="11.38 sshpass"></a>11.38 sshpass</h2><p>功能：非交互 SSH 登录（需要安装）</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-f 从文件中获取密码</li>
<li>-d 用文件描述符数字获取密码</li>
<li>-p 指定 SSH 密码</li>
<li>-e 密码作为环境变量传递，变量名是 SSHPASS</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">免交互 SSH 登录：
<span class="hljs-comment"># sshpass -p 123456 ssh root@192.168.1.10</span>
免交互传输文件：
<span class="hljs-comment"># sshpass -p 123456 scp a.txt 192.168.1.10:/root</span>
密码传入系统变量：
<span class="hljs-comment"># SSHPASS=123456 rsync -avz /etc/hosts -e &quot;sshpass -e ssh&quot; root@192.168.1.221:/opt</span></code></pre>

<h2 id="11-39-tar"><a href="#11-39-tar" class="headerlink" title="11.39 tar"></a>11.39 tar</h2><p>功能：归档目录或文件</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-c 创建新归档</li>
<li>-d 比较归档和文件系统的差异</li>
<li>-r 追加文件到归档</li>
<li>-t 存档的内容列表</li>
<li>-x 提取归档所有文件</li>
<li>-C 改变解压目录</li>
<li>-f 使用归档文件或设备归档</li>
<li>-j bzip2 压缩</li>
<li>-z gzip 压缩</li>
<li>-v 输出处理过程</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">创建归档文件来自 foo 和 bar：
<span class="hljs-comment"># tar -cf archive.tar foo bar</span>
提取归档的所有文件：
<span class="hljs-comment"># tar -xf archive.tar</span>
列出所有归档文件内容：
<span class="hljs-comment"># tar -tvf archive.tar</span>
创建归档并 gzip 压缩：
<span class="hljs-comment"># tar -zcvf archive.tar.gz log</span>
提取归档文件并 gzip 解压：
<span class="hljs-comment"># tar -zxvf log.tar.gz</span>
创建归档并 bzip2 压缩：
<span class="hljs-comment"># tar -jcvf log.tar.bz log</span>
提取归档并解压到指定目录：
<span class="hljs-comment"># tar -zxvf log.tar.gz -C /opt</span></code></pre>

<h2 id="11-40-logger"><a href="#11-40-logger" class="headerlink" title="11.40 logger"></a>11.40 logger</h2><p>功能：系统日志的 shell 命令行接口</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-i 每行记录进程 ID</li>
<li>-f 指定输出日志到文件</li>
<li>-p 设置记录的优先级</li>
<li>-t 添加标签</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># logger -i -t &quot;my_test&quot; -p local3.notice &quot;test_info&quot;</span></code></pre>

<h2 id="11-41-netstat"><a href="#11-41-netstat" class="headerlink" title="11.41 netstat"></a>11.41 netstat</h2><p>功能：打印网络连接、路由表、接口统计信息、伪装连接和多播成员</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-r 显示路由表</li>
<li>-i 显示接口表</li>
<li>-n 不解析名字</li>
<li>-p 显示程序名 PID/Program</li>
<li>-l 显示监听的 socket</li>
<li>-a 显示所有 socket</li>
<li>-o 显示计时器</li>
<li>-Z 显示上下文</li>
<li>-t 只显示 tcp 连接</li>
<li>-u 只显示 udp 连接</li>
<li>-s 显示每个协议统计信息</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">显示所有监听：
<span class="hljs-comment"># netstat -anltu</span>
显示所有 TCP 连接：
<span class="hljs-comment"># netstat -antp</span>
显示所有 UDP 连接：
<span class="hljs-comment"># netstat -anup</span>
显示路由表：
<span class="hljs-comment"># netstat -r</span></code></pre>

<h2 id="11-42-ss"><a href="#11-42-ss" class="headerlink" title="11.42 ss"></a>11.42 ss</h2><p>功能：比 netstat 更强大的 socket 查看工具</p>
<p>格式：ss [options] [ FILTER ]</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-n 不解析名字</li>
<li>-a 显示所有 socket</li>
<li>-l 显示所有监听的 socket</li>
<li>-o 显示计时器</li>
<li>-e 显示 socket 详细信息</li>
<li>-m 显示 socket 内存使用</li>
<li>-p 显示进程使用的 socket</li>
<li>-i 显示内部 TCP 信息</li>
<li>-s 显示 socket 使用汇总</li>
<li>-4 只显示 IPV4 的 socket</li>
<li>-0 显示包 socket</li>
<li>-t 只显示 TCP socket</li>
<li>-u 只显示 UDP socket</li>
<li>-d 只显示 DCCP socket</li>
<li>-w 只显示 RAW socket</li>
<li>-x 只显示 Unix 域 socket</li>
<li>-f FAMILY 只显示 socket 族类型（ unix, inet, inet6, link, netlink）</li>
<li>-A 查询 socket {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]</li>
<li>-D 将原始的 TCP socket 转储到文件</li>
<li>-F 从文件中读取过滤信息</li>
</ul>
<p><strong>过滤：</strong></p>
<ul>
<li>-o state 显示 TCP 连接状态信息</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">显示所有 TCP 连接：
<span class="hljs-comment"># ss -t -a</span>
显示所有 UDP 连接：
<span class="hljs-comment"># ss -u –a</span>
显示 socket 使用汇总：
<span class="hljs-comment"># ss -s</span>
显示所有建立的连接：
<span class="hljs-comment"># ss -o state established</span>
显示所有的 TIME-WAIT 状态：
<span class="hljs-comment"># ss -o state TIME-WAIT</span>
搜索所有本地进程连接到 X Server：
<span class="hljs-comment"># ss -x src /tmp/.X11-unix/*</span></code></pre>

<h2 id="11-43-lsof"><a href="#11-43-lsof" class="headerlink" title="11.43 lsof"></a>11.43 lsof</h2><p>功能：列出打开的文件</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-i [i] 监听的网络地址，如果没有指定，默认列出所有。<br>[i] 来自 [46][protocol][@hostname|hostaddr][:service|port]</li>
<li>-U 列出 Unix 域 socket 文件</li>
<li>-p 指定 PID</li>
<li>-u 指定用户名或 UID 所有打开的文件</li>
<li>+D 递归搜索</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">列出所有打开的文件：
<span class="hljs-comment"># lsof</span>
查看哪个进程占用文件：
<span class="hljs-comment"># lsof /etc/passwd</span>
列出所有打开的监听地址和 unix 域 socket 文件：
<span class="hljs-comment"># lsof -i -U</span>
列出 80 端口监听的进程：
<span class="hljs-comment"># lsof -i:80</span>
列出端口 1 - 1024 之间的所有进程：
<span class="hljs-comment"># lsof -i:1-1024</span>
列出所有 TCP 网络连接：
<span class="hljs-comment"># lsof -i tcp</span>
列出所有 UDP 网络连接：
<span class="hljs-comment"># lsof -i udp</span>
根据文件描述符列出打开的文件：
<span class="hljs-comment"># lsof -d 1</span>
列出某个目录被打开的文件：
<span class="hljs-comment"># lsof +D /var/log</span>
列出进程 ID 打开的文件：
<span class="hljs-comment"># lsof -p 5373</span>
打开所有登录用户名 abc 或 user id 1234 ，或 PID 123 或 PID 456 ：
<span class="hljs-comment"># lsof -p 123,456 -u 123,abc</span>
列出 COMMAND 列中包含字符串 sshd：
<span class="hljs-comment"># lsof -c sshd</span></code></pre>

<h2 id="11-44-ps"><a href="#11-44-ps" class="headerlink" title="11.44 ps"></a>11.44 ps</h2><p>功能：报告当前进程的快照</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-a 显示所有进程</li>
<li>-u 选择有效的用户 ID 或名称</li>
<li>-x 显示无控制终端的进程</li>
<li>-e 显示所有进程</li>
<li>-f 全格式</li>
<li>-r 只显示运行的进程</li>
<li>-T 这个终端的所有进程</li>
<li>-p 指定进程 ID</li>
<li>–sort 对某列排序</li>
<li>-m 线程</li>
<li>-L 格式化代码列表</li>
<li>-o 用户自定义格式</li>
</ul>
<pre><code class="hljs bash">CODE NORMAL HEADER
%C pcpu      %CPU
%G group     GROUP
%P ppid      PPID
%U user      USER
%a args      COMMAND
%c comm      COMMAND
%g rgroup    RGROUP
%n nice      NI
%p pid       PID
%r pgid      PGID
%t etime     ELAPSED
%u ruser     RUSER
%x time      TIME
%y tty       TTY
%z vsz       VSZ</code></pre>

<p><strong>示例：</strong></p>
<pre><code class="hljs bash">打印系统上所有进程标准语法：
<span class="hljs-comment"># ps -ef</span>
打印系统上所有进程 BSD 语法：
<span class="hljs-comment"># ps aux</span>
打印进程树：
<span class="hljs-comment"># ps axjf 或 ps -ejH</span>
查看进程启动的线程：
<span class="hljs-comment"># ps -Lfp PID</span>
查看当前用户的进程数：
<span class="hljs-comment"># ps uxm 或 ps -U root -u root u</span>
自定义格式显示并对 CPU 排序：
<span class="hljs-comment"># ps -eo user,pid,pcpu,pmem,nice,lstart,time,args --sort=-pcpu</span>
或 ps -eo <span class="hljs-string">&quot;%U %p %C %n %x %a&quot;</span></code></pre>

<p>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p>
<ul>
<li>USER 进程所有者</li>
<li>PID 进程 ID</li>
<li>%CPU 占用 CPU 时间</li>
<li>%MEM 物理内存</li>
<li>VSZ 虚拟内存大小（kb）</li>
<li>RSS 驻留集内存页数量（kb）</li>
<li>TTY 终端</li>
<li>STAT 进程状态；R 运行，S 休眠，D 不可中断，T 停止，Z 僵尸，N 表示普通优先级更低的优先级</li>
<li>START 进程启动时间</li>
<li>TIME 使用 CPU 总时间</li>
<li>COMMAND 命令名称和参数</li>
</ul>
<h2 id="11-45-top"><a href="#11-45-top" class="headerlink" title="11.45 top"></a>11.45 top</h2><p>功能：动态显示活动的进程和系统资源利用率</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-d 信息刷新时间间隔</li>
<li>-p 只监控指定的进程 PID</li>
<li>-i 只显示正在使用 CPU 的进程</li>
<li>-H 显示线程</li>
<li>-u 只查看指定用户名的进程</li>
<li>-b 将输出编排成易处理格式，适合输出到文件处理</li>
<li>-n 指定最大循环刷新数</li>
</ul>
<p><strong>交互命令：</strong></p>
<ul>
<li>f 添加或删除显示的指标</li>
<li>c 显示完整命令</li>
<li>P 按 CPU 使用百分比排序</li>
<li>M 按驻留内存大小排序</li>
<li>T 按进程使用 CPU 时间排序</li>
<li>1 显示每个 CPU 核心使用率</li>
<li>k 终止一个进程</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">刷新一次并输出到文件：
<span class="hljs-comment"># top -b -n 1 &gt; top.log</span>
只显示指定进程的线程：
<span class="hljs-comment"># top -Hp 123</span>
top - 09:31:08 up 16:49,  0 users,  load average: 0.03, 0.19, 0.22
Threads:   0 total,   0 running,   0 sleeping,   0 stopped,   0 zombie
%Cpu(s): 12.6 us,  1.0 sy,  0.0 ni, 86.2 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st
KiB Mem :  8008940 total,  7000600 free,   419132 used,   589208 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.  7275176 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</code></pre>

<p>第一行：当前系统时间，系统运行了多长时间（ 9 天 22 小时 16 分钟），CPU 负载： 1 分钟、 5 分钟、15 分钟</p>
<p>第二行：系统总共 178 个进程， 3 个 CPU 正在处理， 175 在休眠等待处理， 0 个停止， 0 个僵尸进程</p>
<p>第三行：us 用户空间使用 CPU 时间 0.3%，sy 内核空间使用 CPU 时间 0.3%，ni 系统调整进程优先级使用 CPU 时间 0.0%，id 空闲 CPU 时间 99.3%，wa 等待 I/O 响应 CPU 时间 0.0%，hi 硬中断，si 软中断。</p>
<p>第四行和第五行：物理内存与交换分区使用率</p>
<p>第六行：</p>
<ul>
<li>PID 进程 ID</li>
<li>USER 进程所有者</li>
<li>PR 进程优先级</li>
<li>NI 负值表示高优先级，正值表示低优先级</li>
<li>VIRT 进程启动后使用虚拟内存总量（KB）， VIRT=SWAP+RES</li>
<li>RES 实际物理内存使用大小（KB），RES=CODE+DATA</li>
<li>SHR 共享内存大小（KB）, 可能与其他进程共享的内存；计算进程使用物理内存大小：RES-SHR</li>
<li>S 进程状态；R 运行，S 休眠，D 不可中断，T 停止，Z 僵尸</li>
<li>%CPU 上次更新到现在的 CPU 时间占用百分比</li>
<li>%MEM 使用物理内存百分比</li>
<li>TIME+ 使用 CPU 总时间</li>
<li>COMMAND 命令名称和参数</li>
</ul>
<h2 id="11-46-free"><a href="#11-46-free" class="headerlink" title="11.46 free"></a>11.46 free</h2><p>功能：查看内存使用率</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-b bytes 显示</li>
<li>-k KB 显示</li>
<li>-m M 显示</li>
<li>-g G 显示</li>
<li>-h 易读单位显示</li>
<li>-s 每几秒重复打印</li>
<li>-c 重复打印几次退出</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">查看物理内存：
<span class="hljs-comment"># free -m</span>
易读单位显示：
<span class="hljs-comment"># free -h</span></code></pre>

<h2 id="11-47-df"><a href="#11-47-df" class="headerlink" title="11.47 df"></a>11.47 df</h2><p>功能：查看文件系统的磁盘空间使用情况</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-a 包含虚拟文件系统</li>
<li>-h 可易读单位显示</li>
<li>-i 显示 inode 信息而非块使用量</li>
<li>-k 1K 块的数量</li>
<li>-t 只显示指定文件系统为指定类型的信息</li>
<li>-T 显示文件系统类型</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">查看所有文件系统：
<span class="hljs-comment"># df -ah</span>
输出指定文件系统：
<span class="hljs-comment"># df -t xfs</span></code></pre>

<h2 id="11-48-vmstat"><a href="#11-48-vmstat" class="headerlink" title="11.48 vmstat"></a>11.48 vmstat</h2><p>功能：报告虚拟内存、swap、io、上下文和 CPU 统计信息。</p>
<p>分析了这些文件：</p>
<ul>
<li>/proc/meminfo</li>
<li>/proc/stat</li>
<li>/proc/*/stat</li>
</ul>
<p><strong>常用选项：</strong></p>
<ul>
<li>-a 打印活跃和不活跃的内存页</li>
<li>-d 打印硬盘统计信息</li>
<li>-D 打印硬盘表</li>
<li>-p 打印硬盘分区统计信息</li>
<li>-s 打印虚拟内存表</li>
<li>-m 打印内存分配（slab）信息</li>
<li>-t 添加时间戳到输出</li>
<li>-S 显示单位，默认 k、KB、m、M，大写是 * 1024</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">每秒刷新一次，统计五次：
<span class="hljs-comment"># vmstat - t 1 5</span>
[root@blog ~]<span class="hljs-comment"># vmstat -t 1 5</span>
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- -----timestamp-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="hljs-keyword">in</span>   cs us sy id wa st                 CST
 1  0      0 6984504   2108 586796    0    0     3    10  142  106  6  1 93  0  0 2020-09-29 09:28:49
 0  0      0 6984504   2108 586828    0    0     0     0  149  174  0  0 100  0  0 2020-09-29 09:28:50
 0  0      0 6984504   2108 586828    0    0     0    69  121  154  1  0 100  0  0 2020-09-29 09:28:51
 0  0      0 6984504   2108 586828    0    0     0     0  128  155  0  0 100  0  0 2020-09-29 09:28:52
 1  0      0 6984504   2108 586828    0    0     0     0  113  146  0  0 100  0  0 2020-09-29 09:28:53</code></pre>

<ul>
<li>r：CPU 正在运行的进程数</li>
<li>b：在等待 I/O 的进程数</li>
<li>swpd：已经使用的交换内存（kb）</li>
<li>free：空闲的物理内存（kb）</li>
<li>buff：已经使用的缓冲区内存（kb）；一般对设备数据缓存，写入到磁盘的数据。</li>
<li>cache：已经使用的缓冲区内存（kb）；一般对文件数据缓存，从磁盘读取的数据。</li>
<li>si：从磁盘交换到内存的交换页数量（kb/s）</li>
<li>so：从内存交换到磁盘的交换页数据（kb/s）</li>
<li>bi：块设备接收的块数量（kb/s）</li>
<li>bo：块设备发送的块数量（kb/s）</li>
<li>in：每秒 CPU 中断次数</li>
<li>cs：每秒 CPU 上下文切换次数</li>
<li>us：用户进程使用 CPU 时间（%）</li>
<li>sy：系统进程使用 CPU 时间（%）</li>
<li>id：CPU 空闲时间（%）</li>
<li>wa：等待 I/O 响应所消耗的 CPU 时间（%）</li>
<li>st：从虚拟设备中获得的时间（%）</li>
</ul>
<h2 id="11-49-iostat"><a href="#11-49-iostat" class="headerlink" title="11.49 iostat"></a>11.49 iostat</h2><p>功能：报告 CPU 利用率和磁盘 I/O</p>
<p>用法: iostat [选项] [ &lt; 时间间隔 &gt; [ &lt; 次数 &gt; ] ]</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-c 显示 CPU 使用率</li>
<li>-d 只显示磁盘使用率</li>
<li>-k 单位 KB/s 代替 Block/s</li>
<li>-m 单位 MB/s 代替 Block/s</li>
<li>-N 显示所有映射设备名字</li>
<li>-t 打印报告时间</li>
<li>-x 显示扩展统计信息</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">显示 CPU 使用率：
<span class="hljs-comment"># iostat -c 1 3</span>
显示 I/O 磁盘统计信息：
<span class="hljs-comment"># iostat -d -x -k 1 3 # 间隔 1 秒，输出 3 次</span></code></pre>

<h2 id="11-50-sar"><a href="#11-50-sar" class="headerlink" title="11.50 sar"></a>11.50 sar</h2><p>功能：查看系统资源综合方面利用率</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-u, CPU</li>
<li>-r, memory</li>
<li>-b, disk</li>
<li>-n DEV, NIC traffic</li>
<li>-q, systemload</li>
<li>-b, TPS（Transaction Per Second，每秒事务处理量）</li>
<li>-o, output to file</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-comment"># sar -u 2 3 #每两秒执行一次，采集三次</span>
<span class="hljs-comment"># sar -u 2 3 -o cpu.out</span>
<span class="hljs-comment"># sar -f cpu.out #读取文件</span></code></pre>

<h2 id="11-51-dstat"><a href="#11-51-dstat" class="headerlink" title="11.51 dstat"></a>11.51 dstat</h2><p>功能：查看系统资源综合方面利用率（需要安装）</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-c cpu 统计</li>
<li>-d 磁盘统计</li>
<li>-m 内存统计</li>
<li>-n 网络统计</li>
<li>-s swap 统计</li>
<li>-l 负载统计</li>
<li>–tcp tcp 状态统计</li>
<li>–udp udp 状态统计</li>
<li>–socket socket 数量统计</li>
<li>-t 输出时间</li>
<li>–output 写入 csv 文件</li>
</ul>
<p><strong>插件：</strong></p>
<ul>
<li>–list 支持的插件</li>
<li>–top-bio-adv 详细显示 I/O 进程写入 block 量，包括 pid、r、w 和 cpu</li>
<li>–top-io-adv 进程写入磁盘总量</li>
<li>–top-cpu 占用 CPU 进程</li>
<li>–top-cpu-adv 查看最高 CPU 进程</li>
<li>–top-mem 内存进程</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">查看 CPU 利用率：
<span class="hljs-comment"># dstat -c</span>
查看 TCP 连接状态：
<span class="hljs-comment"># dstat --tcp</span></code></pre>

<h2 id="11-52-ip"><a href="#11-52-ip" class="headerlink" title="11.52 ip"></a>11.52 ip</h2><p>功能：查看 / 操作路由表、设备、路由策略和隧道</p>
<p>格式：ip [OPTIONS] OBJECT { COMMAND | help }</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-b, -batch <FILENAME> 从文件或标准输入读取命令并调用他们，第一次失败将终止</li>
<li>-force 批量模式有错误不终止，如果有错误则状态返回非 0</li>
<li>-s, -statistics 输出更多的统计信息</li>
<li>-l, -loops <COUNT> 指定最大的循环数</li>
</ul>
<p><strong>操作对象（OBEJECT）：</strong></p>
<ul>
<li>address   网络设备地址</li>
<li>12tp    以太网 IP 隧道</li>
<li>link  配置网络设备</li>
<li>maddress  多播地址</li>
<li>monitor   动态监控网络连接</li>
<li>mroute  多播路由缓存条目</li>
<li>mrule   角色在多播路由策略数据库</li>
<li>neighbour   管理 ARP 或 NDISC 缓存条目</li>
<li>netns   管理网络命名空间</li>
<li>ntable 管理 neighbour 缓存操作</li>
<li>route 路由表</li>
<li>rule 角色在路由策略数据库</li>
<li>tpc_metrics/tcpmetrics 管理 TCP 指标</li>
<li>tunnel IP 隧道</li>
<li>tuntap 管理 TUN/TAP 设备</li>
<li>xfrm 管理 IPSec 策略</li>
</ul>
<p>可通过 ip OBEJECT help 再查看对象的操作方法。</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">查看网络设备地址：
<span class="hljs-comment"># ip addr</span>
查看网卡统计信息：
<span class="hljs-comment"># ip -s link</span>
查看单个网卡统计信息：
<span class="hljs-comment"># ip -s link ls eth0</span>
查看 ARP 缓存表：
<span class="hljs-comment"># ip neighbour</span>
查看路由表：
<span class="hljs-comment"># ip route</span>
查看路由策略：
<span class="hljs-comment"># ip rule</span>
网卡设置 / 删除 IP：
<span class="hljs-comment"># ip addr add/del 192.168.1.201/24 dev eth0</span>
添加 / 删除默认路由：
<span class="hljs-comment"># ip route add default via 192.168.1.1 dev eth0</span>
<span class="hljs-comment"># ip route del 192.168.1.0/24 via 192.168.1.1</span>
添加静态路由：
<span class="hljs-comment"># ip route add 172.17.2.0/24 via 192.168. 2. 1 dev eth0</span>
开启 / 关闭网卡：
<span class="hljs-comment"># ip link set dev eth0 up/down</span>
设置最大传输单元：
<span class="hljs-comment"># ip link set dev eth0 mtu 1500</span>
设置 MAC 地址：
<span class="hljs-comment"># ip link set dev eth0 address 00:0c:29:52:73:8e</span></code></pre>

<h2 id="11-53-nc"><a href="#11-53-nc" class="headerlink" title="11.53 nc"></a>11.53 nc</h2><p>功能：TCP 和 UDP 连接和监听</p>
<p>常用选项：</p>
<ul>
<li>-i interval 指定间隔时间发送和接受行文本</li>
<li>-l 监听模式，管理传入的连接</li>
<li>-n 不解析域名</li>
<li>-p 指定本地源端口</li>
<li>-s 指定本地源 IP 地址</li>
<li>-u 使用 udp 协议，默认是 tcp</li>
<li>-v 执行过程输出</li>
<li>-w timeout 连接超时时间</li>
<li>-x proxy_address[:port] 请求连接主机使用代理地址和端口</li>
<li>-z 指定扫描监听端口，不发送任何数据</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">端口扫描：
<span class="hljs-comment"># nc -z 192.168.1.10 1-65535</span>
TCP 协议连接到目标端口：
<span class="hljs-comment"># nc -p 31337 -w 5 192.168.1.10 22</span>
UDP 协议连接到目的端口：
<span class="hljs-comment"># nc -u 192.168.1.10 53</span>
指定本地 IP 连接：
<span class="hljs-comment"># nc -s 192.168.1.9 192.168.1.10 22</span>
探测端口是否开启：
<span class="hljs-comment"># nc -z -w 2 192.168.1.10 22</span>
创建监听 Unix 域 Socket：
<span class="hljs-comment"># nc -lU /var/tmp/ncsocket</span>
通过 HTTP 代理连接主机：
<span class="hljs-comment"># nc -x10.2.3.4:8080 -Xconnect 10.0.0.10 22</span>
监听端口捕获输出到文件：
<span class="hljs-comment"># nc -l 1234 &gt; filename.out</span>
从文件读入到指定端口：
<span class="hljs-comment"># nc host.example.com 1234 &lt; filename.in</span>
收发信息：
<span class="hljs-comment"># nc -l 1234</span>
<span class="hljs-comment"># nc 127.0.0.1 1234</span>
执行 memcahced 命令：<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;stats\n&quot;</span> |nc 127.0.0.1 11211
发送邮件：
<span class="hljs-comment"># nc [-C] localhost 25 &lt;&lt; EOF</span>
HELO host.example.com
MAIL FROM: &lt;user@host.example.com&gt;
RCPT TO: &lt;user2@host.example.com&gt;
DATA
Body of email
.
QUIT
EOF
<span class="hljs-comment"># echo -n &quot;GET / HTTP/1.0\r\n\r\n&quot; | nc host.example.com 80</span></code></pre>

<h2 id="11-54-time"><a href="#11-54-time" class="headerlink" title="11.54 time"></a>11.54 time</h2><p>功能：执行脚本时间</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">查看执行 ls 所需的时间：
<span class="hljs-comment"># time ls</span></code></pre>

<h2 id="11-55-eval"><a href="#11-55-eval" class="headerlink" title="11.55 eval"></a>11.55 eval</h2><p>功能：执行参数作为 shell 命令</p>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$@</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">eval</span> <span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> ---
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$b</span>
<span class="hljs-comment"># bash test.sh a=1 b=2</span>
---
1
2</code></pre>

<h2 id="11-56-ssh"><a href="#11-56-ssh" class="headerlink" title="11.56 ssh"></a>11.56 ssh</h2><p>功能：SSH 客户端</p>
<p><strong>常用选项：</strong></p>
<ul>
<li>-p 指定远程主机端口</li>
<li>-i 指定认证文件</li>
<li>-L [bind_address:]port:host:hostport</li>
<li>-R [bind_address:]port:host:hostport]</li>
<li>-D [bind_address:]port</li>
<li>-o SSH 选项，有以下几个比较常用的：</li>
<li>ConnectionAttempts=NUM 连接失败后重试次数</li>
<li>ConnectTimeout=SEC 连接超时时间</li>
<li>StrictHostKeyChecking=no 自动拉去主机 key 文件</li>
<li>PasswordAuthentication=no 禁止密码认证</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs bash">登录到远程主机：
<span class="hljs-comment"># ssh user@192.168.1.120</span>
远程主机执行命令：
<span class="hljs-comment"># ssh user@192.168.1.120 &#x27;ifconfig&#x27;</span>
本地文件内容写到远程主机文件：
<span class="hljs-comment"># ssh user@192.168.1.120 &#x27;cat &gt;&gt; file&#x27; &lt; /etc/passwd</span></code></pre>

<p>SSH 还提供了一个非常有用的功能，就是端口转发，能帮你解决一些无法建立的连接。</p>
<p>1 ）本地端口转发</p>
<p>应用场景 1 ：A 不能访问 C，B 能访问 A 和 C，实现通过 B 能让 A 访问 C</p>
<p>在主机 A 执行：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># ssh -L 2222: 主机 C:22 主机 B # ssh - L [绑定地址:] 本地端口: 主机 C:C 端口 主机 B</span>
将 SSH 绑定本地端口 2222 ，本地 2222 端口数据转发主机 B，主机 B 的所有数据转发到主机 C 的 22 端口；这样一来，只要在主机 A ssh - p 2222 localhost，就等于连上了主机 C 的 22 端口。
应用场景 2 ：一台 Squid 代理服务器，限制了本机可以清理缓存，但是我想从远程服务器清理在远程服务器执行：
<span class="hljs-comment"># ssh -L 31280 :localhost:3128 SquidHost</span>
在远程服务器上执行清理命令到本机 31280 端口， 31280 收到的数据加密转发到 SquidHost 的 SSH Server 上，SSH Client 解密收到的数据并转发到监听的 3128 端口上，最后将 Squid 返回的数据原路返回。</code></pre>

<p>2 ）远程端口转发</p>
<p>应用场景 1 ：A 不能访问 C，B 能访问 A 和 C，但 A 不能访问 B，比如 A 在外网，B 在内网</p>
<p>在主机 B 执行：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># ssh -R 2222: 主机 C:22 主机 A</span>
将 SSH 绑定本机 2222 端口，与主机 A 建立 SSH 通道，当主机 A 访问本地 2222 端口，就等于访问主机
B 的 2222 端口，主机 B 的 2222 端口把数据转发到主机 C 的 22 端口。
应用常见 2 ：公司有一台内网服务器，还有一台云主机不能 SSH 直接连接这台公司内网服务器，但内网服务器可以 SSH 连接云主机在公司内网服务器执行：
<span class="hljs-comment"># ssh -R 2222 :localhost:22 云主机</span>
将云主机上的 2222 端口数据转发到内网服务器 SSH Client 上，SSH Client 解密收到的数据并转发到监听的 22 端口上，最后再将返回的数据原路返回。</code></pre>

<p>3 ）动态端口转发（不限定端口，全权代理）</p>
<p>应用场景：翻墙访问国外网站</p>
<p>如果是 MAC 系统直接在终端执行：ssh -D 2222 国外云主机</p>
<p>如果是 Windows 系统可借助 putty 工具实现，在 putty 里面端口转发 -&gt; 本地端口转发属性里面添加一个本地端口，并勾选 SOCKS4/5 动态转发，连接即可。<br>将 SSH 绑定本机 8080 端口，SSH 就会创建一个 SOCKS 代理服务，直接在浏览器上设置代理本机 127.0.0.1 的 8080 端口即可，当浏览器访问国外网站时，本地代理把请求转发到国外云主机的 SSH Server，SSH 解密并转发给指定的网站。</p>
<p>注意：再 Linux 终端执行 ssh 绑定命令后，默认会进入一个新的 shell，只要这个 shell 不退出，此<br>端口转发就一直有效。如果要想放到后台执行就加 - Nf 两个选项，-N 是不执行命令，-f 后台执行，<br>这样就转入后台运行，就可以在本地 shell 执行操作了，如果想关闭后台就 kill 这个进程。</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/">https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></p>
<h2 id="11-57-iptables"><a href="#11-57-iptables" class="headerlink" title="11.57 iptables"></a>11.57 iptables</h2><p>常见几种类型防火墙？</p>
<p>包过滤防火墙：包过滤是 IP 层实现，包过滤根据数据包的源 IP、目的 IP、协议类型（TCP/UDP/ICMP）、源端口、目的端口等包头信息及数据包传输方向灯信息来判断是否允许数据包通过。</p>
<p>应用层防火墙：也称为应用层代理防火墙，基于应用层协议的信息流检测，可以拦截某应用程序的所有封包，提取包内容进行分析。有效防止 SQL 注入或者 XSS（跨站脚本攻击）之类的恶意代码。</p>
<p>状态检测防火墙：结合包过滤和应用层防火墙优点，基于连接状态检测机制，将属于同一连接的所有包作为一个整体的数据流看待，构成连接状态表（通信信息，应用程序信息等），通过规则表与状态表共同配合，对表中的各个连接状态判断。</p>
<p>iptables 是 Linux 下的配置防火墙的工具，用于配置 Linux 内核集成的 IP 信息包过滤系统，使增<br>删改查信息包过滤表中的规则更加简单。</p>
<p>iptables 分为四表五链，表是链的容器，链是规则的容器，规则指定动作。</p>
<p><strong>四表：</strong></p>
<ul>
<li>filter 用于包过滤</li>
<li>nat 网络地址转发</li>
<li>mangle 对特定数据包修改</li>
<li>raw 不做数据包链接跟踪</li>
</ul>
<p><strong>五链：</strong></p>
<ul>
<li>INPUT 本机数据包入口</li>
<li>OUTPUT 本机数据包出口</li>
<li>FORWARD 经过本机转发的数据包</li>
<li>PREROUTING 防火墙之前，修改目的地址（DNAT）</li>
<li>POSTROUTING 防火墙之后，修改源地址（SNAT）</li>
</ul>
<p><strong>表中的链：</strong></p>
<table>
<thead>
<tr>
<th>表</th>
<th>链</th>
</tr>
</thead>
<tbody><tr>
<td>filter</td>
<td>INPUT、OUTPUT 和 FORWARD</td>
</tr>
<tr>
<td>nat</td>
<td>PREROUTING、POSTROUTING 和 OUTPUT</td>
</tr>
<tr>
<td>mangle</td>
<td>PREROUTING、POSTROUTING、INPUT、OUTPUT 和 FORWARD</td>
</tr>
<tr>
<td>raw</td>
<td>PREROUTING 和 OUTPUT</td>
</tr>
</tbody></table>
<p>命令格式：iptables [-t table] 命令 [chain] 匹配条件 动作</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>- A，append</td>
<td>追加一条规则</td>
</tr>
<tr>
<td>- I，insert</td>
<td>插入一条规则，默认链头，后跟编号，指定第几条</td>
</tr>
<tr>
<td>- D，delete</td>
<td>删除一条规则</td>
</tr>
<tr>
<td>- F，flush</td>
<td>清空规则</td>
</tr>
<tr>
<td>- L，list</td>
<td>列出规则</td>
</tr>
<tr>
<td>- P，policy</td>
<td>设置链缺省规则</td>
</tr>
<tr>
<td>- m，module</td>
<td>模块，比如 state、multiport</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>匹配条件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>- i</td>
<td>入口网卡</td>
</tr>
<tr>
<td>- o</td>
<td>出口网卡</td>
</tr>
<tr>
<td>- s</td>
<td>源地址</td>
</tr>
<tr>
<td>- d</td>
<td>目的地址</td>
</tr>
<tr>
<td>- p</td>
<td>协议类型</td>
</tr>
<tr>
<td>–sport</td>
<td>源端口</td>
</tr>
<tr>
<td>–dport</td>
<td>目的端口</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>动作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ACCEPT</td>
<td>允许数据包通过</td>
</tr>
<tr>
<td>DROP</td>
<td>丢弃数据包不做处理</td>
</tr>
<tr>
<td>REJECT</td>
<td>拒绝数据包，并返回报错信息</td>
</tr>
<tr>
<td>SNAT</td>
<td>一般用于 nat 表的 POSTROUTING 链，进行源地址转换</td>
</tr>
<tr>
<td>DNAT</td>
<td>一般用于 nat 表的 PREROUTING 链，进行目的地址转换</td>
</tr>
<tr>
<td>MASQUERADE</td>
<td>动态源地址转换，动态 IP 时使用</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模块</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>state</td>
<td>包状态，有四个：NEW、RELATED、ESTABLISHED 和 INVALID</td>
</tr>
<tr>
<td>mac</td>
<td>源 MAC 地址</td>
</tr>
<tr>
<td>limit</td>
<td>包速率限制</td>
</tr>
<tr>
<td>multiport</td>
<td>多端口，以逗号分隔</td>
</tr>
<tr>
<td>iprange</td>
<td>端口范围，以逗号分隔</td>
</tr>
</tbody></table>
<p><strong>示例：常用的规则配置方法</strong></p>
<pre><code class="hljs bash">iptables -F <span class="hljs-comment"># 清空表规则，默认 filter 表</span>
iptables -t nat - F <span class="hljs-comment"># 清空 nat 表</span>
iptables -A INPUT -p tcp --dport 22 -j ACCEPT <span class="hljs-comment"># 允许 TCP 的 22 端口访问</span>
iptables -I INPUT -p udp --dport 53 -j ACCEPT <span class="hljs-comment"># 允许 UDP 的 53 端口访问，插入在第一条</span>
iptables -A INPUT -p tcp --dport 22:25 -j ACCEPT <span class="hljs-comment"># 允许端口范围访问</span>
iptables -D INPUT -p tcp --dport 22:25 -j ACCEPT <span class="hljs-comment"># 删除这条规则</span>
<span class="hljs-comment"># 允许多个 TCP 端口访问</span>
iptables -A INPUT -p tcp -m multiport --dports 22,80,8080 -j ACCEPT
iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT <span class="hljs-comment"># 允许 192.168.1.0 段 IP 访问</span>
iptables -A INPUT -s 192.168.1.10 -j DROP <span class="hljs-comment"># 对 1.10 数据包丢弃</span>
iptables -A INPUT -i eth0 -p icmp -j DROP <span class="hljs-comment"># eth0 网卡 ICMP 数据包丢弃，也就是禁 ping</span>
<span class="hljs-comment"># 允许来自 lo 接口，如果没有这条规则，将不能通过 127.0.0.1 访问本地服务</span>
iptables -A INPUT -i lo -j ACCEPT
<span class="hljs-comment"># 限制并发连接数，超过 30 个拒绝</span>
iptables -I INPUT -p tcp --syn --dport 80 -m connlimit --connlimit-above 30 -j REJECT
<span class="hljs-comment"># 限制每个 IP 每秒并发连接数最大 3 个</span>
iptables -I INPUT -p tcp --syn -m <span class="hljs-built_in">limit</span> --<span class="hljs-built_in">limit</span> 1/s --limit-burst 3 -j ACCEPT
iptables -A FORWARD -p tcp --syn -m <span class="hljs-built_in">limit</span> --<span class="hljs-built_in">limit</span> 1/s -j ACCEPT
<span class="hljs-comment"># iptables 服务器作为网关时，内网访问公网</span>
iptables –t nat -A POSTROUTING -s [内网 IP 或网段] -j SNAT --to [公网 IP]
<span class="hljs-comment"># 访问 iptables 公网 IP 端口，转发到内网服务器端口</span>
iptables –t nat -A PREROUTING -d [对外 IP] -p tcp --dport [对外端口] -j DNAT --to [内网 IP: 内网端口]
<span class="hljs-comment"># 本地 80 端口转发到本地 8080 端口</span>
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080
<span class="hljs-comment"># 允许已建立及该链接相关联的数据包通过</span>
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
<span class="hljs-comment"># ASDL 拨号上网</span>
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o pppo -j MASQUERADE
<span class="hljs-comment"># 设置 INPUT 链缺省操作丢弃所有数据包，只要不符合规则的数据包都丢弃。注意要在最后设置，</span>
以免把自己关在外面！
iptables -P INPUT DROP</code></pre>

<h1 id="十二、-Shell-脚本编写实战"><a href="#十二、-Shell-脚本编写实战" class="headerlink" title="十二、 Shell 脚本编写实战"></a>十二、 Shell 脚本编写实战</h1><p><strong>注意事项</strong></p>
<ul>
<li>1 ）开头加解释器：#!/bin/bash</li>
<li>2 ）语法缩进，使用四个空格；多加注释说明。</li>
<li>3 ）命名建议规则：变量名大写、局部变量小写，函数名小写，名字体现出实际作用。</li>
<li>4 ）默认变量是全局的，在函数中变量 local 指定为局部变量，避免污染其他作用域。</li>
<li>5 ）有两个命令能帮助我调试脚本：set -e 遇到执行非 0 时退出脚本，set -x 打印执行过程。</li>
<li>6 ）写脚本一定先测试再到生产上。</li>
</ul>
<h2 id="12-1-获取随机字符串或数字"><a href="#12-1-获取随机字符串或数字" class="headerlink" title="12.1 获取随机字符串或数字"></a>12.1 获取随机字符串或数字</h2><p>获取随机 8 位字符串：</p>
<pre><code class="hljs bash">方法 1 ：
<span class="hljs-comment"># echo $RANDOM |md5sum |cut -c 1-8</span>
471b94f2
方法 2 ：
<span class="hljs-comment"># openssl rand -base64 4</span>
vg3BEg==
方法 3 ：
<span class="hljs-comment"># cat /proc/sys/kernel/random/uuid |cut -c 1-8</span>
ed9e032c</code></pre>

<p>获取随机 8 位数字：</p>
<pre><code class="hljs bash">方法 1 ：
<span class="hljs-comment"># echo $RANDOM |cksum |cut -c 1-8</span>
23648321
方法 2 ：
<span class="hljs-comment"># openssl rand -base64 4 |cksum |cut -c 1-8</span>
38571131
方法 3 ：
<span class="hljs-comment"># date +%N |cut -c 1-8</span>
69024815</code></pre>

<p>cksum：打印 CRC 效验和统计字节</p>
<h2 id="12-2-定义一个颜色输出字符串函数"><a href="#12-2-定义一个颜色输出字符串函数" class="headerlink" title="12.2 定义一个颜色输出字符串函数"></a>12.2 定义一个颜色输出字符串函数</h2><pre><code class="hljs bash">方法 1 ：
<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_color</span></span>() &#123;
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$1</span> == <span class="hljs-string">&quot;green&quot;</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>
  <span class="hljs-keyword">elif</span> [<span class="hljs-variable">$1</span> == <span class="hljs-string">&quot;red&quot;</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>
  <span class="hljs-keyword">fi</span>
&#125;
方法 2 ：
<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_color</span></span>() &#123;
  <span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>
    green)
      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>
    ;;
    red)
      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>
    ;;
    *)
      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Example: echo_color red string&quot;</span>
  <span class="hljs-keyword">esac</span>
&#125;
使用方法：echo_color green <span class="hljs-string">&quot;test&quot;</span></code></pre>

<p><strong>function</strong> 关键字定义一个函数，可加或不加。</p>
<h2 id="12-3-批量创建用户"><a href="#12-3-批量创建用户" class="headerlink" title="12.3 批量创建用户"></a>12.3 批量创建用户</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
DATE=$(date +%F_%T)
USER_FILE=user.txt
<span class="hljs-function"><span class="hljs-title">echo_color</span></span>()&#123;
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$1</span> == <span class="hljs-string">&quot;green&quot;</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>
  <span class="hljs-keyword">elif</span> [<span class="hljs-variable">$1</span> == <span class="hljs-string">&quot;red&quot;</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31;40m<span class="hljs-variable">$2</span>\033[0m&quot;</span>
  <span class="hljs-keyword">fi</span>
&#125;
<span class="hljs-comment"># 如果用户文件存在并且大小大于 0 就备份</span>
<span class="hljs-keyword">if</span> [-s <span class="hljs-variable">$USER_FILE</span>]; <span class="hljs-keyword">then</span>
  mv <span class="hljs-variable">$USER_FILE</span> <span class="hljs-variable">$&#123;USER_FILE&#125;</span>-<span class="hljs-variable">$&#123;DATE&#125;</span>.bak
  echo_color green <span class="hljs-string">&quot;<span class="hljs-variable">$USER_FILE</span> exist, rename <span class="hljs-variable">$&#123;USER_FILE&#125;</span>-<span class="hljs-variable">$&#123;DATE&#125;</span>.bak&quot;</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;User\tPassword&quot;</span> &gt;&gt; <span class="hljs-variable">$USER_FILE</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;----------------&quot;</span> &gt;&gt; <span class="hljs-variable">$USER_FILE</span>

<span class="hljs-keyword">for</span> USER <span class="hljs-keyword">in</span> user&#123;1..10&#125;; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> ! id <span class="hljs-variable">$USER</span> &amp;&gt;/dev/null; <span class="hljs-keyword">then</span>
    PASS=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$RANDOM</span> |md5sum |cut -c 1-8)
    useradd <span class="hljs-variable">$USER</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PASS</span> |passwd --stdin <span class="hljs-variable">$USER</span> &amp;&gt;/dev/null
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>\t<span class="hljs-variable">$PASS</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$USER_FILE</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span> User create successful.&quot;</span>
  <span class="hljs-keyword">else</span>
    echo_color red <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span> User already exists!&quot;</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-4-检查软件包是否安装"><a href="#12-4-检查软件包是否安装" class="headerlink" title="12.4 检查软件包是否安装"></a>12.4 检查软件包是否安装</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">if</span> rpm -q sysstat &amp;&gt;/dev/null; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sysstat is already installed.&quot;</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sysstat is not installed!&quot;</span>
<span class="hljs-keyword">fi</span></code></pre>

<h2 id="12-5-检查服务状态"><a href="#12-5-检查服务状态" class="headerlink" title="12.5 检查服务状态"></a>12.5 检查服务状态</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
PORT_C=$(ss -anu |grep -c 123)
PS_C=$(ps -ef |grep ntpd |grep -vc grep)
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$PORT_C</span> -eq 0 -o <span class="hljs-variable">$PS_C</span> -eq 0]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;内容&quot;</span> | mail - s <span class="hljs-string">&quot;主题&quot;</span> dst@example.com
<span class="hljs-keyword">fi</span></code></pre>

<h2 id="12-6-检查主机存活状态"><a href="#12-6-检查主机存活状态" class="headerlink" title="12.6 检查主机存活状态"></a>12.6 检查主机存活状态</h2><p>方法 1 ：将错误 IP 放到数组里面判断是否 ping 失败三次</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
IP_LIST=<span class="hljs-string">&quot;192.168.18.1 192.168.1.1 192.168.18.2&quot;</span>
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$IP_LIST</span>; <span class="hljs-keyword">do</span>
  NUM=1
  <span class="hljs-keyword">while</span> [<span class="hljs-variable">$NUM</span> -le 3]; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> ping -c 1 <span class="hljs-variable">$IP</span> &gt; /dev/null; <span class="hljs-keyword">then</span>
      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is successful.&quot;</span>
      <span class="hljs-built_in">break</span>
    <span class="hljs-keyword">else</span>
    <span class="hljs-comment"># echo &quot;$IP Ping is failure $NUM&quot;</span>
      FAIL_COUNT[<span class="hljs-variable">$NUM</span>]=<span class="hljs-variable">$IP</span>
      <span class="hljs-built_in">let</span> NUM++
    <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">done</span>
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$&#123;#FAIL_COUNT[*]&#125;</span> -eq 3 ];<span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;FAIL_COUNT[1]&#125;</span> Ping is failure!&quot;</span>
    <span class="hljs-built_in">unset</span> FAIL_COUNT[*]
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<p>方法 2 ：将错误次数放到 FAIL_COUNT 变量里面判断是否 ping 失败三次</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
IP_LIST=<span class="hljs-string">&quot;192.168.18.1 192.168.1.1 192.168.18.2&quot;</span>
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$IP_LIST</span>; <span class="hljs-keyword">do</span>
  FAIL_COUNT=0
  <span class="hljs-keyword">for</span> ((i=1;i&lt;=3;i++)); <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> ping - c 1 <span class="hljs-variable">$IP</span> &gt;/dev/null; <span class="hljs-keyword">then</span>
      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is successful.&quot;</span>
      <span class="hljs-built_in">break</span>
    <span class="hljs-keyword">else</span>
    <span class="hljs-comment"># echo &quot;$IP Ping is failure $i&quot;</span>
      <span class="hljs-built_in">let</span> FAIL_COUNT++
    <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">done</span>
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$FAIL_COUNT</span> -eq 3]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is failure!&quot;</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<p>方法 3 ：利用 for 循环将 ping 通就跳出循环继续，如果不跳出就会走到打印 ping 失败</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">ping_success_status</span></span>() &#123;
  <span class="hljs-keyword">if</span> ping -c 1 <span class="hljs-variable">$IP</span> &gt;/dev/null; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is successful.&quot;</span>
    <span class="hljs-built_in">continue</span>
  <span class="hljs-keyword">fi</span>
&#125;
IP_LIST=<span class="hljs-string">&quot;192.168.18.1 192.168.1.1 192.168.18.2&quot;</span>
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$IP_LIST</span>; <span class="hljs-keyword">do</span>
  ping_success_status
  ping_success_status
  ping_success_status
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> Ping is failure!&quot;</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-7-监控-CPU、内存和硬盘利用率"><a href="#12-7-监控-CPU、内存和硬盘利用率" class="headerlink" title="12.7 监控 CPU、内存和硬盘利用率"></a>12.7 监控 CPU、内存和硬盘利用率</h2><p><strong>1 ）CPU</strong></p>
<p>借助 vmstat 工具来分析 CPU 统计信息。</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
DATE=$(date +%F<span class="hljs-string">&quot; &quot;</span>%H:%M)
IP=$(ifconfig eth0 |awk -F <span class="hljs-string">&#x27;[ :]+&#x27;</span> <span class="hljs-string">&#x27;/inet addr/&#123;print $4&#125;&#x27;</span>) <span class="hljs-comment"># 只支持 CentOS6</span>
MAIL=<span class="hljs-string">&quot;example@mail.com&quot;</span>
<span class="hljs-keyword">if</span> ! <span class="hljs-built_in">which</span> vmstat &amp;&gt;/dev/null; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;vmstat command no found, Please install procps package.&quot;</span>
  <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>
US=$(vmstat |awk <span class="hljs-string">&#x27;NR==3&#123;print $13&#125;&#x27;</span>)
SY=$(vmstat |awk <span class="hljs-string">&#x27;NR==3&#123;print $14&#125;&#x27;</span>)
IDLE=$(vmstat |awk <span class="hljs-string">&#x27;NR==3&#123;print $15&#125;&#x27;</span>)
WAIT=$(vmstat |awk <span class="hljs-string">&#x27;NR==3&#123;print $16&#125;&#x27;</span>)
USE=$((<span class="hljs-variable">$US</span>+<span class="hljs-variable">$SY</span>))
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$USE</span> -ge 50]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;</span>
<span class="hljs-string">  Date: <span class="hljs-variable">$DATE</span></span>
<span class="hljs-string">  Host: <span class="hljs-variable">$IP</span></span>
<span class="hljs-string">  Problem: CPU utilization <span class="hljs-variable">$USE</span></span>
<span class="hljs-string">  &quot;</span>| mail -s<span class="hljs-string">&quot;CPU Monitor&quot;</span> <span class="hljs-variable">$MAIL</span>
<span class="hljs-keyword">fi</span></code></pre>

<p><strong>2 ）内存</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
DATE=$(date +%F<span class="hljs-string">&quot; &quot;</span>%H:%M)
IP=$(ifconfig eth0 |awk -F <span class="hljs-string">&#x27;[ :]+&#x27;</span> <span class="hljs-string">&#x27;/inet addr/&#123;print $4&#125;&#x27;</span>)
MAIL=<span class="hljs-string">&quot;example@mail.com&quot;</span>
TOTAL=$(free -m |awk <span class="hljs-string">&#x27;/Mem/&#123;print $2&#125;&#x27;</span>)
USE=$(free -m |awk <span class="hljs-string">&#x27;/Mem/&#123;print $3-$6-$7&#125;&#x27;</span>)
FREE=$((<span class="hljs-variable">$TOTAL</span>-<span class="hljs-variable">$USE</span>))
<span class="hljs-comment"># 内存小于 1G 发送报警邮件</span>
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$FREE</span> -lt 1024]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;</span>
<span class="hljs-string">  Date: <span class="hljs-variable">$DATE</span></span>
<span class="hljs-string">  Host: <span class="hljs-variable">$IP</span></span>
<span class="hljs-string">  Problem: Total=<span class="hljs-variable">$TOTAL</span>,Use=<span class="hljs-variable">$USE</span>,Free=<span class="hljs-variable">$FREE</span></span>
<span class="hljs-string">  &quot;</span>| mail -s<span class="hljs-string">&quot;Memory Monitor&quot;</span> <span class="hljs-variable">$MAIL</span>
<span class="hljs-keyword">fi</span></code></pre>

<p><strong>3 ）硬盘</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
DATE=$(date +%F<span class="hljs-string">&quot; &quot;</span>%H:%M)
IP=$(ifconfig eth0 |awk -F <span class="hljs-string">&#x27;[ :]+&#x27;</span> <span class="hljs-string">&#x27;/inet addr/&#123;print $4&#125;&#x27;</span>)
MAIL=<span class="hljs-string">&quot;example@mail.com&quot;</span>
TOTAL=$(fdisk -l |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;BEGIN&#123;OFS=&quot;=&quot;&#125;/^Disk \/dev/&#123;printf&quot;%s=%sG,&quot;,$2,$3&#125;&#x27;</span>)
PART_USE=$(df -h |awk <span class="hljs-string">&#x27;BEGIN&#123;OFS=&quot;=&quot;&#125;/^\/dev/&#123;print $1,int($5),$6&#125;&#x27;</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$PART_USE</span>; <span class="hljs-keyword">do</span>
  PART=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span> |cut -d<span class="hljs-string">&quot;=&quot;</span> -f1)
  USE=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span> |cut -d<span class="hljs-string">&quot;=&quot;</span> -f2)
  MOUNT=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span> |cut -d<span class="hljs-string">&quot;=&quot;</span> -f3)
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$USE</span> -gt 80]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;</span>
<span class="hljs-string">    Date: <span class="hljs-variable">$DATE</span></span>
<span class="hljs-string">    Host: <span class="hljs-variable">$IP</span></span>
<span class="hljs-string">    Total: <span class="hljs-variable">$TOTAL</span></span>
<span class="hljs-string">    Problem: <span class="hljs-variable">$PART</span>=<span class="hljs-variable">$USE</span>(<span class="hljs-variable">$MOUNT</span>)</span>
<span class="hljs-string">    &quot;</span>| mail -s<span class="hljs-string">&quot;Disk Monitor&quot;</span> <span class="hljs-variable">$MAIL</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-8-批量主机磁盘利用率监控"><a href="#12-8-批量主机磁盘利用率监控" class="headerlink" title="12.8 批量主机磁盘利用率监控"></a>12.8 批量主机磁盘利用率监控</h2><p>前提监控端和被监控端 SSH 免交互登录或者密钥登录。</p>
<p>写一个配置文件保存被监控主机 SSH 连接信息，文件内容格式：IP User Port</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
HOST_INFO=host.info
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> $(awk <span class="hljs-string">&#x27;/^[^#]/&#123;print $1&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>); <span class="hljs-keyword">do</span>
  USER=$(awk -v ip=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;ip==$1&#123;print $2&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)
  PORT=$(awk -v ip=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;ip==$1&#123;print $3&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)
  TMP_FILE=/tmp/disk.tmp
  ssh -p <span class="hljs-variable">$PORT</span> <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;df -h&#x27;</span> &gt; <span class="hljs-variable">$TMP_FILE</span>
  USE_RATE_LIST=$(awk <span class="hljs-string">&#x27;BEGIN&#123;OFS=&quot;=&quot;&#125;/^\/dev/&#123;print $1,int($5)&#125;&#x27;</span> <span class="hljs-variable">$TMP_FILE</span>)
  <span class="hljs-keyword">for</span> USE_RATE <span class="hljs-keyword">in</span> <span class="hljs-variable">$USE_RATE_LIST</span>; <span class="hljs-keyword">do</span>
    PART_NAME=<span class="hljs-variable">$&#123;USE_RATE%=*&#125;</span>
    USE_RATE=<span class="hljs-variable">$&#123;USE_RATE#*=&#125;</span>
    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$USE_RATE</span> - ge 80]; <span class="hljs-keyword">then</span>
      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$PART_NAME</span> Partition usage <span class="hljs-variable">$USE_RATE</span>%!&quot;</span>
    <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">done</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-9-检查网站可用性"><a href="#12-9-检查网站可用性" class="headerlink" title="12.9 检查网站可用性"></a>12.9 检查网站可用性</h2><p><strong>1 ）检查 URL 可用性</strong></p>
<pre><code class="hljs bash">方法 1 ：
<span class="hljs-function"><span class="hljs-title">check_url</span></span>() &#123;
HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="hljs-string">&quot;%&#123;http_code&#125;&quot;</span> <span class="hljs-variable">$1</span>)
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -ne 200]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$1</span> Access failure!&quot;</span>
<span class="hljs-keyword">fi</span>
&#125;
方法 2 ：
<span class="hljs-function"><span class="hljs-title">check_url</span></span>() &#123;
<span class="hljs-keyword">if</span> ! wget -T 10 --tries=1 --spider <span class="hljs-variable">$1</span> &gt;/dev/null 2&gt;&amp;1; <span class="hljs-keyword">then</span>
  <span class="hljs-comment">#-T 超时时间，--tries 尝试 1 次，--spider 爬虫模式</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$1</span> Access failure!&quot;</span>
<span class="hljs-keyword">fi</span>
&#125;
使用方法：check_url www.baidu.com</code></pre>

<p><strong>2 ）判断三次 URL 可用性</strong></p>
<p>思路与上面检查主机存活状态一样。</p>
<pre><code class="hljs bash">方法 1 ：利用循环技巧，如果成功就跳出当前循环，否则执行到最后一行
<span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">check_url</span></span>() &#123;
  HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="hljs-string">&quot;%&#123;http_code&#125;&quot;</span> <span class="hljs-variable">$1</span>)
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -eq 200]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">continue</span>
  <span class="hljs-keyword">fi</span>
&#125;
URL_LIST=<span class="hljs-string">&quot;www.baidu.com www.agasgf.com&quot;</span>
<span class="hljs-keyword">for</span> URL <span class="hljs-keyword">in</span> <span class="hljs-variable">$URL_LIST</span>; <span class="hljs-keyword">do</span>
  check_url <span class="hljs-variable">$URL</span>
  check_url <span class="hljs-variable">$URL</span>
  check_url <span class="hljs-variable">$URL</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$URL</span> Access failure!&quot;</span>
<span class="hljs-keyword">done</span>

方法 2 ：错误次数保存到变量
<span class="hljs-meta">#!/bin/bash</span>
URL_LIST=<span class="hljs-string">&quot;www.baidu.com www.agasgf.com&quot;</span>
<span class="hljs-keyword">for</span> URL <span class="hljs-keyword">in</span> <span class="hljs-variable">$URL_LIST</span>; <span class="hljs-keyword">do</span>
  FAIL_COUNT=0
  <span class="hljs-keyword">for</span> ((i=1;i&lt;=3;i++)); <span class="hljs-keyword">do</span>
    HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="hljs-string">&quot;%&#123;http_code&#125;&quot;</span> <span class="hljs-variable">$URL</span>)
    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -ne 200]; <span class="hljs-keyword">then</span>
      <span class="hljs-built_in">let</span> FAIL_COUNT++
    <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">break</span>
    <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">done</span>
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$FAIL_COUNT</span> -eq 3]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$URL</span> Access failure!&quot;</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>

方法 3 ：错误次数保存到数组
<span class="hljs-meta">#!/bin/bash</span>
URL_LIST=<span class="hljs-string">&quot;www.baidu.com www.agasgf.com&quot;</span>
<span class="hljs-keyword">for</span> URL <span class="hljs-keyword">in</span> <span class="hljs-variable">$URL_LIST</span>; <span class="hljs-keyword">do</span>
  NUM=1
  <span class="hljs-keyword">while</span> [<span class="hljs-variable">$NUM</span> -le 3]; <span class="hljs-keyword">do</span>
    HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w <span class="hljs-string">&quot;%&#123;http_code&#125;&quot;</span> <span class="hljs-variable">$URL</span>)
    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$HTTP_CODE</span> -ne 200]; <span class="hljs-keyword">then</span>
      FAIL_COUNT[<span class="hljs-variable">$NUM</span>]=<span class="hljs-variable">$IP</span> <span class="hljs-comment">#创建数组，以 $NUM 下标，$IP 元素</span>
      <span class="hljs-built_in">let</span> NUM++
    <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">break</span>
    <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">done</span>
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$&#123;#FAIL_COUNT[*]&#125;</span> -eq 3 ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning: <span class="hljs-variable">$URL</span> Access failure!&quot;</span>
    <span class="hljs-built_in">unset</span> FAIL_COUNT[*] <span class="hljs-comment">#清空数组</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-10-检查-MySQL-主从同步状态"><a href="#12-10-检查-MySQL-主从同步状态" class="headerlink" title="12.10 检查 MySQL 主从同步状态"></a>12.10 检查 MySQL 主从同步状态</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
USER=bak
PASSWD=123 456
IO_SQL_STATUS=$(mysql -u<span class="hljs-variable">$USER</span> -p<span class="hljs-variable">$PASSWD</span> -e <span class="hljs-string">&#x27;show slave status\G&#x27;</span> |awk -F:<span class="hljs-string">&#x27;/Slave_.*_Running/&#123;gsub(&quot;: &quot;,&quot;:&quot;);print $0&#125;&#x27;</span>) <span class="hljs-comment">#gsub 去除冒号后面的空格</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$IO_SQL_STATUS</span>; <span class="hljs-keyword">do</span>
  THREAD_STATUS_NAME=<span class="hljs-variable">$&#123;i%:*&#125;</span>
  THREAD_STATUS=<span class="hljs-variable">$&#123;i#*:&#125;</span>
  <span class="hljs-keyword">if</span> [<span class="hljs-string">&quot;<span class="hljs-variable">$THREAD_STATUS</span>&quot;</span> != <span class="hljs-string">&quot;Yes&quot;</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: MySQL Master-Slave <span class="hljs-variable">$THREAD_STATUS_NAME</span> status is</span>
<span class="hljs-string">    <span class="hljs-variable">$THREAD_STATUS</span>!&quot;</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-11-屏蔽网站访问频繁的-IP"><a href="#12-11-屏蔽网站访问频繁的-IP" class="headerlink" title="12. 11 屏蔽网站访问频繁的 IP"></a>12. 11 屏蔽网站访问频繁的 IP</h2><p><strong>1 ）屏蔽每分钟访问超过 200 的 IP</strong></p>
<pre><code class="hljs bash">方法 1 ：以 Nginx 日志作为测试
DATE=$(date +%d/%b/%Y:%H:%M)
ABNORMAL_IP=$(tail -n5000 access.log |grep <span class="hljs-variable">$DATE</span> |awk <span class="hljs-string">&#x27;&#123;a[$1]++&#125;END&#123;for(i in a)if(a[i]&gt;100)print i&#125;&#x27;</span>)
<span class="hljs-comment">#先 tail 防止文件过大，读取慢，数字可调整每分钟最大的访问量。awk 不能直接过滤日志，因为包含特殊字符。</span>
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$ABNORMAL_IP</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> [$(iptables -vnL |grep -c <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span>&quot;</span>) -eq 0 ]; <span class="hljs-keyword">then</span>
    iptables -I INPUT -s <span class="hljs-variable">$IP</span> -j DROP
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
方法 2 ：通过建立连接数
ABNORMAL_IP=$(netstat -an |awk <span class="hljs-string">&#x27;$4~/:80$/ &amp;&amp; $6~/ESTABLISHED/&#123;gsub(/:[0-9]+/,&quot;&quot;,$5);&#123;a[$5]++&#125;&#125;END&#123;for(i in a)if(a[i]&gt;100)print i&#125;&#x27;</span>)
<span class="hljs-comment">#gsub 是将第五列（客户端 IP）的冒号和端口去掉</span>
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$ABNORMAL_IP</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> [$(iptables -vnL |grep -c <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span>&quot;</span>) -eq 0 ]; <span class="hljs-keyword">then</span>
    iptables -I INPUT -s <span class="hljs-variable">$IP</span> -j DROP
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<p><strong>2 ）屏蔽每分钟 SSH 暴力破解超过 10 次的 IP</strong></p>
<pre><code class="hljs bash">方法 1 ：通过 lastb 获取登录状态:
DATE=$(date +<span class="hljs-string">&quot;%a %b %e %H:%M&quot;</span>) <span class="hljs-comment">#星期月天时分 %e 单数字时显示 7 ，而 %d 显示 07</span>
ABNORMAL_IP=$(lastb |grep <span class="hljs-string">&quot;<span class="hljs-variable">$DATE</span>&quot;</span> |awk <span class="hljs-string">&#x27;&#123;a[$3]++&#125;END&#123;for(i in a)if(a[i]&gt;10)print i&#125;&#x27;</span>)
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$ABNORMAL_IP</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> [$(iptables -vnL |grep -c <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span>&quot;</span>) -eq 0 ]; <span class="hljs-keyword">then</span>
    iptables -I INPUT -s <span class="hljs-variable">$IP</span> -j DROP
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>

方法 2 ：通过日志获取登录状态
DATE=$(date +<span class="hljs-string">&quot;%b %d %H&quot;</span>)
ABNORMAL_IP=<span class="hljs-string">&quot;<span class="hljs-subst">$(tail -n10000 /var/log/auth.log |grep<span class="hljs-string">&quot;<span class="hljs-variable">$DATE</span>&quot;</span>|awk&#x27;/Failed/&#123;a[$(NF-3)</span>]++&#125;END&#123;for(i in a)if(a[i]&gt;5)print i&#125;&#x27;)&quot;</span>
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> <span class="hljs-variable">$ABNORMAL_IP</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> [$(iptables -vnL |grep -c <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span>&quot;</span>) -eq 0 ]; <span class="hljs-keyword">then</span>
    iptables -A INPUT -s <span class="hljs-variable">$IP</span> -j DROP
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(date +<span class="hljs-string">&quot;%F %T&quot;</span>)</span> - iptables -A INPUT -s <span class="hljs-variable">$IP</span> -j DROP&quot;</span> &gt;&gt;~/ssh-login-limit.log
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-12-判断输入是否为-IP"><a href="#12-12-判断输入是否为-IP" class="headerlink" title="12.12 判断输入是否为 IP"></a>12.12 判断输入是否为 IP</h2><p><strong>方法 1:</strong></p>
<pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_ip</span></span>()&#123;
  IP=<span class="hljs-variable">$1</span>
  VALID_CHECK=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|awk -F. <span class="hljs-string">&#x27;$1&lt;=255&amp;&amp;$2&lt;=255&amp;&amp;$3&lt;=255&amp;&amp;$4&lt;=255&#123;print&quot;yes&quot;&#125;&#x27;</span>)
  <span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|grep -E <span class="hljs-string">&quot;^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$&quot;</span>&gt;/dev/null;<span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$VALID_CHECK</span> == <span class="hljs-string">&quot;yes&quot;</span>]; <span class="hljs-keyword">then</span>
      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> available.&quot;</span>
    <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> not available!&quot;</span>
    <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Format error!&quot;</span>
  <span class="hljs-keyword">fi</span>
&#125;
check_ip 192.168.1.1
check_ip 256.1.1.1

方法 2 ：
<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_ip</span></span>()&#123;
IP=<span class="hljs-variable">$1</span>
<span class="hljs-keyword">if</span> [[<span class="hljs-variable">$IP</span> =~ ^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$ ]]; <span class="hljs-keyword">then</span>
  FIELD1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|cut -d. -f1)
  FIELD2=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|cut -d. -f2)
  FIELD3=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|cut -d. -f3)
  FIELD4=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|cut -d. -f4)
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$FIELD1</span> -le 255 -a <span class="hljs-variable">$FIELD2</span> -le 255 -a <span class="hljs-variable">$FIELD3</span> -le 255 -a <span class="hljs-variable">$FIELD4</span> -le 255]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> available.&quot;</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> not available!&quot;</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Format error!&quot;</span>
<span class="hljs-keyword">fi</span>
&#125;
check_ip 192.168.1.1
check_ip 256.1.1.1</code></pre>

<p>增加版：加个死循环，如果 IP 可用就退出，不可用提示继续输入，并使用 awk 判断</p>
<pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_ip</span></span>()&#123;
<span class="hljs-built_in">local</span> IP=<span class="hljs-variable">$1</span>
VALID_CHECK=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|awk -F. <span class="hljs-string">&#x27;$1&lt;=255&amp;&amp;$2&lt;=255&amp;&amp;$3&lt;=255&amp;&amp;$4&lt;=255&#123;print&quot;yes&quot;&#125;&#x27;</span>)
<span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$IP</span>|grep -E <span class="hljs-string">&quot;^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$&quot;</span> &gt;/dev/null;<span class="hljs-keyword">then</span>
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$VALID_CHECK</span> == <span class="hljs-string">&quot;yes&quot;</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">return</span> 0
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> not available!&quot;</span>
    <span class="hljs-built_in">return</span> 1
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Format error! Please input again.&quot;</span>
  <span class="hljs-built_in">return</span> 1
<span class="hljs-keyword">fi</span>
&#125;
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please enter IP:&quot;</span> IP
  check_ip <span class="hljs-variable">$IP</span>
  [$? -eq 0] &amp;&amp; <span class="hljs-built_in">break</span> || <span class="hljs-built_in">continue</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-13-判断输入是否为数字"><a href="#12-13-判断输入是否为数字" class="headerlink" title="12.13 判断输入是否为数字"></a>12.13 判断输入是否为数字</h2><pre><code class="hljs bash">方法 1 ：
<span class="hljs-keyword">if</span> [[<span class="hljs-variable">$1</span> =~ ^[0-9]+$ ]]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Is Number.&quot;</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No Number.&quot;</span>
<span class="hljs-keyword">fi</span>

方法 2 ：
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$1</span> -gt 0] 2&gt;/dev/null; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Is Number.&quot;</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No Number.&quot;</span>
<span class="hljs-keyword">fi</span>

方法 3 ：
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span> |awk <span class="hljs-string">&#x27;&#123;print $0~/^[0-9]+$/?&quot;Is Number.&quot;:&quot;No Number.&quot;&#125;&#x27;</span> <span class="hljs-comment">#三目运算符</span></code></pre>

<h2 id="12-14-找出包含关键字的文件"><a href="#12-14-找出包含关键字的文件" class="headerlink" title="12.14 找出包含关键字的文件"></a>12.14 找出包含关键字的文件</h2><pre><code class="hljs bash">DIR=<span class="hljs-variable">$1</span>
KEY=<span class="hljs-variable">$2</span>

<span class="hljs-keyword">for</span> FILE <span class="hljs-keyword">in</span> $(find <span class="hljs-variable">$DIR</span> -<span class="hljs-built_in">type</span> f); <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> grep <span class="hljs-variable">$KEY</span> <span class="hljs-variable">$FILE</span> &amp;&gt;/dev/null; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;--&gt; <span class="hljs-variable">$FILE</span>&quot;</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-15-监控目录，将新创建的文件名追加到日志中"><a href="#12-15-监控目录，将新创建的文件名追加到日志中" class="headerlink" title="12.15 监控目录，将新创建的文件名追加到日志中"></a>12.15 监控目录，将新创建的文件名追加到日志中</h2><p>需安装 <code>inotify-tools</code> 软件包。</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
MON_DIR=/opt
inotifywait -mq --format %f -e create <span class="hljs-variable">$MON_DIR</span> |\
<span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> files; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$files</span> &gt;&gt; test.log
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-16-多个网卡选择"><a href="#12-16-多个网卡选择" class="headerlink" title="12.16 多个网卡选择"></a>12.16 多个网卡选择</h2><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">local_nic</span></span>() &#123;
  <span class="hljs-built_in">local</span> NUM ARRAY_LENGTH
  NUM=0
  <span class="hljs-keyword">for</span> NIC_NAME <span class="hljs-keyword">in</span> $(ls /sys/class/net|grep - vE <span class="hljs-string">&quot;lo|docker0&quot;</span>); <span class="hljs-keyword">do</span>
    NIC_IP=$(ifconfig <span class="hljs-variable">$NIC_NAME</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/inet addr/&#123;print $4&#125;&#x27;</span>)
    <span class="hljs-keyword">if</span> [-n <span class="hljs-string">&quot;<span class="hljs-variable">$NIC_IP</span>&quot;</span>]; <span class="hljs-keyword">then</span>
      NIC_IP_ARRAY[<span class="hljs-variable">$NUM</span>]=<span class="hljs-string">&quot;<span class="hljs-variable">$NIC_NAME</span>:<span class="hljs-variable">$NIC_IP</span>&quot;</span> <span class="hljs-comment">#将网卡名和对应 IP 放到数组</span>
      <span class="hljs-built_in">let</span> NUM++
    <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">done</span>
  ARRAY_LENGTH=<span class="hljs-variable">$&#123;#NIC_IP_ARRAY[*]&#125;</span>
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$ARRAY_LENGTH</span> -eq 1]; <span class="hljs-keyword">then</span> <span class="hljs-comment">#如果数组里面只有一条记录说明就一个网卡</span>
    NIC=<span class="hljs-variable">$&#123;NIC_IP_ARRAY[0]%:*&#125;</span>
    <span class="hljs-built_in">return</span> 0
  <span class="hljs-keyword">elif</span> [<span class="hljs-variable">$ARRAY_LENGTH</span> -eq 0]; <span class="hljs-keyword">then</span> <span class="hljs-comment">#如果没有记录说明没有网卡</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No available network card!&quot;</span>
    <span class="hljs-built_in">exit</span> 1
  <span class="hljs-keyword">else</span>
  <span class="hljs-comment">#如果有多条记录则提醒输入选择</span>
    <span class="hljs-keyword">for</span> NIC <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;NIC_IP_ARRAY[*]&#125;</span>; <span class="hljs-keyword">do</span>
      <span class="hljs-built_in">echo</span> <span class="hljs-variable">$NIC</span>
    <span class="hljs-keyword">done</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>
      <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please enter local use to network card name:&quot;</span> INPUT_NIC_NAME
      COUNT=0
      <span class="hljs-keyword">for</span> NIC <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;NIC_IP_ARRAY[*]&#125;</span>; <span class="hljs-keyword">do</span>
        NIC_NAME=<span class="hljs-variable">$&#123;NIC%:*&#125;</span>
        <span class="hljs-keyword">if</span> [<span class="hljs-variable">$NIC_NAME</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$INPUT_NIC_NAME</span>&quot;</span>]; <span class="hljs-keyword">then</span>
          NIC=<span class="hljs-variable">$&#123;NIC_IP_ARRAY[$COUNT]%:*&#125;</span>
          <span class="hljs-built_in">return</span> 0
        <span class="hljs-keyword">else</span>
          COUNT+=1
        <span class="hljs-keyword">fi</span>
      <span class="hljs-keyword">done</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Not match! Please input again.&quot;</span>
    <span class="hljs-keyword">done</span>
  <span class="hljs-keyword">fi</span>
&#125;
local_nic</code></pre>

<p>如果有只有一个网卡就不选择。</p>
<h2 id="12-17-查看网卡实时流量"><a href="#12-17-查看网卡实时流量" class="headerlink" title="12.17 查看网卡实时流量"></a>12.17 查看网卡实时流量</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># Description: Only CentOS6</span>
<span class="hljs-function"><span class="hljs-title">traffic_unit_conv</span></span>() &#123;
  <span class="hljs-built_in">local</span> traffic=<span class="hljs-variable">$1</span>
  <span class="hljs-keyword">if</span> [<span class="hljs-variable">$traffic</span> -gt 1024000]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%.1f%s&quot;</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(($traffic/1024/1024)</span>)&quot;</span> <span class="hljs-string">&quot;MB/s&quot;</span>
  <span class="hljs-keyword">elif</span> [<span class="hljs-variable">$traffic</span> -lt 1024000]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%.1f%s&quot;</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(($traffic/1024)</span>)&quot;</span> <span class="hljs-string">&quot;KB/s&quot;</span>
  <span class="hljs-keyword">fi</span>
&#125;
NIC=<span class="hljs-variable">$1</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;In ------ Out&quot;</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>
  OLD_IN=$(awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;$0~&quot;&#x27;</span><span class="hljs-variable">$NIC</span><span class="hljs-string">&#x27;&quot;&#123;print $3&#125;&#x27;</span> /proc/net/dev)
  OLD_OUT=$(awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;$0~&quot;&#x27;</span><span class="hljs-variable">$NIC</span><span class="hljs-string">&#x27;&quot;&#123;print $11&#125;&#x27;</span> /proc/net/dev)
  sleep 1
  NEW_IN=$(awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;$0~&quot;&#x27;</span><span class="hljs-variable">$NIC</span><span class="hljs-string">&#x27;&quot;&#123;print $3&#125;&#x27;</span> /proc/net/dev)
  NEW_OUT=$(awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;$0~&quot;&#x27;</span><span class="hljs-variable">$NIC</span><span class="hljs-string">&#x27;&quot;&#123;print $11&#125;&#x27;</span> /proc/net/dev)
  IN=$((<span class="hljs-variable">$NEW_IN</span>-<span class="hljs-variable">$OLD_IN</span>))
  OUT=$((<span class="hljs-variable">$NEW_OUT</span>-<span class="hljs-variable">$OLD_OUT</span>))
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(traffic_unit_conv $IN)</span> <span class="hljs-subst">$(traffic_unit_conv $OUT)</span>&quot;</span>
  sleep 1
<span class="hljs-keyword">done</span>

<span class="hljs-comment"># 也可以通过 ficonfig 命令获取收发流量</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>
  OLD_IN=$(ifconfig <span class="hljs-variable">$NIC</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/bytes/&#123;print $4&#125;&#x27;</span>)
  OLD_OUT=$(ifconfig <span class="hljs-variable">$NIC</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/bytes/&#123;print $9&#125;&#x27;</span>)
  sleep 1
  NEW_IN=$(ifconfig <span class="hljs-variable">$NIC</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/bytes/&#123;print $4&#125;&#x27;</span>)
  NEW_OUT=$(ifconfig <span class="hljs-variable">$NIC</span> |awk -F<span class="hljs-string">&#x27;[:]+&#x27;</span> <span class="hljs-string">&#x27;/bytes/&#123;print $9&#125;&#x27;</span>)
  IN=$((<span class="hljs-variable">$NEW_IN</span>-<span class="hljs-variable">$OLD_IN</span>))
  OUT=$((<span class="hljs-variable">$NEW_OUT</span>-<span class="hljs-variable">$OLD_OUT</span>))
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(traffic_unit_conv $IN)</span> <span class="hljs-subst">$(traffic_unit_conv $OUT)</span>&quot;</span>
  sleep 1
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-18-MySQL-数据库备份"><a href="#12-18-MySQL-数据库备份" class="headerlink" title="12.18 MySQL 数据库备份"></a>12.18 MySQL 数据库备份</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
DATE=$(date +%F_%H-%M-%S)
HOST=192.168.1.120
DB=<span class="hljs-built_in">test</span>
USER=bak
PASS=123456
MAIL=<span class="hljs-string">&quot;zhangsan@example.com lisi@example.com&quot;</span>
BACKUP_DIR=/data/db_backup
SQL_FILE=<span class="hljs-variable">$&#123;DB&#125;</span>_full_<span class="hljs-variable">$DATE</span>.sql
BAK_FILE=<span class="hljs-variable">$&#123;DB&#125;</span>_full_<span class="hljs-variable">$DATE</span>.zip
<span class="hljs-built_in">cd</span> <span class="hljs-variable">$BACKUP_DIR</span>
<span class="hljs-keyword">if</span> mysqldump - h<span class="hljs-variable">$HOST</span> - u<span class="hljs-variable">$USER</span> - p<span class="hljs-variable">$PASS</span> --single-transaction --routines --triggers - B <span class="hljs-variable">$DB</span> &gt; <span class="hljs-variable">$SQL_FILE</span>; <span class="hljs-keyword">then</span>
  zip <span class="hljs-variable">$BAK_FILE</span> <span class="hljs-variable">$SQL_FILE</span> &amp;&amp; rm - f <span class="hljs-variable">$SQL_FILE</span>
  <span class="hljs-keyword">if</span> [! - s <span class="hljs-variable">$BAK_FILE</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$DATE</span> 内容&quot;</span> | mail -s <span class="hljs-string">&quot;主题&quot;</span> <span class="hljs-variable">$MAIL</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$DATE</span> 内容&quot;</span> | mail -s <span class="hljs-string">&quot;主题&quot;</span> <span class="hljs-variable">$MAIL</span>
<span class="hljs-keyword">fi</span>
find <span class="hljs-variable">$BACKUP_DIR</span> -name <span class="hljs-string">&#x27;*.zip&#x27;</span> -ctime +14 -<span class="hljs-built_in">exec</span> rm &#123;&#125; \;</code></pre>

<h2 id="12-19-Nginx-启动脚本"><a href="#12-19-Nginx-启动脚本" class="headerlink" title="12.19 Nginx 启动脚本"></a>12.19 Nginx 启动脚本</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># Description: Only support RedHat system</span>
. /etc/init.d/<span class="hljs-built_in">functions</span>

WORD_DIR=/data/project/nginx1.10
DAEMON=<span class="hljs-variable">$WORD_DIR</span>/sbin/nginx
CONF=<span class="hljs-variable">$WORD_DIR</span>/conf/nginx.conf
NAME=nginx

PID=$(awk -F<span class="hljs-string">&#x27;[;]+&#x27;</span> <span class="hljs-string">&#x27;/^[^#]/&#123;if($0~/pid;/)print $2&#125;&#x27;</span> <span class="hljs-variable">$CONF</span>)
<span class="hljs-keyword">if</span> [-z <span class="hljs-string">&quot;<span class="hljs-variable">$PID</span>&quot;</span>]; <span class="hljs-keyword">then</span>
  PID=<span class="hljs-variable">$WORD_DIR</span>/logs/nginx.pid
<span class="hljs-keyword">else</span>
  PID=<span class="hljs-variable">$WORD_DIR</span>/<span class="hljs-variable">$PID</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-function"><span class="hljs-title">stop</span></span>() &#123;
  <span class="hljs-variable">$DAEMON</span> -s stop
  sleep 1
  [! -f <span class="hljs-variable">$PID</span>] &amp;&amp; action <span class="hljs-string">&quot;* Stopping <span class="hljs-variable">$NAME</span>&quot;</span> /bin/<span class="hljs-literal">true</span> || action <span class="hljs-string">&quot;* Stopping <span class="hljs-variable">$NAME</span>&quot;</span> /bin/<span class="hljs-literal">false</span>
&#125;
<span class="hljs-function"><span class="hljs-title">start</span></span>() &#123;
  <span class="hljs-variable">$DAEMON</span>
  sleep 1
  [-f <span class="hljs-variable">$PID</span>] &amp;&amp; action <span class="hljs-string">&quot;* Starting <span class="hljs-variable">$NAME</span>&quot;</span> /bin/<span class="hljs-literal">true</span> || action <span class="hljs-string">&quot;* Starting <span class="hljs-variable">$NAME</span>&quot;</span> /bin/<span class="hljs-literal">false</span>
&#125;
<span class="hljs-function"><span class="hljs-title">reload</span></span>() &#123;
  <span class="hljs-variable">$DAEMON</span> -s reload
&#125;
<span class="hljs-function"><span class="hljs-title">test_config</span></span>() &#123;
  <span class="hljs-variable">$DAEMON</span> -t
&#125;

<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span>
  start)
  <span class="hljs-keyword">if</span> [! -f <span class="hljs-variable">$PID</span>]; <span class="hljs-keyword">then</span>
    start
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> is running...&quot;</span>
    <span class="hljs-built_in">exit</span> 0
  <span class="hljs-keyword">fi</span>
  ;;
  stop)
  <span class="hljs-keyword">if</span> [-f <span class="hljs-variable">$PID</span>]; <span class="hljs-keyword">then</span>
    stop
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> not running!&quot;</span>
    <span class="hljs-built_in">exit</span> 0
  <span class="hljs-keyword">fi</span>
  ;;
  restart)
  <span class="hljs-keyword">if</span> [! -f <span class="hljs-variable">$PID</span>]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> not running!&quot;</span>
    start
  <span class="hljs-keyword">else</span>
    stop
    start
  <span class="hljs-keyword">fi</span>
  ;;
  reload)
  reload
  ;;
  testconfig)
  test_config
  ;;
  status)
  [-f <span class="hljs-variable">$PID</span>] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> is running...&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span> not running!&quot;</span>
  ;;
  *)
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: $ 0 &#123;start|stop|restart|reload|testconfig|status&#125;&quot;</span>
  <span class="hljs-built_in">exit</span> 3
  ;;
<span class="hljs-keyword">esac</span></code></pre>

<h2 id="12-20-选择-SSH-连接主机"><a href="#12-20-选择-SSH-连接主机" class="headerlink" title="12.20 选择 SSH 连接主机"></a>12.20 选择 SSH 连接主机</h2><p>写一个配置文件保存被监控主机 SSH 连接信息，文件内容格式：主机名 IP User Port</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
PS3=<span class="hljs-string">&quot;Please input number:&quot;</span>
HOST_FILE=host
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>
  select NAME <span class="hljs-keyword">in</span> $(awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="hljs-variable">$HOST_FILE</span>) quit; <span class="hljs-keyword">do</span>
    [<span class="hljs-variable">$&#123;NAME:=empty&#125;</span> == <span class="hljs-string">&quot;quit&quot;</span> ] &amp;&amp; <span class="hljs-built_in">exit</span> 0
    IP=$(awk - v NAME=<span class="hljs-variable">$&#123;NAME&#125;</span> <span class="hljs-string">&#x27;$1==NAME&#123;print $2&#125;&#x27;</span> <span class="hljs-variable">$HOST_FILE</span>)
    USER=$(awk - v NAME=<span class="hljs-variable">$&#123;NAME&#125;</span> <span class="hljs-string">&#x27;$1==NAME&#123;print $3&#125;&#x27;</span> <span class="hljs-variable">$HOST_FILE</span>)
    PORT=$(awk - v NAME=<span class="hljs-variable">$&#123;NAME&#125;</span> <span class="hljs-string">&#x27;$1==NAME&#123;print $4&#125;&#x27;</span> <span class="hljs-variable">$HOST_FILE</span>)
    <span class="hljs-keyword">if</span> [<span class="hljs-variable">$IP</span>]; <span class="hljs-keyword">then</span>
      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Name: <span class="hljs-variable">$NAME</span>, IP: <span class="hljs-variable">$IP</span>&quot;</span>
      ssh -o StrictHostKeyChecking=no -p <span class="hljs-variable">$PORT</span> -i id_rsa <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span> <span class="hljs-comment"># 密钥登录</span>
      <span class="hljs-built_in">break</span>
    <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Input error, Please enter again!&quot;</span>
      <span class="hljs-built_in">break</span>
    <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">done</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-21-FTP-下载文件"><a href="#12-21-FTP-下载文件" class="headerlink" title="12.21 FTP 下载文件"></a>12.21 FTP 下载文件</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">if</span> [<span class="hljs-variable">$#</span> -ne 1]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$0</span> filename&quot;</span>
<span class="hljs-keyword">fi</span>
dir=$(dirname <span class="hljs-variable">$1</span>)
file=$(basename <span class="hljs-variable">$1</span>)
ftp -n -v &lt;&lt; EOF <span class="hljs-comment"># -n 自动登录</span>
open 192.168.1.10
user admin adminpass
binary <span class="hljs-comment"># 设置 ftp 传输模式为二进制，避免 MD5 值不同或. tar.gz 压缩包格式错误</span>
<span class="hljs-built_in">cd</span> <span class="hljs-variable">$dir</span>
get <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>
EOF</code></pre>

<h2 id="12-22-输入五个-100-数之内的字符，统计和、最小和最大"><a href="#12-22-输入五个-100-数之内的字符，统计和、最小和最大" class="headerlink" title="12.22 输入五个 100 数之内的字符，统计和、最小和最大"></a>12.22 输入五个 100 数之内的字符，统计和、最小和最大</h2><pre><code class="hljs bash">COUNT=1
SUM=0
MIN=0
MAX=100

<span class="hljs-keyword">while</span> [<span class="hljs-variable">$COUNT</span> -le 5]; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入 1 - 10 个整数：&quot;</span> INT
  <span class="hljs-keyword">if</span> [[! <span class="hljs-variable">$INT</span> =~ ^[0-9]+$ ]]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;输入必须是整数！&quot;</span>
    <span class="hljs-built_in">exit</span> 1
  <span class="hljs-keyword">elif</span> [[<span class="hljs-variable">$INT</span> -gt 100]]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;输入必须是 100 以内！&quot;</span>
    <span class="hljs-built_in">exit</span> 1
  <span class="hljs-keyword">fi</span>
SUM=$((<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$INT</span>))
[<span class="hljs-variable">$MIN</span> -lt <span class="hljs-variable">$INT</span>] &amp;&amp; MIN=<span class="hljs-variable">$INT</span>
[<span class="hljs-variable">$MAX</span> -gt <span class="hljs-variable">$INT</span>] &amp;&amp; MAX=<span class="hljs-variable">$INT</span>
<span class="hljs-built_in">let</span> COUNT++
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;SUM: <span class="hljs-variable">$SUM</span>&quot;</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;MIN: <span class="hljs-variable">$MIN</span>&quot;</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;MAX: <span class="hljs-variable">$MAX</span>&quot;</span></code></pre>

<h2 id="12-23-将结果分别赋值给变量"><a href="#12-23-将结果分别赋值给变量" class="headerlink" title="12.23 将结果分别赋值给变量"></a>12.23 将结果分别赋值给变量</h2><pre><code class="hljs bash">方法 1 ：
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;4 5 6&quot;</span>); <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">eval</span> a<span class="hljs-variable">$i</span>=<span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$a4</span> <span class="hljs-variable">$a5</span> <span class="hljs-variable">$a6</span>

方法 2 ：将位置参数 192.168.18.1&#123;1,2&#125; 拆分为到每个变量
num=0
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">eval</span> <span class="hljs-built_in">echo</span> $*);<span class="hljs-keyword">do</span> <span class="hljs-comment">#eval 将 &#123;1,2&#125; 分解为 1 2</span>
  <span class="hljs-built_in">let</span> num+=1
  <span class="hljs-built_in">eval</span> node<span class="hljs-variable">$&#123;num&#125;</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$node1</span> <span class="hljs-variable">$node2</span> <span class="hljs-variable">$node3</span>
<span class="hljs-comment"># bash a.sh 192.168.18.1&#123;1,2&#125;</span>
192.168.18.11 192.168.18.12

方法 3 ：
arr=(4 5 6)
INDEX1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[0]&#125;</span>)
INDEX2=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[1]&#125;</span>)
INDEX3=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[2]&#125;</span>)</code></pre>

<h2 id="12-24-批量修改文件名"><a href="#12-24-批量修改文件名" class="headerlink" title="12. 24 批量修改文件名"></a>12. 24 批量修改文件名</h2><pre><code class="hljs bash"><span class="hljs-comment"># touch article_&#123;1..3&#125;.html</span>
<span class="hljs-comment"># ls</span>
article_1.html article_2.html article_3.html</code></pre>

<p>现在想把 article 改为 bbs：</p>
<pre><code class="hljs bash">方法 1 ：
<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(ls *html); <span class="hljs-keyword">do</span>
  mv <span class="hljs-variable">$file</span> bbs_<span class="hljs-variable">$&#123;file#*_&#125;</span>
<span class="hljs-comment"># mv $file $(echo $file |sed - r &#x27;s/.*(_.*)/bbs\1/&#x27;)</span>
<span class="hljs-comment"># mv $file $(echo $file |echo bbs_$(cut - d_ - f2)</span>
<span class="hljs-keyword">done</span>

方法 2 ：
<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(find. -maxdepth 1 -name <span class="hljs-string">&quot;*html&quot;</span>); <span class="hljs-keyword">do</span>
  mv <span class="hljs-variable">$file</span> bbs_<span class="hljs-variable">$&#123;file#*_&#125;</span>
<span class="hljs-keyword">done</span>

方法 3 ：
<span class="hljs-comment"># rename article bbs *.html</span></code></pre>

<h2 id="12-25-统计当前目录中以-html-结尾的文件总大小"><a href="#12-25-统计当前目录中以-html-结尾的文件总大小" class="headerlink" title="12.25 统计当前目录中以 .html 结尾的文件总大小"></a>12.25 统计当前目录中以 .html 结尾的文件总大小</h2><pre><code class="hljs bash">方法 1 ：
<span class="hljs-comment"># find. -name &quot;*.html&quot; -maxdepth 1 -exec du -b &#123;&#125; \; |awk &#x27;&#123;sum+=$1&#125;END&#123;print sum&#125;&#x27;</span>

方法 2 ：
<span class="hljs-keyword">for</span> size <span class="hljs-keyword">in</span> $(ls -l *.html |awk <span class="hljs-string">&#x27;&#123;print $5&#125;&#x27;</span>); <span class="hljs-keyword">do</span>
  sum=$((<span class="hljs-variable">$sum</span>+<span class="hljs-variable">$size</span>))
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$sum</span>
递归统计：
<span class="hljs-comment"># find. -name &quot;*.html&quot; -exec du -k &#123;&#125; \; |awk &#x27;&#123;sum+=$1&#125;END&#123;print sum&#125;&#x27;</span></code></pre>

<h2 id="12-26-扫描主机端口状态"><a href="#12-26-扫描主机端口状态" class="headerlink" title="12.26 扫描主机端口状态"></a>12.26 扫描主机端口状态</h2><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
HOST=<span class="hljs-variable">$1</span>
PORT=<span class="hljs-string">&quot;22 25 80 8080&quot;</span>
<span class="hljs-keyword">for</span> PORT <span class="hljs-keyword">in</span> <span class="hljs-variable">$PORT</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> &amp;&gt;/dev/null &gt; /dev/tcp/<span class="hljs-variable">$HOST</span>/<span class="hljs-variable">$PORT</span>; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$PORT</span> open&quot;</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$PORT</span> close&quot;</span>
  <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-27-Expect-实现-SSH-免交互执行命令"><a href="#12-27-Expect-实现-SSH-免交互执行命令" class="headerlink" title="12.27 Expect 实现 SSH 免交互执行命令"></a>12.27 Expect 实现 SSH 免交互执行命令</h2><p>需要先安装 <code>expect</code> 工具。</p>
<p>expect 涉及用法说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>可以设置超时，也可以设置变量</td>
</tr>
<tr>
<td>timeout</td>
<td>超时等待时间，默认 10s</td>
</tr>
<tr>
<td>spawn</td>
<td>执行一个命令</td>
</tr>
<tr>
<td>expect “”</td>
<td>匹配输出的内容</td>
</tr>
<tr>
<td>exp_continue</td>
<td>继续执行下面匹配</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>$argc</td>
<td>统计位置参数数量</td>
</tr>
<tr>
<td>[lindex $argv 0]</td>
<td>位置参数</td>
</tr>
<tr>
<td>puts</td>
<td>打印字符串，类似于 echo</td>
</tr>
<tr>
<td>expect{…}</td>
<td>输入多行记录</td>
</tr>
</tbody></table>
<p><strong>方法 1 ：EOF 标准输出作为 expect 标准输入</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
USER=root
PASS=123.com
IP=192.168.1.120
expect &lt;&lt; EOF
<span class="hljs-built_in">set</span> timeout 30
spawn ssh <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span>
expect &#123;
<span class="hljs-string">&quot;(yes/no)&quot;</span> &#123;send <span class="hljs-string">&quot;yes\r&quot;</span>; exp_continue&#125;
<span class="hljs-string">&quot;password:&quot;</span> &#123;send <span class="hljs-string">&quot;<span class="hljs-variable">$PASS</span>\r&quot;</span>&#125;
&#125;
expect <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>@*&quot;</span> &#123;send <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>\r&quot;</span>&#125;
expect <span class="hljs-string">&quot;<span class="hljs-variable">$USER</span>@*&quot;</span> &#123;send <span class="hljs-string">&quot;exit\r&quot;</span>&#125;
expect eof
EOF</code></pre>

<p><strong>方法 2 ：</strong></p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
USER=root
PASS=123.com
IP=192.168.1.120
expect -c <span class="hljs-string">&quot;</span>
<span class="hljs-string">  spawn ssh <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span></span>
<span class="hljs-string">  expect &#123;</span>
<span class="hljs-string">    \&quot;(yes/no)\&quot; &#123;send \&quot;yes\r\&quot;; exp_continue&#125;</span>
<span class="hljs-string">    \&quot;password:\&quot; &#123;send \&quot;<span class="hljs-variable">$PASS</span>\r\&quot;; exp_continue&#125;</span>
<span class="hljs-string">    \&quot;<span class="hljs-variable">$USER</span>@*\&quot; &#123;send \&quot;df -h\r exit\r\&quot;; exp_continue&#125;</span>
<span class="hljs-string">  &#125;&quot;</span></code></pre>

<p><strong>方法 3 ：将 expect 脚本独立出来</strong></p>
<p>login.exp 登录文件：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/expect</span>
<span class="hljs-built_in">set</span> ip [lindex <span class="hljs-variable">$argv</span> 0]
<span class="hljs-built_in">set</span> user [lindex <span class="hljs-variable">$argv</span> 1]
<span class="hljs-built_in">set</span> passwd [lindex <span class="hljs-variable">$argv</span> 2]
<span class="hljs-built_in">set</span> cmd [lindex <span class="hljs-variable">$argv</span> 3]
<span class="hljs-keyword">if</span> &#123;<span class="hljs-variable">$argc</span> != 4&#125; &#123;
  puts <span class="hljs-string">&quot;Usage: expect login.exp ip user passwd&quot;</span>
  <span class="hljs-built_in">exit</span> 1
&#125;
<span class="hljs-built_in">set</span> timeout 30
spawn ssh <span class="hljs-variable">$user</span>@<span class="hljs-variable">$ip</span>
expect &#123;
  <span class="hljs-string">&quot;(yes/no)&quot;</span> &#123;send <span class="hljs-string">&quot;yes\r&quot;</span>; exp_continue&#125;
  <span class="hljs-string">&quot;password:&quot;</span> &#123;send <span class="hljs-string">&quot;<span class="hljs-variable">$passwd</span>\r&quot;</span>&#125;
&#125;
expect <span class="hljs-string">&quot;<span class="hljs-variable">$user</span>@*&quot;</span> &#123;send <span class="hljs-string">&quot;<span class="hljs-variable">$cmd</span>\r&quot;</span>&#125;
expect <span class="hljs-string">&quot;<span class="hljs-variable">$user</span>@*&quot;</span> &#123;send <span class="hljs-string">&quot;exit\r&quot;</span>&#125;
expect eof</code></pre>

<p>执行命令脚本：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
HOST_INFO=user_info
<span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> $(awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)
<span class="hljs-keyword">do</span>
  user=$(awk -v I=<span class="hljs-string">&quot;<span class="hljs-variable">$ip</span>&quot;</span> <span class="hljs-string">&#x27;I==$1&#123;print $2&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)
  pass=$(awk -v I=<span class="hljs-string">&quot;<span class="hljs-variable">$ip</span>&quot;</span> <span class="hljs-string">&#x27;I==$1&#123;print $3&#125;&#x27;</span> <span class="hljs-variable">$HOST_INFO</span>)
  expect login.exp <span class="hljs-variable">$ip</span> <span class="hljs-variable">$user</span> <span class="hljs-variable">$pass</span> <span class="hljs-variable">$1</span>
<span class="hljs-keyword">done</span></code></pre>

<p>SSH 连接信息文件：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># cat user_info</span>
192.168.1.120 root 123 456</code></pre>

<h2 id="12-28-批量修改服务器用户密码"><a href="#12-28-批量修改服务器用户密码" class="headerlink" title="12.28 批量修改服务器用户密码"></a>12.28 批量修改服务器用户密码</h2><p>旧密码 SSH 主机信息 old_info 文件：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># ip user passwd port</span>
<span class="hljs-comment">#--------------------------------------</span>
192.168.18.217 root 123456 22
192.168.18.218 root 123456 22</code></pre>

<p>修改密码脚本：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
OLD_INFO=old_info
NEW_INFO=new_info
<span class="hljs-keyword">for</span> IP <span class="hljs-keyword">in</span> $(awk <span class="hljs-string">&#x27;/^[^#]/&#123;print $1&#125;&#x27;</span> <span class="hljs-variable">$OLD_INFO</span>); <span class="hljs-keyword">do</span>
  USER=$(awk -v I=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;I==$1&#123;print $2&#125;&#x27;</span> <span class="hljs-variable">$OLD_INFO</span>)
  PASS=$(awk -v I=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;I==$1&#123;print $3&#125;&#x27;</span> <span class="hljs-variable">$OLD_INFO</span>)
  PORT=$(awk -v I=<span class="hljs-variable">$IP</span> <span class="hljs-string">&#x27;I==$1&#123;print $4&#125;&#x27;</span> <span class="hljs-variable">$OLD_INFO</span>)
  NEW_PASS=$(mkpasswd -l 8)
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IP</span> <span class="hljs-variable">$USER</span> <span class="hljs-variable">$NEW_PASS</span> <span class="hljs-variable">$PORT</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$NEW_INFO</span>
  expect -c <span class="hljs-string">&quot;</span>
<span class="hljs-string">  spawn ssh -p<span class="hljs-variable">$PORT</span> <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$IP</span></span>
<span class="hljs-string">  set timeout 2</span>
<span class="hljs-string">  expect &#123;</span>
<span class="hljs-string">    \&quot;(yes/no)\&quot; &#123;send \&quot;yes\r\&quot;;exp_continue&#125;</span>
<span class="hljs-string">    \&quot;password:\&quot; &#123;send \&quot;<span class="hljs-variable">$PASS</span>\r\&quot;;exp_continue&#125;</span>
<span class="hljs-string">    \&quot;<span class="hljs-variable">$USER</span>@*\&quot; &#123;send \&quot;echo \&#x27;<span class="hljs-variable">$NEW_PASS</span>\&#x27;|passwd --stdin <span class="hljs-variable">$USER</span>\rexit\r\&quot;;exp_continue&#125;</span>
<span class="hljs-string">  &#125;&quot;</span>
<span class="hljs-keyword">done</span></code></pre>
<p>生成新密码 new_info 文件：</p>
<pre><code class="hljs bash">192.168.18.217 root n8wX3mU% 22
192.168.18.218 root c87;ZnnL 22</code></pre>

<h2 id="12-29-打印乘法口诀"><a href="#12-29-打印乘法口诀" class="headerlink" title="12.29 打印乘法口诀"></a>12.29 打印乘法口诀</h2><pre><code class="hljs bash">方法 1 ：
<span class="hljs-comment"># awk &#x27;BEGIN&#123;for(n=0;n++&lt;9;)&#123;for(i=0;i++&lt;n;)printf i&quot;x&quot;n&quot;=&quot;i*n&quot; &quot;;print&quot;&quot;&#125;&#125;&#x27;</span>

方法 2 ：
<span class="hljs-keyword">for</span> ((i=1;i&lt;=9;i++)); <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">for</span> ((j=1;j&lt;=i;j++)); <span class="hljs-keyword">do</span>
    result=$((<span class="hljs-variable">$i</span>*<span class="hljs-variable">$j</span>))
    <span class="hljs-built_in">echo</span> - n <span class="hljs-string">&quot;<span class="hljs-variable">$j</span>*<span class="hljs-variable">$i</span>=<span class="hljs-variable">$result</span>&quot;</span>
  <span class="hljs-keyword">done</span>
  <span class="hljs-built_in">echo</span>
<span class="hljs-keyword">done</span></code></pre>

<h2 id="12-30-getopts-工具完善脚本命令行参数"><a href="#12-30-getopts-工具完善脚本命令行参数" class="headerlink" title="12.30 getopts 工具完善脚本命令行参数"></a>12.30 getopts 工具完善脚本命令行参数</h2><p>getopts 是一个解析脚本选项参数的工具。</p>
<p>命令格式：getopts optstring name [arg]</p>
<p>初次使用你要注意这几点：</p>
<ul>
<li>1 ）脚本位置参数会与 optstring 中的单个字母逐个匹配，如果匹配到就赋值给 name，否则赋值 name 为问号；</li>
<li>2 ）optstring 中单个字母是一个选项，如果字母后面加冒号，表示该选项后面带参数，参数值并会赋值给 OPTARG 变量；</li>
<li>3 ）optstring 中第一个是冒号，表示屏蔽系统错误（test.sh: illegal option – h）；</li>
<li>4 ）允许把选项放一起，例如 - ab</li>
</ul>
<p>下面写一个打印文件指定行的简单例子，用于引导你思路，扩展你的脚本选项功能：</p>
<pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">while</span> <span class="hljs-built_in">getopts</span> :f:n: option; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">case</span> <span class="hljs-variable">$option</span> <span class="hljs-keyword">in</span>
  f)
    FILE=<span class="hljs-variable">$OPTARG</span>
    [! -f <span class="hljs-variable">$FILE</span>] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$FILE</span> File not exist!&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span>
  ;;
  n)
    sed -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;OPTARG&#125;</span>p&quot;</span> <span class="hljs-variable">$FILE</span>
  ;;
  ?)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$0</span> -f &lt;file_path&gt; -n &lt;line_number&gt;&quot;</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-f, --file specified file&quot;</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-n, --line-number print specified line&quot;</span>
    <span class="hljs-built_in">exit</span> 1
  ;;
  <span class="hljs-keyword">esac</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment"># bash test.sh -h</span>
Usage: test.sh -f &lt;file_path&gt; -n &lt;line_number&gt;

-f, --file specified file
-n, --line-number <span class="hljs-built_in">print</span> specified line

<span class="hljs-comment"># bash test.sh -f /etc/passwd -n 1</span>
root:x:0:0:root:/root:/bin/bash</code></pre>

<p>思路扩展：限定脚本参数，将参数保存变量，下面调用变量继续操作。</p>
<blockquote>
<p>作者信息 李振良（阿良），微信：init 1024<br>官方网站 <a target="_blank" rel="noopener" href="http://www.ctnrs.com/">http://www.ctnrs.com</a></p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Linux/">Linux</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/10/zabbix_host/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Zabbix 5.0 LTS 添加主机及监控</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/24/linux_base/">
                        <span class="hidden-mobile">Linux 运维基本功学习路径</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  





  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
